<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Adobe RoboHelp 8" />
<title>Theory of Operation</title>
<link rel="StyleSheet" href="../Bookshelf.css" type="text/css" />
<script type="text/javascript" language="JavaScript">
//<![CDATA[
function ehlp_showtip(current,e,text)
{
  if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == 'Netscape'))
  {
    document.tooltip.document.write("<layer bgColor='yellow' style='border:1px solid black;font-size:12px;'>"+ text + "<\/layer>");
    document.tooltip.document.close();
    document.tooltip.left=e.pageX+5;
    document.tooltip.top=e.pageY+5;
    document.tooltip.visibility="show";
  }
}
function ehlp_hidetip()
{
  document.tooltip.visibility="hidden";
}
//]]>
</script>
<script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
        origWidth = innerWidth;
        origHeight = innerHeight;
        onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
/*<![CDATA[*/
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
-->
/*]]>*/
</style>

<script type="text/javascript" language="javascript1.2" src="../whmsg.js">
</script>
<script type="text/javascript" language="javascript" src="../whver.js">
</script>
<script type="text/javascript" language="javascript1.2" src="../whproxy.js">
</script>
<script type="text/javascript" language="javascript1.2" src="../whutils.js">
</script>
<script type="text/javascript" language="javascript1.2" src="../whlang.js">
</script>
<script type="text/javascript" language="javascript1.2" src="../whtopic.js">
</script>
</head>
<body>
<script type="text/javascript" language="javascript1.2">
//<![CDATA[
<!--
if (window.gbWhTopic)
{
        var strUrl = document.location.href;
        var bc = 0;
        var n = strUrl.toLowerCase().indexOf("bc-");
        if(n != -1)
        {
                document.location.href = strUrl.substring(0, n);
                bc = strUrl.substring(n+3);
        }

        if (window.addTocInfo)
        {
        addButton("show",BTN_TEXT,"Show Table of Contents","","","","",0,0,"","","");

        }
        if (window.writeBtnStyle)
                writeBtnStyle();

        if (window.writeIntopicBar)
                writeIntopicBar(1);

        
        

        if (window.setRelStartPage)
        {
        setRelStartPage("../Bookshelf.htm");

                autoSync(0);
                sendSyncInfo();
                sendAveInfoOut();
        }
}
else
        if (window.gbIE4)
                document.location.reload();

//-->
//]]>
</script><script type="text/javascript" language="JavaScript1.2" src="../ehlpdhtm.js">
</script><script type="text/javascript" language="javascript">
//<![CDATA[
document.write("<p  style=\"text-align:right;color:#0000ff;font-family:Arial;font-size:7pt;font-weight: normal;font-style: normal;text-decoration: none;\">");
AddMasterBreadcrumbs("../Bookshelf.htm", "color:#0000ff;font-family:Arial;font-size:7pt;font-weight: normal;font-style: normal;text-decoration: none;", "&gt;", "Home", "index.htm");
document.write("Theory of Operation<\/p>");
//]]>
</script>
<p>&#160;</p>
<h1><a name="MiniTOCBookMark1" id="MiniTOCBookMark1"></a><img src="../Shared_Images/square.gif" alt="square.gif" style="border: none;" width="15" height="15" border="0" /> Welcome to GroundWork Monitor 6.6</h1>
<h3 align="right"><a href="index.htm"><img src="../Shared_Images/homeicon.gif" alt="homeicon.gif" style="border: none;" width="33" height="27" border="0" /></a> <img src="../Shared_Images/printicon.gif" onclick="window.print()" alt="Print Page" title="Print Page" style="border: none;" width="31" height="27" border="0" /> <a href="mailto:support@groundworkopensource.com?subject=Theory of Operation" title="Send Comments"><img src="../Shared_Images/commentsicon.gif" alt="commentsicon.gif" style="border: none;" width="33" height="27" border="0" /></a></h3>
<p><span class="PageTitle">GroundWork Monitor Theory of Operation</span></p>
<p align="left">Table&#160;of&#160;Contents:&#160;<a class="dropspot" href="javascript:TextPopup(this)" id="MTHotSpot47100" name="MTHotSpot47100"><span class="MTText">Show</span><span class="MTText" style="display: none;">Hide</span></a></p>
<script type="text/javascript" language="JavaScript1.2">
//<![CDATA[
TextPopupInit('MTHotSpot47100', 'MTPOPUP47100');
//]]>
</script>
<div align="left" class="droptext" id="MTPOPUP47100" style="display: none;">
<ul style="text-align:left; list-style-type: circle;">
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark2">Chapter 1 - Technology Overview</a>
<ul style="list-style-type: circle;">
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark3">The Logical Information Model</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark4">The Software Architecture</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark5">The Configuration Tier</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark6">The Instrumentation Tier</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark7">The Collection Tier</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark8">The Visualization Tier</a></li>
</ul>
</li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark9">Chapter 2 - Procedural Overview</a>
<ul style="list-style-type: circle;">
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark10">Resource Configuration</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark11">Command and Service Definitions</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark12">Host Definitions</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark13">The Data Collection Cycle</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark14">The Nagios Command Scheduler</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark15">The Nagios Command Processor</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark16">The Nagios Passive Interface</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark17">Information Processing</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark18">State Tracking</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark19">The GroundWork Foundation Database</a></li>
<li style="margin-left: 0px;margin-top: 0px;"><a href="#MiniTOCBookMark20">Performance Data</a></li>
</ul>
</li>
</ul>
</div>
<h2><a name="MiniTOCBookMark2" id="MiniTOCBookMark2"></a>Chapter 1 - Technology Overview</h2>
<p><span style="font-style: italic;"><i>GroundWork Monitor</i></span> combines modular open source technologies with a unified information management subsystem to provide a low cost and consistently managed monitoring solution that is also extremely flexible. This is achieved through the use of a loosely-coupled component-based architecture, whereby a core set of data-management services provide collection and control functions while independent and self-contained instrumentation and visualization components provide the input and output services that are needed to manage a specific network. By using this approach, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> is able to provide a stable and consistent monitoring platform, while also allowing for an almost unlimited number of monitoring and reporting tools to be implemented as discrete components.</p>
<h3><a name="MiniTOCBookMark3" id="MiniTOCBookMark3"></a>The Logical Information Model</h3>
<p>From a high-level perspective, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> uses an abstract information model comprised of four distinct logical tiers, as illustrated in the diagram below. First, components in the <span style="font-style: italic;"><i>Configuration</i></span> tier define the network resources that need to be monitored, and also describe how monitoring data should be processed after it has been gathered. Once the resources have been defined, task-specific instrumentation components (<span style="font-style: italic;"><i>Instrumentation</i></span> tier) are used to collect sampling data through a variety of different monitoring interfaces. After that, integration tools in the <span style="font-style: italic;"><i>Collection</i></span> tier gather up the data for processing and storage. Finally, web applications in the <span style="font-style: italic;"><i>Visualization</i></span> tier at the top of the model retrieve and display the information to the users.</p>
<p>This loosely-coupled component-based approach provides a managed yet extensible framework that ensures data flows through the system in a consistent and predictable way, while also allowing <span style="font-style: italic;"><i>GroundWork Monitor</i></span> users to deploy the monitoring and reporting tools that are needed for each specific network environment. As such, customers can mold <span style="font-style: italic;"><i>GroundWork Monitor</i></span> to suit the specific needs of their own environment, while still preserving a consistent information management model.</p>
<p class="Caption">Figure: Logical Information Model</p>
<p class="Figure"><img src="Assets/welcome_toologicalinformationmodel.gif" alt="Logical Information Model" title="Logical Information Model" style="border: none; margin-right: 0px; margin-left: 0px; margin-top: 5px; margin-bottom: 5px;" width="500" height="278" border="0" /></p>
<h3><a name="MiniTOCBookMark4" id="MiniTOCBookMark4"></a>The Software Architecture</h3>
<p>Although the information model is useful for thinking about the way information flows through the system, it's also important to recognize that it is a highly abstracted representation of the overall architecture, and does not always fully mirror the system-level mechanics.</p>
<p>In particular, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> makes heavy use of several independent open source tools and technologies, most of which are self-contained entities in their own right. However, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> does not force these component tools into a fixed framework, but instead allows the constituent tools and technologies to operate in their native modes, and then relies on integration technologies to tie the otherwise independent components into the broader monitoring platform. This approach preserves the power and capabilities of the individual components, while also ensuring that the overall information flow delivers the necessary level of functionality.</p>
<p>This concept is illustrated in the figure below, which shows the major components of <span style="font-style: italic;"><i>GroundWork Monitor</i></span> along with many of the commonly used component tools. As can be seen from that example, a fully-configured <span style="font-style: italic;"><i>GroundWork Monitor</i></span> system can have multiple discrete components performing their own task-specific functions, while the information management toolkit provides the integration technologies that are needed to bridge the individual components into a unified and cohesive monitoring platform.</p>
<p>As stated earlier, the logical information model can be used as a reference guide to help understand how information flows through the system, and this remains true even when multiple components are involved. Regardless of the number of components in use, resources are still described by the Configuration subsystem, while sampling data is still retrieved by components in the Instrumentation tier, then stored and processed by the Collection tier, and eventually read for display by one or more tools in the Visualization tier.</p>
<p>Using the information model to examine the Software Architecture diagram, we can see that the Configuration tier governs the behavior of the <span style="font-style: italic;"><i>Instrumentation</i></span> and <span style="font-style: italic;"><i>Collection</i></span> tiers. In particular, this tier is responsible for cataloging the network resources that need to be monitored, which is subsequently reflected in all of the other tiers. However, this tier is also responsible for describing the monitoring components that are used by the <span style="font-style: italic;"><i>Instrumentation</i></span> tier to gather the actual readings, and it is also responsible for controlling how the resulting data is eventually processed and stored in the <span style="font-style: italic;"><i>Collection</i></span> tier.</p>
<p class="Caption">Figure: Software Architecture</p>
<p class="Figure"><img src="Assets/welcome_toosoftwarearchitecture.gif" alt="Software Architecture" title="Software Architecture" style="border: none; margin-left: 0px; margin-right: 0px; margin-top: 5px; margin-bottom: 5px;" width="500" height="293" border="0" /></p>
<p>Next, the <span style="font-style: italic;"><i>Collection</i></span> tier incorporates the shared databases and integration tools that are needed to tie the independent components into a cohesive system. Parts of this subsystem provide embedded database tables that store global resource definitions (such as host and service assets), as well as embedded database tables for the collected data readings, but this tier also includes some standalone databases that are specific to some of the individual components (such as the round-robin database files that store long-term performance readings for historical graphing). Apart from the database components, this tier also contains tools that perform the necessary integration tasks (such as pulling data from external log files, or pushing configuration changes out to the discrete components), as well as development tools that provide controlled access to the shared databases and system management services.</p>
<p>Finally, the top of the stack contains the web-based applications that constitute the <span style="font-style: italic;"><i>Visualization</i></span> tier. The <span style="font-style: italic;"><i>JBoss Portal</i></span> is an open source and standards-based environment for hosting and serving a portal's Web interface and publishing and managing its content. The <span style="font-style: italic;"><i>JBoss Portal</i></span> unites <span style="font-style: italic;"><i>GroundWork Monitor</i></span> web applications into a common presentation framework. <span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes a variety of web applications ranging from single-purpose tools that display the contents of a specific database, to complex applications that pull data from multiple sources simultaneously, and can also integrate wholly separate web applications from remote hosts if needed.</p>
<p>Taken as a whole, the loosely-coupled component-based architecture provides a tremendous amount of flexibility. On the one hand, the structured information model provides a consistent platform that facilitates extensibility without sacrificing manageability, while the use of modular component technologies within each tier also allows administrators to customize the monitoring platform to reflect the requirements of their specific network. This concept is explored further throughout the remainder of this paper, which discusses the tiers of the information model and their constituent component technologies in greater detail.</p>
<h3><a name="MiniTOCBookMark5" id="MiniTOCBookMark5"></a>The Configuration Tier</h3>
<p>Although the configuration tasks are not a formal part of the formal data-gathering and processing cycle, they still play a crucial part of the overall information flow.</p>
<p>For one thing, the <span style="font-style: italic;"><i>Configuration</i></span> tier is where network resources are itemized, which in turn affects almost all of the other components across the system. This includes the low-level monitoring data that is initially gathered for each of the itemized network resources, but also includes the components in the <span style="font-style: italic;"><i>Collection</i></span> tier that have to map secondary data sources to known resources, and even includes lightweight components such as the lists of known hosts and services that are used by some of the reporting tools. In this regard, the configuration tools in this tier affect everything else that the system does, and are absolutely crucial to the successful operation of <span style="font-style: italic;"><i>GroundWork Monitor</i></span>, even if these components are not directly used in the ongoing data-processing cycle.</p>
<p>Beyond the basic configuration tasks, the <span style="font-style: italic;"><i>Configuration</i></span> tier also affects how the other two lower tiers function - it controls how the resource-specific data is gathered by the <span style="font-style: italic;"><i>Instrumentation</i></span> tier, and it also tells the data-processing tools what to do with the data after it has been collected (such as whether or not the performance readings should be recorded into the long-term performance databases).</p>
<p>For example, the main component in this tier is a web-based configuration front-end to Nagios that is based on the open source <span style="font-style: italic;"><i>Monarch</i></span> configuration tool that is separately published by <span style="font-style: italic;"><i>GroundWork</i></span>. Specifically, the configuration tool stores the <span style="font-style: italic;"><i>Nagios</i></span> configuration settings into an application-specific embedded database table, and then uses integration scripts to synchronize the configuration tables with the <span style="font-style: italic;"><i>GroundWork Monitor</i></span> asset database. Once the configuration has been finalized, back-end scripts generate the actual <span style="font-style: italic;"><i>Nagios</i></span> configuration files, and also update any other application-specific configuration repositories that the system knows about.</p>
<p>This specific arrangement has the primary benefit of relieving administrators from having to configure <span style="font-style: italic;"><i>Nagios</i></span> control files by hand, but more importantly it also becomes possible to ensure that all of the other components have the exact same view of the network, meaning that administrators are further relieved from having to reconfigure all the other components after every change to Nagios. This approach also makes it much simpler to extend <span style="font-style: italic;"><i>Nagios</i></span> with new features and add-ons, which in turn contribute to the power of <span style="font-style: italic;"><i>Nagios</i></span> itself.</p>
<h3><a name="MiniTOCBookMark6" id="MiniTOCBookMark6"></a>The Instrumentation Tier</h3>
<p><img src="Assets/welcome_tooinstrumentationtier1.gif" alt="SSH Wrapper" title="SSH Wrapper" style="border: none; margin-right: 10px; margin-bottom: 10px; margin-left: 0px; margin-top: 0px;" width="105" height="286" align="left" border="0" />Although <span style="font-style: italic;"><i>GroundWork Monitor</i></span> supports many different tools for gathering monitoring data, it uses the open source <span style="font-style: italic;"><i>Nagios</i></span> monitoring toolkit as its primary instrumentation mechanism. This is largely due to the fact that <span style="font-style: italic;"><i>Nagios</i></span> has an open and lightweight textual plug-in interface that can work with almost any command-line tool, and this simple and open interface has resulted in a huge library of <span style="font-style: italic;"><i>Nagios</i></span> plug-ins being developed that can collectively monitor thousands of different sensors and variables, with very little effort required by the system administrator.</p>
<p>Just for starters, <span style="font-style: italic;"><i>Nagios</i></span> includes a variety of Linux scripts and utilities that can be used to fetch operating system details from the local server, including things like disk and memory usage, CPU utilization levels, and other types of system information, with all of this information being obtained by simply executing a local command and parsing the response text. But since <span style="font-style: italic;"><i>Nagios</i></span> uses a lightweight command-based interface for these tools, it is also possible to pull the same kind of data from other systems simply by calling on a redirection mechanism of some kind.</p>
<p>For example, <span style="font-style: italic;"><i>Nagios</i></span> provides a generic SSH wrapper that allows the "local" Linux utilities and scripts to be executed on remote systems, simply by creating the appropriate SSH user and session keys and then copying the desired tools to the target systems. In this setup, <span style="font-style: italic;"><i>Nagios</i></span> calls the SSH wrapper tool with parameters that identify the target host and the remote command to be executed, while the remote output is passed back to <span style="font-style: italic;"><i>Nagios</i></span> for processing. More importantly, the SSH wrapper is not specifically limited to the bundled <span style="font-style: italic;"><i>Nagios</i></span> commands, and in fact can be used with any command as long as the target program has the ability to return an appropriately formatted response. As such, <span style="font-style: italic;"><i>Nagios</i></span> is able to use the SSH wrapper to query almost any kind of networked platform, as long as the target command can return a compatible textual response.</p>
<p><img src="Assets/welcome_tooinstrumentationtier2.gif" alt="NRPE Plugin" title="NRPE Plugin" style="border: none; margin-left: 10px; margin-right: 0px; margin-top: 0px; margin-bottom: 0px;" width="105" height="449" align="right" border="0" /><span style="font-style: italic;"><i>Nagios</i></span> also supports remote command execution through a Nagios-specific client-server protocol called NRPE which is similar to SSH but more direct. In this model, remote systems run an NRPE listener, while the Nagios server uses an NRPE client to connect with remote hosts and issue local commands, with the command output subsequently being returned to the Nagios server. As with the SSH interface, the NRPE listener allows any remote command to be executed as long as the target program is able to return a properly formatted response.</p>
<p><span style="font-style: italic;"><i>GroundWork</i></span> also provides a version of NRPE for Windows which includes a collection of VBScript utilities for gathering Windows-specific data through WMI calls. Since WMI also works over the network, the <span style="font-style: italic;"><i>GroundWork Monitor</i></span> port of NRPE for Windows also has the inherent ability to function as a WMI proxy for an entire network of Windows devices, whereby the <span style="font-style: italic;"><i>GroundWork Monitor</i></span> server simply identifies the target Windows host in a parameter to the VBScript commands.</p>
<p><span style="font-style: italic;"><i>Nagios</i></span> also provides a variety of tools for performing network-level tests, such as ICMP "ping" tests that simply check for host availability and responsiveness, as well as TCP/IP probes that can see if a specific port is responding to connection requests within an acceptable threshold. Nagios also provides the ability to actively test network applications by utilizing the network protocols themselves, such as logging into a remote mail server, or querying for a well-known DNS domain name, with all of these tests ensuring that the target service is actually functioning correctly and not just listening for incoming connections.</p>
<p><img src="Assets/welcome_tooinstrumentationtier3.gif" alt="SNMP Plugin" title="SNMP Plugin" style="border: none; margin-left: 0px; margin-right: 10px; margin-top: 0px; margin-bottom: 0px;" width="105" height="229" align="left" border="0" />Naturally, <span style="font-style: italic;"><i>Nagios</i></span> also supports the use of SNMP, which allows it to be used for everything from network device probes to detailed system queries, with the only restriction being the number of SNMP MIBs available. As with the other plug-ins, <span style="font-style: italic;"><i>Nagios</i></span> calls a local SNMP client and provides it with the target host and SNMP MIB to query, while the client returns the collected data to Nagios in the necessary format.</p>
<p>Apart from the probe-based plug-ins, Nagios also provides a "passive" monitoring interface that allows autonomous tools to gather information independently from the Nagios scheduler, with these tools recording important output into log files that <span style="font-style: italic;"><i>Nagios</i></span> processes during each scheduled run. If <span style="font-style: italic;"><i>Nagios</i></span> finds any new event messages in these files at the next polling interval, the data is picked up and processed the same as if it were a regular monitoring event.</p>
<p><img src="Assets/welcome_tooinstrumentationtier4.gif" alt="Passive Monitoring" title="Passive Monitoring" style="border: none; margin-left: 10px; margin-bottom: 0px; margin-right: 10px; margin-top: 0px;" width="230" height="240" align="right" border="0" />Commercial versions of <span style="font-style: italic;"><i>GroundWork Monitor</i></span> include plug-ins that capture and filter syslog messages and SNMP traps and then pass the resulting messages to Nagios over the passive interface, both of which allow <span style="font-style: italic;"><i>Nagios</i></span> to be informed of asynchronous, out-of-band events that might otherwise be missed by the poll-based tools. On a more general level, Nagios also provides a network protocol called NSCA that allows remote systems to push local command output to Nagios' passive interface across the network, which effectively allows multiple independent monitoring systems to feed monitoring data to a single master server for storage purposes.</p>
<p>Cumulatively, the number and breadth of available plug-ins make Nagios an exceptionally powerful monitoring system that is capable of detecting almost any kind of critical event. However, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also makes use of other <span style="font-style: italic;"><i>Nagios</i></span> component technologies which are equally as powerful, such as the alarm and escalation system that allows administrative personnel to be notified whenever a critical event occurs. Meanwhile, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also uses the open <span style="font-style: italic;"><i>Nagios</i></span> interfaces to add additional value back to <span style="font-style: italic;"><i>Nagios</i></span> itself (such as the syslog and SNMP trap extensions described above), but also by integrating <span style="font-style: italic;"><i>Nagios</i></span> with RRDtool, which allows long-term performance data to be captured and graphed by <span style="font-style: italic;"><i>Nagios</i></span> directly.</p>
<p>As stated earlier, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also supports a variety of additional monitoring and instrumentation tools, and also provides programming interfaces that allow whole new monitoring tools to be developed in case an existing solution is not feasible for a particular monitoring task.</p>
<h3><a name="MiniTOCBookMark7" id="MiniTOCBookMark7"></a>The Collection Tier</h3>
<p>In simple terms, the <span style="font-style: italic;"><i>Collection</i></span> tier of <span style="font-style: italic;"><i>GroundWork Monitor</i></span> provides the glue that binds the Instrumentation and <span style="font-style: italic;"><i>Visualization</i></span> tiers together. More specifically, this tier contains the databases that are of interest to the system as a whole, and also provides the integration tools that bridge the independent components into the overall system. Most of the components in this tier are provided by an open source package known as <span style="font-style: italic;"><i>GroundWork Foundation</i></span>, although some of the independent software packages also provide additional functionality that has been rolled into this tier.</p>
<p>For data storage, <span style="font-style: italic;"><i>GroundWork Foundation</i></span> uses a collection of embedded database tables that provide globally-relevant data (such as object tables that store state information for all of the monitored hosts and services), as well as event tables that store records of all significant monitoring events (such as warning messages that have been generated by <span style="font-style: italic;"><i>Nagios</i></span>). By storing this data in a common location, it can be accessed and used by multiple tools under a common access-control framework.</p>
<p>Separately, <span style="font-style: italic;"><i>GroundWork</i></span> also provides a collection of control scripts and programming libraries that provide integration services to the components that need it. The control scripts provide active integration services that move information around as needed, such as moving event records from Nagios to the appropriate database table. Meanwhile, the Perl, PHP, Java and SOAP programming libraries included with <span style="font-style: italic;"><i>GroundWork Foundation</i></span> provide passive interfaces to applications when they need to interact with the system directly.</p>
<p>Apart from the <span style="font-style: italic;"><i>Foundation</i></span> package, the <span style="font-style: italic;"><i>Collection</i></span> tier also contains some other globally-useful technologies that are sourced from other packages. The most obvious examples of this can be found in the Nagios control services that are crucial to the operation of <span style="font-style: italic;"><i>GroundWork Monitor</i></span> as a whole. For example, <span style="font-style: italic;"><i>Nagios</i></span> provides tools that allow the administrator to immediately probe a specific device for its current condition, and <span style="font-style: italic;"><i>GroundWork Monitor</i></span> incorporates this tool into the <span style="font-style: italic;"><i>Collection</i></span> tier rather than replicate the functionality in separate tools.</p>
<p>Similarly, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> uses the RRD toolkit to store and graph long-term performance data, and as such the RRD database and graphing service fall within the scope of the <span style="font-style: italic;"><i>Collection</i></span> tier, even though the technology is sourced from the RRD component instead of the <span style="font-style: italic;"><i>Foundation</i></span> package.</p>
<h3><a name="MiniTOCBookMark8" id="MiniTOCBookMark8"></a>The Visualization Tier</h3>
<p>The top tier in the <span style="font-style: italic;"><i>GroundWork Monitor</i></span> architecture is the <span style="font-style: italic;"><i>Visualization</i></span> tier, which contains the web applications that are used to display data managed by the <span style="font-style: italic;"><i>Collection</i></span> tier. There are a dozen or so web applications included in <span style="font-style: italic;"><i>GroundWork Monitor</i></span> by default, a primary component in this tier is the <span style="font-style: italic;"><i>JBoss Portal</i></span> framework and as mentioned previously the <span style="font-style: italic;"><i>JBoss Portal</i></span> unites <span style="font-style: italic;"><i>GroundWork Monitor</i></span> web applications into a common presentation framework. For detailed information regarding <span style="font-style: italic;"><i>JBoss</i></span> see: <img src="../Shared_Images/gray_book_closed.gif" alt="gray_book_closed.gif" style="border: none;" width="18" height="15" border="0" /><span style="font-weight: bold;"><b>OPEN SOURCE REFERENCE <img src="../Shared_Images/ref_page.gif" alt="ref_page.gif" style="border: none;" width="14" height="14" border="0" /><a title="About JBoss" href="../Open_Source_Reference/osr_jbossportal.htm" onmouseover="if ((parseInt(navigator.appVersion) == 4) &amp;&amp; (navigator.appName == 'Netscape')) ehlp_showtip(this,event,'About JBoss');" onmouseout="if ((parseInt(navigator.appVersion) == 4) &amp;&amp; (navigator.appName == 'Netscape')) ehlp_hidetip();">JBoss</a></b></span>.</p>
<p><span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes several applications that are integrated into the basic package. For example, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes a status viewer application that provides an overview of a specific host or service by incorporating data from multiple sources, including summary information from the <span style="font-style: italic;"><i>Foundation</i></span> database, graphs from the RRD subsystem, and log messages from events that are stored in <span style="font-style: italic;"><i>Foundation</i></span>. In addition, the status viewer also includes controls that allow the user to manipulate and probe the <span style="font-style: italic;"><i>Nagios</i></span> view of the target resource by way of the <span style="font-style: italic;"><i>Nagios</i></span> control interface.</p>
<p>Meanwhile, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes a console application that provides a simple table view of the <span style="font-style: italic;"><i>Foundation</i></span> event database, which allows network operators to become aware of problems as soon as they have been detected.</p>
<p><span style="font-style: italic;"><i>GroundWork Monitor</i></span> also provides several tools for generating long-term analytical reports. First, <span style="font-style: italic;"><i>Nagios</i></span> has its own ability to produce simple graphs of per-host or per-service availability data, all of which are available through the Nagios web interface. Meanwhile, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also include an "Reports" application which presents significant historical events across multiple hosts and services simultaneously, providing a snapshot view of the complete network. Separately, commercial versions of <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also include the open source BIRT reporting tool which allows for the creation of hand-tailored reports.</p>
<h2><a name="MiniTOCBookMark9" id="MiniTOCBookMark9"></a>Chapter 2 - Procedural Overview</h2>
<p>As was discussed in Chapter 1, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> combines modular open source monitoring and presentation tools with a unified information management subsystem, resulting in a highly extensible yet consistently managed monitoring platform.</p>
<p>From a high-level architectural perspective, these components fall into one of four tiers - <span style="font-style: italic;"><i>Configuration</i></span>, <span style="font-style: italic;"><i>Instrumentation</i></span>, <span style="font-style: italic;"><i>Collection</i></span>, and <span style="font-style: italic;"><i>Visualization</i></span> - with information flowing through the system as it is specified, gathered, processed, and ultimately displayed. However, this is a highly abstracted view of the overall monitoring process, and the actual data-processing mechanics can often be somewhat more elaborate than the logical model suggests, especially as additional software components and functions are enabled.</p>
<p>This is largely due to the fact that <span style="font-style: italic;"><i>GroundWork Monitor</i></span> makes heavy use of open source component technologies that frequently have their own information processing models, while <span style="font-style: italic;"><i>GroundWork Monitor</i></span> relies on integration tools to bring those components into the information model. As such, the software in use tends to be much more important towards day-to-day operations, while the logical information model is most useful as a reference tool for understanding how information flows through the system.</p>
<p>Chapter 1 described the logical information model that is used by <span style="font-style: italic;"><i>GroundWork Monitor</i></span> and also discussed the major system components as they fit within the context of that architecture. In this chapter, we will examine the information flow from the perspective of the individual software components themselves.</p>
<h3><a name="MiniTOCBookMark10" id="MiniTOCBookMark10"></a>Resource Configuration</h3>
<p>Although the configuration tasks may not seem to be a formal part of the ongoing data-collection and processing cycle, they play a crucial part of the overall information flow in <span style="font-style: italic;"><i>GroundWork Monitor</i></span>. At a bare minimum, resources must be defined before they can be monitored or displayed to the end-user, and as such the configuration process determines everything else that will happen in the system later. However, the configuration process also affects a variety of subordinate components (such as performance graphing and event collation) which are less obvious but just as critical to the long-term satisfactory use of the system.</p>
<p>Architecturally, the basic unit of data in <span style="font-style: italic;"><i>GroundWork Monitor</i></span> is the measurement reading that is taken at a specific time for a specific resource on a specific host. Before this data can be collected, however, the system administrator must first define the target host, and must also define the services on that host which need to be monitored. Administrators must also specify the data that they want to collect - do they only want the basic availability information, or do they also want to capture numeric performance readings historical analysis? - and they must also assign general options such as scheduling intervals and notification contacts. Once a resource and all of its necessary options have been defined, a command scheduler will periodically execute the appropriate monitoring tool for that resource, thereby producing a sample reading for the resource in question. From there, the measurement data is subsequently used to perform additional tasks throughout <span style="font-style: italic;"><i>GroundWork Monitor</i></span>, according to the options that have been defined.</p>
<p>The process of defining a resource and its options is managed through the <span style="font-style: italic;"><i>Configuration</i></span> tier, and specifically the open source <span style="font-style: italic;"><i>GroundWork Monarch</i></span> configuration tool for <span style="font-style: italic;"><i>Nagios</i></span>. This application presents data-entry screens and forms to the user via a web interface, while reading and storing the configuration settings into an embedded database on the back-end. Once the administrator decides to commit the configuration, additional processing is invoked which generates the configuration files and databases that are needed by the individual software components. In this manner, all of the different software components throughout <span style="font-style: italic;"><i>GroundWork Monitor</i></span> are guaranteed to always have a consistent view of the hosts and services that are being monitored, without requiring the administrator to configure each component separately.</p>
<h3><a name="MiniTOCBookMark11" id="MiniTOCBookMark11"></a>Command and Service Definitions</h3>
<p>Resource definitions in <span style="font-style: italic;"><i>Nagios</i></span> use a nested chain of templates and profiles, each of which define a particular aspect of a common resource type. A complete resource definition is constructed by linking the templates and profiles to a specific instance of a specific resource on a specific target device.</p>
<p>The most atomic unit in this model is the command definition, which essentially provides a plug-in definition that tells <span style="font-style: italic;"><i>Nagios</i></span> how to monitor a particular resource type. The command definition specifies the program or script that will be called, as well as any options that are needed for the plug-in to function. <span style="font-style: italic;"><i>Nagios</i></span>-specific variables (also known as "macros") that will be expanded at run-time can also be used in the command definition, which allows resource-specific parameter values to be filled in as they are needed.</p>
<p>For example, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> provides a command definition called "check_tcp" shown in the diagram to the right, that allows <span style="font-style: italic;"><i>Nagios</i></span> to test if a particular TCP port on a specific host is listening for incoming connection requests. The full command definition specifies a path to the program, a "-H" option and "$HOSTADDRESS$" variable that specifies the target host, and a "-p" option and "$ARG1$" variable that specifies the target port number. The use of variables in the command definition means that this single command can be used to construct multiple probes, simply by filling in the variable data with target-specific data.</p>
<p class="Caption">Figure: Command Definition</p>
<p class="Figure"><img src="Assets/welcome_toocommandandservice1.gif" alt="Command and Service Definitions" title="Command and Service Definitions" style="border: none; margin-right: 0px; margin-left: 0px; margin-top: 5px; margin-bottom: 5px;" width="500" height="278" border="0" /></p>
<p>It's important to understand that the command definition is not processed by <span style="font-style: italic;"><i>Nagios</i></span> directly, but instead is only used to define a plug-in that can be called upon later. Once a command definition has been created, it is ultimately mapped to one or more resources, with the resulting resource-specific command being used to monitor the specific resource. Put more simply, the command definition merely provides a building block for defining the actual resource monitors later. <span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes several dozen predefined command definitions for this purpose, ranging from simple tools like the one shown above, all the way up to advanced tools that connect with application services on remote hosts to collect application-specific readings.</p>
<p>Apart from the command definition, resource monitors in Nagios also requires that certain kinds of governance data also be defined for each monitoring job. Whereas the command definitions describe the basic command-line to be used, the governance data describes control elements, such as the desired polling frequency, the persons to contact if a critical event is detected.</p>
<p>These values can be entered manually when a resource is defined, but they are usually defined in a service template, which is a reusable object similar to the command definition. By default, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes a single "generic-service" template that uses the most common settings, but additional templates can be defined if some resources need different control settings (such as needing to have different administrative contacts).</p>
<p><img src="Assets/welcome_toocommandandservice2.gif" alt="Command and Service Definitions" title="Command and Service Definitions" style="border: none; margin-left: 0px; margin-right: 10px; margin-top: 0px; margin-bottom: 10px;" width="233" height="100" align="left" border="0" />The combination of a command definition and its associated governance data produces a service definition, which cumulatively defines the monitoring behavior for a specific type of resource. Service definitions can inherit all of the attributes from the command definition and service template, or administrators can override some of the attributes, either by filling in variable values from the underlying command definition, or by replacing the governance data from the service template with service-specific values.</p>
<p>For example, the "check_tcp" command definition described earlier has a command-line variable for specifying the target port number. By explicitly defining this variable value as "80" (for HTTP) or "25" (for SMTP), it's possible for the single command definition to be used as a cornerstone for multiple service definitions. Conversely, a generic "check_tcp" service definition could also be created that simply left these variable values undefined, thereby allowing the port number variable to be populated when the specific resource itself is defined.</p>
<p><span style="font-style: italic;"><i>GroundWork Monitor</i></span> includes several dozen predefined service definitions, and additional service definitions can be created as they are needed, either by defining new command definitions or service templates, or simply by changing the values that already exist.</p>
<p><img src="Assets/welcome_toocommandandservice3.gif" alt="Command and Service Definitions" title="Command and Service Definitions" style="border: none; margin-left: 10px; margin-right: 0px; margin-top: 0px; margin-bottom: 10px;" width="434" height="125" align="right" border="0" /> <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also allows multiple service definitions to be linked together as part of a service profile, which can be helpful when a common set of service definitions need to be defined for multiple hosts. For example, if you have a few dozen email systems that all have SMTP and POP3 servers, you can create an "Internet Email" service profile that references the appropriate service definitions, and then apply the service profile to those hosts without needing to explicitly apply each individual service definition to each host. Service profiles can be defined as they are needed, and <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also includes several dozen predefined profiles in the box.</p>
<h3><a name="MiniTOCBookMark12" id="MiniTOCBookMark12"></a>Host Definitions</h3>
<p>Host definitions follow many of the same principles as command and service definition, albeit with some significant differences. In particular, a host definition does not require the multiple layers of abstraction found in command and service definitions, but instead only needs to have an IP address or hostname, along with some host-specific control data. In the latter case, host templates are typically used in the same way as service templates, and satisfy the same kind of purposes (IE, some hosts need different administrative contacts).</p>
<p class="Figure"><img src="Assets/welcome_toohostdefinitions.gif" alt="Host Definitions" title="Host Definitions" style="border: none; margin-right: 0px; margin-left: 0px; margin-bottom: 0px; margin-top: 5px;" width="576" height="98" border="0" /></p>
<p>At the next level of abstraction, host profiles are the combination of a host template and one or more service profiles. For example, you can have a generic "Windows Server" host profile that combines a generic host template with service profiles for system-level SNMP and WMI lookups, along with WMI-based Exchange queries and the Internet email service profile discussed earlier. From there it would be a simple matter of applying the host template to all of the Windows-based Exchange servers on your network.</p>
<p><span style="font-style: italic;"><i>Nagios</i></span> also allows individual host definitions to be grouped into logical hierarchies through the use of host groups. Host groups can have some basic attribute definitions (such as a specific contact group or escalation tree), but they are most often used for filtering and sorting purposes by the presentation tools. By default, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> provides a "Linux Servers" host group that only contains the local system, but host groups can be created to represent any kind of logical grouping that may be desired. For example, you can have host groups that refer to geographic locations, or organizational divisions, or any other kind of arrangement that may be desired. <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also allows you to predefine a host group within a host profile, so that the organizational hierarchy is imposed on all of the affected host definitions.</p>
<p>Taken as a whole, the judicious use of templates, profiles and host groups allows an administrator to pre-configure almost any resource imaginable. For example, a web server at an off-site data-center might have a host template that notifies a third-party service provider about hardware-level errors, while a "ping" service profile notifies the hosting provider of network reachability problems, while application specific service profiles notify internal help-desk staff of application issues, with all of these settings being predefined in various templates and/or profiles. As stated earlier however, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> also allows hosts and their resources to be manually defined if needed, overriding the profile and template settings.</p>
<p>Furthermore, the use of templates and profiles within the configuration application (and specifically its underlying relational database) allows for some fairly robust inheritance capabilities. For example, if the contact group for a specific service definition needs to be changed, then the administrator only needs to change the associated service template, and the new contact information will be automatically inherited by all of the associated service definitions the next time the configuration data is saved.</p>
<h3><a name="MiniTOCBookMark13" id="MiniTOCBookMark13"></a>The Data Collection Cycle</h3>
<p>In <span style="font-style: italic;"><i>GroundWork Monitor</i></span>, almost all of the regular data-collection duties are carried out by <span style="font-style: italic;"><i>Nagios</i></span>. Although <span style="font-style: italic;"><i>GroundWork Monitor</i></span> supports the use of independent and autonomous monitoring tools, and also provides its own development libraries and APIs for custom monitoring solutions, Nagios is almost always the preferred method of collecting monitor data due to the fact that its simple and lightweight textual interface is remarkably easy to work with. As a result, Nagios has a large library of service definitions that are already included in <span style="font-style: italic;"><i>GroundWork Monitor</i></span>, while many others are available for download from third-party Internet sites. For most needs, it is very likely that a suitable <span style="font-style: italic;"><i>Nagios</i></span> plug-in already exists.</p>
<p><span style="font-style: italic;"><i>Nagios</i></span> provides three crucial functions to the data-collection phase of the overall information flow. First, it provides a command scheduler that intelligently coordinates plug-in processing across all of the defined resources. The second critical function is the execution of the raw plug-in commands, which is the where the monitoring data is actually gathered. Finally, <span style="font-style: italic;"><i>Nagios</i></span> examines the plug-in response data, and takes additional action based on the response that was received. These three functions are completed in linear fashion, with the cycle continuously repeating for as long as a resource definition exists.</p>
<h3><a name="MiniTOCBookMark14" id="MiniTOCBookMark14"></a>The Nagios Command Scheduler</h3>
<p>Whenever the <span style="font-style: italic;"><i>Nagios</i></span> service is restarted, it takes a survey of all the defined hosts and their associated resources, and then populates a rotating schedule of commands to execute. The formula that is used to create the command schedule can be somewhat arcane, involving multiple algorithms and variables, but the basic principle behind the algorithm is that Nagios tries to evenly distribute the rate at which it will execute commands. This helps to ensure that the local server does not get overloaded when a new polling period begins, and it also helps to prevent target servers from being overloaded with complex queries. Without these precautions in place, Nagios could easily become the source of problems that it subsequently believes to have detected.</p>
<p>One of the major parts of this formula involves distributing all of the service definitions across the available time window in an even fashion. Essentially, this is achieved by dividing the average polling interval by the number of resource definitions in the command queue, which yields an evenly spaced set of execution intervals.</p>
<p>In addition, the <span style="font-style: italic;"><i>Nagios</i></span> command scheduler also interleaves queries on a per-host basis so that the target systems do not get hit with all their queries simultaneously. This is achieved by dividing the number of resource definitions by the number of active host definitions, with the resulting value being used as a "skip" value. <span style="font-style: italic;"><i>Nagios</i></span> begins the scheduling process by adding the first command to the first opening in the schedule window, then skips ahead in the command queue by the determined "skip value" and adds the next command to the current slot in the schedule. This process is continually repeated until all of the commands have been added to all of the slots in the command schedule.</p>
<p>Taken together, these techniques allow the <span style="font-style: italic;"><i>Nagios</i></span> scheduler to issue commands at a reasonably low rate, while also spreading the query volume across all of the servers in a reasonably even manner. This concept is illustrated in the diagram below, which shows how eight discrete monitoring tasks for three different hosts would theoretically be distributed across a 10-minute polling window. In that example, the 10-minute window is broken into eight 1.25-minute intervals, with a skip value of "3". The first command from the first host is placed into the first available slot, then the scheduler moves three places and adds the second command from the first host to that slot, and so forth, with this process repeating until all of the commands have been added to the scheduler.</p>
<p class="Caption">Figure: Command Scheduler</p>
<p class="Figure"><img src="Assets/welcome_toonagioscommandscheduler.gif" alt="Minute Intervals" title="Minute Intervals" style="border: none; margin-right: 0px; margin-left: 0px; margin-top: 5px; margin-bottom: 5px;" width="500" height="193" border="0" /></p>
<p>Although the above explanation covers the most important factors in determining how commands are scheduled, it's important to recognize that there are many other variables and options that are taken into consideration when the <span style="font-style: italic;"><i>Nagios</i></span> command queue is being filled, and the two mechanisms described above are by no means the only criteria (for a detailed description of the full algorithm and all of its variables, please refer to <a href="http://nagios.sourceforge.net/docs/2_0/checkscheduling.html">the Nagios documentation</a>.</p>
<p>Furthermore, sometimes an external event can also affect how a command is processed, regardless of how the command was originally scheduled. For example, every host definition has a special service definition that is used to determine whether or not the host is online. If this test indicates that the target host has become unreachable, then other service checks for that host may be suspended, resulting in the resource-specific commands being skipped at their next scheduled interval.</p>
<p>It is also possible to have more resource definitions than the Nagios server can monitor in the allowed polling interval, which may result in scheduled commands being deferred or skipped. Generally speaking, the maximum number of commands that can be executed within the available polling window will vary according to CPU and memory availability on the local and remote hosts, network bandwidth and latency, the complexity of the command, the length of time required to fully process each command, and other such factors. As a rule, Nagios will always attempt to execute as many monitoring jobs as it can, but if you consume all of your available computing resources with too many probes, the remaining jobs will be rescheduled, potentially resulting in incomplete monitoring runs.</p>
<h3><a name="MiniTOCBookMark15" id="MiniTOCBookMark15"></a>The Nagios Command Processor</h3>
<p>The <span style="font-style: italic;"><i>Nagios</i></span> command interface is the central point for the collection of monitoring data. It is the facility where monitoring commands are executed and response data is read and captured. This is perhaps the most important subsystem in the entire <span style="font-style: italic;"><i>GroundWork Monitor</i></span> collection, given that it is where all of the data collected by Nagios is initially obtained.</p>
<p>The <span style="font-style: italic;"><i>Nagios</i></span> command interface is remarkably simple, especially considering its importance. Essentially, <span style="font-style: italic;"><i>Nagios</i></span> does nothing more than expand whatever variables have been defined for the service definition at hand, submits the full command line to the operating system for processing, and then reads the response output.</p>
<p>As was discussed earlier, resource monitoring in Nagios uses command definitions that are mapped to service definitions, which are in turn mapped to a specific resource on a specific host, with variable values in the underlying command-line being filled in by the service definition or the resource-specific definition, as needed. As this relates to the <span style="font-style: italic;"><i>Nagios</i></span> command interface, the command-line that is used by <span style="font-style: italic;"><i>Nagios</i></span> is sourced from the final resource definition, since that is the last point where variable substitution can occur.</p>
<p>For general status measurement, <span style="font-style: italic;"><i>Nagios</i></span> uses four different response codes: "OK" responses indicate that the monitored resource is operating within its normal bounds, while a "WARNING" response means that the resource is operating outside normal bounds but is not in a crisis condition (yet), while "CRITICAL" means that the resource is either not operating or has reached a crisis condition, and "UNKNOWN" means that some other condition has occurred that the command does not know how to interpret. The status responses are primarily provided as POSIX return codes through STDERR, with "0" meaning "OK", "1" meaning "WARNING", "2" meaning "CRITICAL", and "3" meaning "UNKNOWN".</p>
<p>However, <span style="font-style: italic;"><i>Nagios</i></span> also expects textual response data to appear in STDOUT, with this data typically providing the textual equivalent of the status response codes along with any error text that may be needed for alerting and notification purposes, as well as any measurement data that may be needed for performance monitoring.</p>
<p>Historically, <span style="font-style: italic;"><i>Nagios</i></span> has used a relatively free-form textual response, although most plug-ins use a format similar to "&lt;SERVICE&gt; &lt;STATUS&gt; - &lt;Textual message&gt;", where "&lt;SERVICE&gt;" is the service name, "&lt;STATUS&gt;" is a textual representation of the return codes described above, and "&lt;Textual message&gt;" is the free-form response message.</p>
<p>With the addition of performance monitoring, however, the response format was specifically amended to include structured data. In particular, plug-ins that return performance data are now required to append a vertical pipe symbol ("|") to the end of the free-form text message, with detailed performance data following the pipe character. The performance data is required to take the exact form of "&lt;label&gt;=&lt;value&gt;;&lt;warning-threshold&gt;;&lt;critical-threshold&gt;;&lt;minimum-value&gt;;&lt;maximum-value&gt;." This syntax provides all the information that is needed for a command to determine the current performance of a resource, relative to that specific resource. In those cases where a particular field is not appropriate, the data is omitted, but the semi-colon separators must still be provided. For more details on the response format rules, refer to the <a href="http://nagiosplug.sourceforge.net/developer-guidelines.html">Nagios plug-in developer's guide</a>.</p>
<h3><a name="MiniTOCBookMark16" id="MiniTOCBookMark16"></a>The Nagios Passive Interface</h3>
<p>Most service definitions use command-based probes to actively query a specific resource, but in some cases it can be preferable or even necessary to allow external probes and tools to bring the monitoring data to <span style="font-style: italic;"><i>Nagios</i></span> instead. This is especially useful with services that can generate spurious messages at somewhat random intervals, since those types of events cannot be easily monitored through <span style="font-style: italic;"><i>Nagios'</i></span> poll-based scheduler.</p>
<p>For example, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> provides tools that can pickup SNMP traps and SYSLOG messages independently of <span style="font-style: italic;"><i>Nagios</i></span>, and then use the passive interface to feed the event message into Nagios for additional processing (such as generating notification messages or event alarms). Meanwhile, <span style="font-style: italic;"><i>Nagios</i></span> also provides a network protocol called NSCA which allows remote systems to submit monitor results directly to Nagios, which in turn helps to alleviate load on the local server.</p>
<p>In these cases, external system processes queue up incoming messages for <span style="font-style: italic;"><i>Nagios</i></span> to process later, while the <span style="font-style: italic;"><i>Nagios</i></span> command scheduler also queues up "passive" checks that are executed in the same manner as regular commands. Whenever the passive check for a specific resource rolls around, <span style="font-style: italic;"><i>Nagios</i></span> reads the associated input, and then treats the discovered data as if it had been obtained from a "normal" command, with the data being essentially indistinguishable from that point forward.</p>
<h3><a name="MiniTOCBookMark17" id="MiniTOCBookMark17"></a>Information Processing</h3>
<p>Although <span style="font-style: italic;"><i>Nagios</i></span> collects response data as each command completes, it does not begin to process the command output right away, but instead places the response data into a global event queue for processing at the next available command interval (which may happen immediately, or may happen later if <span style="font-style: italic;"><i>Nagios</i></span> is busy on other tasks). Once an available command window rolls around, <span style="font-style: italic;"><i>Nagios</i></span> starts a "reaper" event that gathers up all of the output data that has been queued, and then parses through each of the recorded results.</p>
<p>As part of this process, <span style="font-style: italic;"><i>Nagios</i></span> first records details about the commands that were executed for each resource, along with the output that was returned from each of the commands. This logfile is subsequently read by the <span style="font-style: italic;"><i>GroundWork</i></span> integration scripts, which in turn updates the appropriate <span style="font-style: italic;"><i>Foundation</i></span> database tables; the status codes are stored in a basic state-tracking table that is used to monitor basic availability, while the free-form response text is stored in a log table that provides a textual view of historical events.</p>
<p>Separately, <span style="font-style: italic;"><i>Nagios</i></span> also records the collected performance data into another logfile so that it can be used to build long-term performance databases, if they have been requested. Every five minutes, the Nagios event processor executes a Perl script supplied with <span style="font-style: italic;"><i>GroundWork Monitor</i></span> that creates and appends the resource-specific round-robin databases with the collected performance data, which in turn allows the historical sampling data to be graphed by presentation tools.</p>
<p>Cumulatively, these repositories can provide a substantial amount of information about a particular resource. For example, the <span style="font-style: italic;"><i>Status</i></span> application in <span style="font-style: italic;"><i>GroundWork Monitor</i></span> uses all of the collected data to display summary information about a specific resource, including its current status, the major event messages which have been received, and the long-term performance readings. This concept is illustrated below and shows a typical view of the <span style="font-style: italic;"><i>Status</i></span> application, and also indicates the database sources that are used to build the web page. Data in block number <img src="../Shared_Images/1green.gif" alt="1green.gif" style="border: none;" width="25" height="25" border="0" /> contains summary information that was fed into <span style="font-style: italic;"><i>Foundation</i></span> from the <span style="font-style: italic;"><i>Nagios</i></span> status log file, while data in block <img src="../Shared_Images/2green.gif" alt="2green.gif" style="border: none;" width="25" height="25" border="0" /> contains the textual messages that have been associated with this specific resource, while data in block <img src="../Shared_Images/3green.gif" alt="3green.gif" style="border: none;" width="25" height="25" border="0" /> contains a graph that is created from the round-robin performance databases (which are themselves sourced from the Nagios performance logs).</p>
<p class="Caption">Figure: Status Application</p>
<p class="Figure"><img src="Assets/welcome_tooinformationprocessing.gif" alt="Information Processing" title="Information Processing" style="border: none;" width="700" height="1176" border="0" /></p>
<h3><a name="MiniTOCBookMark18" id="MiniTOCBookMark18"></a>State Tracking</h3>
<p>Apart from recording output messages into the various log files, the <span style="font-style: italic;"><i>Nagios</i></span> "reaper" process is also responsible for examining the response status, taking any action that may be required (such as generating an alarm), and then resubmitting the monitoring tasks to the command scheduler. Essentially, this portion of the output process is where <span style="font-style: italic;"><i>Nagios</i></span> determines if a resource is up or down, and if some kind of additional processing needs to occur.</p>
<p>The principle piece of information in this process is the return code from the plug-in that was used to query the resource in question. Resource definitions that return an "OK" status are simply noted, and their associated commands are resubmitted to the scheduler for execution at the next available interval. However, if a service returns a WARNING or CRITICAL status result, then Nagios will queue a request to probe the host itself to make sure that the target device itself is up and reachable.</p>
<p>If the host check for a failing service also returns a non-OK result, then Nagios assumes that the host is down, and takes whatever action has been specified for the target host as a whole. However, if the host check succeeds, then the specific resource is assumed to be in a failing state, and <span style="font-style: italic;"><i>Nagios</i></span> takes whatever action has been specified for that specific resource.</p>
<p>Services that return a non-OK status are determined to be in a "soft" error state until a specified number of attempts have been made, at which point the service will be flagged as being in a "hard" error state. Services that are flagged in either of these states can use event handlers to attempt some kind of automated recovery (event handlers are usually defined in the service and host templates, but can also be assigned globally if desired). When the service reaches a hard error state, notification messages will be issued to the appropriate contact.</p>
<h3><a name="MiniTOCBookMark19" id="MiniTOCBookMark19"></a>The GroundWork Foundation Database</h3>
<p>Although <span style="font-style: italic;"><i>GroundWork Monitor</i></span> does not replicate the entire Nagios status log locally, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> do copy some of the event data into an embedded database so that administrators have quick and easy access to the major events that have been recorded.</p>
<p>This data is primarily used by the <span style="font-style: italic;"><i>GroundWork Monitor Event Console</i></span> application, shown in the diagram below, but it is also incorporated into some other presentation tools as well (most notably the <span style="font-style: italic;"><i>Status</i></span> viewer application).</p>
<p class="Caption">Figure: Event Console</p>
<p class="Figure"><img src="Assets/welcome_toogwfoundationdb.gif" alt="Event Console" title="Event Console" style="border: none; margin-right: 0px; margin-left: 0px; margin-top: 5px; margin-bottom: 5px;" width="700" height="220" border="0" /></p>
<p>The number of records that are created and stored in the <span style="font-style: italic;"><i>GroundWork Foundation</i></span> database is determined by filters that the administrator defines. By default, the database only stores major events (such as major state changes), but it can capture as much information as the administrator desires. Likewise, critical information from the SYSLOG and SNMP Trap tools that are bundled into commercial versions of <span style="font-style: italic;"><i>GroundWork Monitor</i></span> can also be extracted and stored into the console table. In fact, the <span style="font-style: italic;"><i>Foundation</i></span> database can be extended to receive and store event data from practically any event source.</p>
<p>Event records in the <span style="font-style: italic;"><i>Event Console</i></span> application can be "cleared" when they have been acknowledged and dealt with by an operator, so that old records do not clutter the application view. However, the underlying events will remain in the database until they are manually purged, thereby allowing for long-term reporting and analysis to function properly.</p>
<p>Another critical aspect of this service comes from the way that the integration scripts can automatically eliminate duplicate records, which can help to reduce database overhead. For example, if two events occur that are considered identical, the database will simply update the "Last Inserted" field of the first entry with the timestamp from the last entry, and then increment the "Message Count" field to show that multiple instances of the same response have been detected. This algorithm can be changed if administrators require a different level of granularity, or if they need to specify different criteria for identifying identical messages.</p>
<h3><a name="MiniTOCBookMark20" id="MiniTOCBookMark20"></a>Performance Data</h3>
<p>In <span style="font-style: italic;"><i>GroundWork Monitor</i></span>, long-term storage of performance data is handled by the open source RRD toolkit, which provides "round-robin" databases and graphing functions that cumulatively allow for time-based views of historical readings. Essentially, the RRD toolkit uses fixed-length database files with a first-in, first-out rotation policy, and also uses a moving-average algorithm that consolidates and removes older data as new samples get added. As a result, short-term readings are always available in their raw, high-precision form, while older readings have a lower resolution as a result of the long-term averaging algorithm. This model allows a single database file to provide snapshot views at multiple time intervals, ranging from one minute to one year, while the underlying database files always remain at a fixed size.</p>
<p>The RRD databases are seeded by a Perl script provided with <span style="font-style: italic;"><i>GroundWork Monitor</i></span> that is executed by <span style="font-style: italic;"><i>Nagios</i></span>' job scheduler every few minutes. Whenever performance data for a monitored resource is discovered in the log file, the Perl script appends the data to the appropriate RRD database, or creates the database if it does not exist. However, it is also important to note that the Perl script provided with <span style="font-style: italic;"><i>GroundWork Monitor</i></span> does not explicitly require <span style="font-style: italic;"><i>Nagios</i></span> performance readings, and can instead infer performance data from other information if needed. For example, it can examine the time required to establish a connection with the remote target, and create a graph based on that data, instead of having to rely on the Nagios-specific performance readings.</p>
<p>In order for the Perl script to know which databases should be created and how the data should be captured and organized, <span style="font-style: italic;"><i>GroundWork Monitor</i></span> provides a separate <span style="font-style: italic;"><i>Performance</i></span> configuration option within the <span style="font-style: italic;"><i>Configuration</i></span> application solely for this purpose. This application allows the administrator to specify the types of services that need to have performance databases, how to map plug-in output to the RRD database files, how to parse the performance data, and how to update the RRD databases with new readings.</p>
<p>By default, the performance configuration system contains several pre-defined settings for frequently used service definitions, such as CPU and memory utilization, network interface traffic, system load, and other common metrics. If additional performance graphs for other resources are desired, they must be defined in the performance configuration tool before the RRD databases can be created, appended or graphed.</p>
<p>Another noteworthy aspect of this area is that RRD databases can store multiple readings in separate columns within a single file, if needed. This allows for complex graphs that refer to multiple types of readings (such as a network interface graph that shows the amount of traffic sent and received in a single view), but with the caveat that certain changes to the columns may require a new database to be created.</p>
<div style="width: 100%; position: relative;" id="footer">
<p class="Footer" style="font-size: 7pt; line-height: Normal; margin-top: 6pt; margin-bottom: 4pt;">GroundWork, Inc. ©2011</p>
</div>
<script type="text/javascript" language="JavaScript">
//<![CDATA[
 if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == 'Netscape'))
  document.write("<div id='tooltip' class='WebHelpPopupMenu'><\/div>");
//]]>
</script><script type="text/javascript" language="javascript1.2">
//<![CDATA[
<!--
if (window.writeIntopicBar)
        writeIntopicBar(0);


highlightSearch();
//-->
//]]>
</script>
</body>
</html>
