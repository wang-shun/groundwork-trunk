#!/usr/bin/perl -w --

# Copyright (c) 2010 by GroundWork Open Source, Inc.
# All rights reserved.

# Obfuscate a single file of C code.

# The intent is to carry out transformations to hide the intent of the code:
# (*) Preprocess all kinds of C symbols expressed as OBFN_readable_name
#     and turn them into seemingly random valid names which are consistent
#     across the entire program.
# (*) Encode literal strings expressed as OBFS_string("...") and
#     create both declarations for them (as seemingly random valid names)
#     and references to them in the code.  The references must decrypt
#     the string values before use.
# (*) Strip comments and blank lines from the code.
# Future versions may do even more.

my @inc     = ();
my @def     = ();
my %var     = ();
my %str     = ();
my %type    = ();
my %name    = ();
my %used    = ();
my $str_num = 0;
my $initial = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz';
my $remains = $initial . '_0123456789';

# You must choose this character wisely.  It cannot replicate any character
# used in your program's strings, or they will be truncated at that point,
# and the world will end.
my $hide_char = "0xAA";

# my %keywords = {
#     => 'EXIT_SUCCESS',
#     => 'FILE',
#     => 'NULL',
#     => 'argc',
#     => 'argv',
#     => 'atoi',
#     => 'char',
#     => 'const',
#     => 'do',
#     => 'else',
#     => 'fclose',
#     => 'fopen',
#     => 'for',
#     => 'if',
#     => 'int',
#     => 'main',
#     => 'my_bool',
#     => 'printf',
#     => 'regex_t',
#     => 'regmatch_t',
#     => 'return',
#     => 'static',
#     => 'strdup',
#     => 'strndup',
#     => 'struct',
#     => 'unsigned',
#     => 'while',
# };

main();

sub main {
    open_urandom();

    my $string_struct = <<EOF;
#include <string.h>

// You must choose this character wisely.  It cannot replicate any character
// used in your program's strings, or they will be truncated at that point.
static char OBFN_xor = $hide_char;

struct OBFN_string_struct
    {
    char *OBFN_string_addr;
    char *OBFN_string;
    };

char *OBFN_string_convert (struct OBFN_string_struct *OBFN_string_ptr)
    {
    if (!OBFN_string_ptr->OBFN_string_addr)
        {
	char *OBFN_ptr;
	OBFN_string_ptr->OBFN_string_addr = strdup(OBFN_string_ptr->OBFN_string);
	for (OBFN_ptr=OBFN_string_ptr->OBFN_string_addr;*OBFN_ptr;++OBFN_ptr)
	    {
	    *OBFN_ptr ^= OBFN_xor;
	    }
	}
    return (OBFN_string_ptr->OBFN_string_addr);
    }

EOF

    my @prelude = split (/\n/, $string_struct);
    for (@prelude) {
        $_ .= "\n";
    }

    my @input = ();
    push @input, <>;

    filter (\@prelude);
    filter (\@input);

    foreach my $v (keys %var) {
	$var{$v} = obfuscate_var($v);
    }

    foreach my $s (keys %str) {
	$var{$s} = obfuscate_var($s);
	$str{$s} = obfuscate_str($s, $str{$s});
    }
    close_urandom();

    my @strings = ();
    foreach my $s (keys %str) {
        push @strings, "struct OBFN_string_struct $var{$s} = { 0, \"$str{$s}\" };\n" 
    }

    my @declarations = ();
    my @functions = ();
    foreach my $f (keys %fun) {
	(my $raw_fun = $f) =~ s/OBFF_//;
	$type{$f} = 'void' if !$type{$f};
        push @declarations, "extern $type{$f} $raw_fun();\n";
        push @functions, "$type{$f} (*$var{$f})() = $raw_fun;\n";
    }

    for (@def, @inc, @prelude, @strings, @declarations, @functions, @input) {
	while (s/(OBFS_\w+)\s*\(\s*"(([^"]|\\")*)"\s*\)/
	    '('.$var{$1}.'.'.$var{OBFN_string_addr}.'?'.$var{$1}.'.'.$var{OBFN_string_addr}.':'.$var{OBFN_string_convert}.'(&'.$var{$1}.'))'
	    /xeg) {
	}
	while (/OBFN_\w+/) {
	    s/$&/$var{$&}/;
	}
	# FIX THIS:  we can't have this substitution in play for the actual
	# function definition, only for its invocations; because of this,
	# the support for OBFF_ is still experimental (in development)
	while (/OBFF_\w+/) {
	    s/$&/(*$var{$&})/;
	}
	print if $_ !~ /^\s+$/;
    }
}

sub filter {
    my $array_ref = shift;
    for (@$array_ref) {
	# FIX THIS:  This will wipe out http://... embedded within a string, and
	# not just comments; we need to figure out how to parse strings and not
	# perform this comment elision if this pattern is found inside a string.
	while (m{//}) {
	    $_ =~ s{//.*}{};
	}
	while (/OBFS_string\s*\(\s*"(([^"]|\\")*)"\s*\)/g) {
	    my $str_name = "OBFS_$str_num";
	    $str{$str_name} = condense($1);
	    s/OBFS_string/$str_name/;
	    ++$str_num;
	}
	while (/OBFN_\w+/g) {
	    $var{$&} = 1;
	}
	while (/\(([^()]+)\)\s*(OBFF_\w+)/g) {
	    # Capture the casted type for later use.  We don't yet support casts
	    # that include parentheses, but might do so in a later version.
	    $type{$2} = $1;
	}
	while (/OBFF_\w+/g) {
	    $var{$&} = 1;
	    $fun{$&} = 1;
	}
	while (/^\s*#\s*define\s/) {
	    push @def, $_;
	    $_ = '';
	}
	while (/^\s*#\s*include\s/) {
	    push @inc, $_;
	    $_ = '';
	}
    }
}

sub open_urandom {
    open URANDOM, '<', '/dev/urandom' or die 'Cannot open /dev/urandom';
}

sub close_urandom {
    close URANDOM;
}

sub entropy {
    my $base  = shift;
    my $len   = shift;
    my $chaos = undef;
    do  {
	# Use /dev/urandom and one of the drand48() functions repeatedly,
	# to pull together a string of length $len chosen from characters
	# in $remains.
	$chaos = '';
	while (length $chaos < $len) {
	    my $buf = '';
	    read URANDOM, $buf, 1;
	    $offset = int( (unpack('C', $buf) / 256) * length ($remains) );
	    $chaos .= substr $remains, $offset, 1;
	}
    } while ($used{$chaos});
    $used{$chaos} = 1;
    return $chaos;
}

sub obfuscate_var {
    my $var = shift;
    if (!$name{$var}) {
	my $offset = int( rand() * length($initial) );
	my $random = entropy($remains, 15);
	$name{$var} = (substr $initial, $offset, 1 ) . $random;
    }
    return $name{$var};
}

sub obfuscate_str {
    my $var = shift;
    my $str = shift;
    my $hex = unpack "H*", $str ^ ( chr(hex($hide_char)) x length($str) );
    $hex =~ s/\w\w/\\x$&/g;
    if ($hex =~ /x00/) {
	# Having a NUL character in the middle of the obfuscated string
	# will cause the C program to treat the string as truncated early,
	# which will change the behavior of the program when it tries to
	# unobfuscate the obfuscated copy.  That is not acceptable.  To
	# fix this for your particular program, choose a different value
	# for the hide character.
        die "ERROR:  Cannot safely obfuscate a string containing the hide character ($hide_char).\n";
    }
    return $hex;
}

# Handle all the possible constructions in a C string (except trigraphs, which are rarely used).
sub condense {
    my $str = shift;
    $str =~ s/\\\\/<<<backslash>>>/g;
    $str =~ s/\\n/\n/g;
    $str =~ s/\\r/\r/g;
    $str =~ s/\\t/\t/g;
    $str =~ s/\\f/\f/g;
    $str =~ s/\\a/\a/g;
    $str =~ s/\\b/\b/g;
    $str =~ s/\\v/\x0b/g;
    $str =~ s/\\'/'/g;
    $str =~ s/\\"/"/g;
    $str =~ s/\\[?]/?/g;
    $str =~ s/\\([0-7]{1,3})/chr(oct($1))/eg;
    $str =~ s/\\x([0-9a-fA-F]+)/chr(hex($1))/eg;
    $str =~ s/<<<backslash>>>/\\/g;
    return $str;
}

exit 0;
