# MonArch - Groundwork Monitor Architect
# MonarchDoc.pm
#
############################################################################
# Release 4.6
# June 2018
############################################################################
#
# Original author: Scott Parris
#
# Copyright 2007-2018 GroundWork Open Source, Inc. (GroundWork)
# All rights reserved. This program is free software; you can redistribute
# it and/or modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

use strict;

package Doc;

sub properties_doc(@) {
	my $obj   = $_[1];  # required arg
	my $props = $_[2];  # required arg
	my $view  = $_[3];  # optional arg
	my @props = @{$props};
	my %docs  = ();

	$docs{'override'} = q(Inherit all values from the template: set all directives in this section to inherit values from the template selected above. Uncheck the left checkbox on an individual directive to override that template value.);
	foreach my $prop (@props) {

# host template
		if ($obj eq 'host_templates' && $prop eq 'process_perf_data') {
			$docs{$prop} = q(Process perf data: Optional. This directive is used to determine whether or not the processing of performance data is enabled for hosts using this template. Values:  unchecked = disable performance data processing, checked = enable performance data processing.);
		} elsif ($obj eq 'host_templates' && $prop eq 'retain_status_information') {
			$docs{$prop} = q(Retain status information: Optional. This directive is used to determine whether or not status-related information about the host is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive. Value:  unchecked = disable status information retention, checked = enable status information retention.);
		} elsif ($obj eq 'host_templates' && $prop eq 'flap_detection_enabled') {
			$docs{$prop} = q(Flap detection enabled: Optional. This directive is used to determine whether or not flap detection is enabled for hosts using this template. Values:  unchecked = disable host flap detection, checked = enable host flap detection.);
		} elsif ($obj eq 'host_templates' && $prop eq 'low_flap_threshold') {
			$docs{$prop} = q(Low flap threshold: Optional. This directive is used to specify the low state change threshold used in flap detection for hosts using this template. If you set this directive to a value of 0, the program-wide value specified by the low_host_flap_threshold directive will be used.);
		} elsif ($obj eq 'host_templates' && $prop eq 'high_flap_threshold') {
			$docs{$prop} = q(High flap threshold: Optional. This directive is used to specify the high state change threshold used in flap detection for hosts using this template. If you set this directive to a value of 0, the program-wide value specified by the high_host_flap_threshold directive will be used.);
		} elsif ($obj eq 'host_templates' && $prop eq 'retain_nonstatus_information') {
			$docs{$prop} = q(Retain nonstatus information: Optional. This directive is used to determine whether or not non-status information about the host is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive. Value:  unchecked = disable non-status information retention, checked = enable non-status information retention.);
		} elsif ($prop eq 'checks_enabled') {
			$docs{$prop} = q(Checks enabled: Optional. This directive is used to determine whether or not checks of hosts using this template are enabled. Values:  unchecked = disable host checks, checked = enable host checks.);
		} elsif ($obj eq 'host_templates' && $prop eq 'active_checks_enabled') {
			$docs{$prop} = q(Active checks enabled: This directive is used to determine whether or not active checks (either regularly scheduled or on-demand) of this host are enabled. Values: unchecked = disable active host checks, checked = enable active host checks.);
		} elsif ($obj eq 'host_templates' && $prop eq 'passive_checks_enabled') {
			$docs{$prop} = q(Passive checks enabled: This directive is used to determine whether or not passive checks are enabled for this host. Values: uncehcked = disable passive host checks, checked = enable passive host checks.);
		} elsif ($obj eq 'host_templates' && $prop eq 'check_period') {
			$docs{$prop} = q(Check period: Required. This directive is used to specify the short name of the time period during which active checks of this host can be made.);
		} elsif ($obj eq 'host_templates' && $prop eq 'check_command') {
			$docs{$prop} = q(Host templates: Optional. This directive is used to specify the short name of the command that should be used to check if the host is up or down. Typically, this command would try to ping the host to see if it is 'alive'. The command must return a status of OK (0) or Nagios will assume the host is down. If you leave this argument blank, the host will not be checked -- Nagios will always assume the host is up. This is useful if you are monitoring printers or other devices that are frequently turned off. The maximum amount of time that the notification command can run is controlled by the host_check_timeout option.);
		} elsif ($obj eq 'host_templates' && $prop eq 'command_line') {
			$docs{$prop} = q(Command line: Optional, sets the default value. If check command requires arguments, enter the check command with command arguments separated by a ! character. Example: check_ping!3000.0,80%!5000.0,100%);
		} elsif ($obj eq 'host_templates' && $prop eq 'max_check_attempts') {
			$docs{$prop} = q(Max check attempts: Required. This directive is used to define the number of times that Nagios will retry the host check command if it returns any state other than an OK state. Setting this value to 1 will cause Nagios to generate an alert without retrying the host check again. Note:  If you do not want to check the status of the host, you must still set this to a minimum value of 1. To bypass the host check, just leave the check_command option blank.);
		} elsif ($obj eq 'host_templates' && $prop eq 'check_interval') {
			$docs{$prop} = q(Check interval: Optional. This directive defines the number of &quot;time units&quot; between regularly scheduled checks of the host. A value of 0 will disable regularly scheduled host checks (though on-demand host checks will still be possible if active host checks are enabled and a check command is configured). Otherwise, unless you've changed the interval_length directive from the default value of 60, this number will mean minutes.);
		} elsif ($obj eq 'host_templates' && $prop eq 'retry_interval') {
			$docs{$prop} = q(Retry interval: This directive is used to define the number of 'time units' to wait before scheduling a re-check of the hosts. Hosts are rescheduled at the retry interval when they have changed to a non-UP state. Once the host has been retried max_check_attempts times without a change in its status, it will revert to being scheduled at its 'normal' rate as defined by the check_interval value. Unless you've changed the interval_length directive from the default value of 60, this number will mean minutes.);
		} elsif ($obj eq 'host_templates' && $prop eq 'event_handler_enabled') {
			$docs{$prop} = q(Event handler enabled: Optional. This directive is used to determine whether or not the event handler for hosts using this template is enabled. Values:  unchecked = disable host event handler, checked = enable host event handler.);
		} elsif ($obj eq 'host_templates' && $prop eq 'event_handler') {
			$docs{$prop} = q(Event handler: Optional. This directive is used to specify the short name of the command that should be run whenever a change in the state of the host is detected (i.e., whenever it goes down or recovers). The maximum amount of time that the event handler command can run is controlled by the event_handler_timeout option.);
		} elsif ($obj eq 'host_templates' && $prop eq 'notifications_enabled') {
			$docs{$prop} = q(Notifications enabled: Optional. This directive is used to determine whether or not notifications for hosts using this template are enabled. Values:  unchecked = disable host notifications, checked = enable host notifications.);
		} elsif ($obj eq 'host_templates' && $prop eq 'notification_interval') {
			$docs{$prop} = q(Notification interval: Required. This directive is used to define the number of 'time units' to wait before re-notifying a contact that this server is still down or unreachable. Unless you've changed the interval_length directive from the default value of 60, this number will mean minutes. If you set this value to 0, Nagios will not re-notify contacts about problems for hosts using this template -- only one problem notification will be sent out.);
		} elsif ($obj eq 'host_templates' && $prop eq 'notification_period') {
			$docs{$prop} = q(Notification period: Required. This directive is used to specify the short name of the time period during which notifications of events for hosts using this template can be sent out to contacts. If a host goes down, becomes unreachable, or recoveries during a time which is not covered by the time period, no notifications will be sent out.);
		} elsif ($obj eq 'host_templates' && $prop eq 'notification_options') {
			$docs{$prop} = q(Notification options: Required. This directive is used to determine when notifications for the host should be sent out. Valid options are a combination of one or more of the following:  Down checked = send notifications on a DOWN state; Unreachable checked = send notifications on an UNREACHABLE state; and Recovery checked = send notifications on recoveries (OK state). If you specify n (None) as an option, no host notifications will be sent out. Example:  If you specify Down and Recovery, notifications will only be sent out when the host goes DOWN and when it recovers from a DOWN state.);
		} elsif ($obj eq 'host_templates' && $prop eq 'stalking_options') {
			$docs{$prop} = q(Stalking options: Optional. This directive determines which host states 'stalking' is enabled for. Valid options are a combination of one or more of the following:  Up checked = stalk on UP states, Down checked = stalk on DOWN states, and Unreachable checked = stalk on UNREACHABLE states.);
		} elsif ($obj eq 'host_templates' && $prop eq 'obsess_over_host') {
			$docs{$prop} = q(Obsess over host: This directive determines whether or not checks for the host will be 'obsessed' over using the ochp_command (defined in Nagios main configuration). checked = enabled);
		} elsif ($obj eq 'host_templates' && $prop eq 'check_freshness') {
			$docs{$prop} = q(Check freshness: This directive is used to determine whether or not freshness checks are enabled for hosts using this template. Checked = enable freshness checks.);
		} elsif ($obj eq 'host_templates' && $prop eq 'freshness_threshold') {
			$docs{$prop} = q(Freshness threshold: This directive is used to specify the freshness threshold (in seconds) for hosts using this template. If you set this directive to a value of 0, Nagios will determine a freshness threshold to use automatically.);
		} elsif ($obj eq 'host_templates' && $prop eq 'contactgroup') {
			$docs{$prop} = q(Contact groups: This is a list of the short names of the contact groups that should be notified whenever there are problems (or recoveries) with this host.);
# host dependencies
		} elsif ($obj eq 'host_dependencies' && $prop eq 'dependent_host') {
			$docs{$prop} = q(Dependent host: Required. This directive is used to identify the short name of the dependent host.);
		} elsif ($obj eq 'host_dependencies' && $prop eq 'master_host') {
			$docs{$prop} = q(Master host: Required. This directive is used to identify the short name of the host that is being depended upon.);
		} elsif ($obj eq 'host_dependencies' && $prop eq 'execution_failure_criteria') {
			$docs{$prop} = q(Execution failure criteria: Optional.  This directive is used to specify the criteria that determine when the dependent host should not be actively checked. If the master host is in one of the failure states you specify, the dependent host will not be actively checked. Valid options are a combination of one or more of the following (multiple options are separated with commas): o = fail on an UP state, d = fail on a DOWN state, u = fail on an UNREACHABLE state, and p = fail on a PENDING state (i.e., the host has not yet been checked). If you specify n (none) as an option, the execution dependency will never fail and the dependent host will always be actively checked (if other conditions allow for it to be). Example: If you specify u,d in this field, the dependent host will not be actively checked if the master host is in either an UNREACHABLE or DOWN state.);
		} elsif ($obj eq 'host_dependencies' && $prop eq 'inherits_dependencies') {
			$docs{$prop} = q(This directive indicates whether or not this dependency inherits dependencies of the host that is being depended upon (also referred to as the master host). In other words, if you have master host dependency inheritance enabled, the master host is dependent upon other hosts, and any one of those dependencies fails, this dependency will also fail.);
		} elsif ($obj eq 'host_dependencies' && $prop eq 'notification_failure_criteria') {
			$docs{$prop} = q(Notification failure criteria: Required. This directive is used to define the criteria that determine when notifications for the dependent host should not be sent out. If the master host is in one of the failure states you specify, notifications for the dependent host will not be sent to contacts. Valid options are a combination of one or more of the following:  o = fail on an UP state, d = fail on a DOWN state, u = fail on an UNREACHABLE state, and p = fail on a PENDING state (i.e., the host has not yet been checked). If you specify n (none) as an option, the notification dependency will never fail and notifications for the dependent host will always be sent out. Example:  If you specify d in this field, the notifications for the dependent host will not be sent out if the master host is in a DOWN state.);

# host / service ext info
		} elsif ($obj eq 'extended_host_info_templates' && $prop eq 'notes') {
			$docs{$prop} = q(Notes: This directive is used to define an optional default string of notes pertaining to the host.  The content here will be overridden by any notes defined for an individual host to which this template is applied. Also, as this is a template, you may use macros $HOSTNAME$ and $HOSTADDRESS$ in the notes.);
		} elsif ($obj eq 'extended_host_info_templates' && $prop eq 'notes_url') {
			$docs{$prop} = q(<p>Notes URL: Optional. This option is used to define a URL that can be used to provide more information about the host. If you specify a URL, you will see various forms of 'Extra Host Notes' links in the Nagios CGI screens (when you are viewing information about the specified host). This can be very useful if you want to make detailed information on the host, emergency contact methods, etc. available to other support staff.</p><p class=append>Any valid URL can be used. If you plan on using relative paths, the base path will be the same as what is used to access the CGIs (i.e., /cgi-bin/nagios/). Also, as this is a template, you may use macros $HOSTNAME$ and $HOSTADDRESS$ in the URL.</p>);
		} elsif ($obj eq 'extended_host_info_templates' && $prop eq 'action_url') {
			$docs{$prop} = q(<p>Action URL: Optional. This directive is used to define an optional URL that can be used to provide more actions to be performed on the host. If you specify a URL, you will see various forms of 'Extra Host Actions' links in the Nagios CGI screens (when you are viewing information about the specified host).</p><p class=append>Any valid URL can be used. If you plan on using relative paths, the base path will be the same as what is used to access the CGIs (i.e., /cgi-bin/nagios/). Also, as this is a template, you may use macros $HOSTNAME$ and $HOSTADDRESS$ in the URL.</p>);
		} elsif ($obj eq 'extended_service_info_templates' && $prop eq 'notes') {
			$docs{$prop} = q(Notes: This directive is used to define an optional default string of notes pertaining to the service.  The content here will be overridden by any notes defined for an individual service to which this template is applied.  Also, as this is a template, you may use macros $HOSTNAME$, $HOSTADDRESS$, $SERVICENAME$, $SERVICEDESC$, and $SERVICEDESCRIPTION$ in the notes.  The latter three macros all expand to the same value.);
		} elsif ($obj eq 'extended_service_info_templates' && $prop eq 'notes_url') {
			$docs{$prop} = q(<p>Notes URL: Optional. This option is used to define a URL that can be used to provide more information about the service. If you specify a URL, you will see various forms of 'Extra Service Notes' links in the Nagios CGI screens (when you are viewing information about the specified service). This can be very useful if you want to make detailed information on the service, emergency contact methods, etc. available to other support staff.</p><p class=append>Any valid URL can be used. If you plan on using relative paths, the base path will be the same as what is used to access the CGIs (i.e., /cgi-bin/nagios/). Also, as this is a template, you may use macros $HOSTNAME$, $HOSTADDRESS$, $SERVICENAME$, $SERVICEDESC$, and $SERVICEDESCRIPTION$ in the URL. The latter three macros all expand to the same value.</p>);
		} elsif ($obj eq 'extended_service_info_templates' && $prop eq 'action_url') {
			$docs{$prop} = q(<p>Action URL: Optional. This directive is used to define an optional URL that can be used to provide more actions to be performed on the service. If you specify a URL, you will see various forms of 'Extra Service Actions' links in the Nagios CGI screens (when you are viewing information about the specified service).</p><p class=append>Any valid URL can be used. If you plan on using relative paths, the base path will be the same as what is used to access the CGIs (i.e., /cgi-bin/nagios/). Also, as this is a template, you may use macros $HOSTNAME$, $HOSTADDRESS$, $SERVICENAME$, $SERVICEDESC$, and $SERVICEDESCRIPTION$ in the URL. The latter three macros all expand to the same value.</p>);
		} elsif ($prop eq 'script') {
			$docs{$prop} = q(Script: Optional custom script. Enter full path, file name and command line arguments. Use Control -> Run Extended Info Scripts to execute custom scripts for objects assigned this template. Arguements can include $HOSTNAME$ and $SERVICENAME$ macros.);
		} elsif ($prop eq 'icon_image') {
			$docs{$prop} = q(Icon image: Optional. This variable is used to define the name of a GIF, PNG, or JPG image that should be associated with this host. This image will be displayed in the status and extended information CGIs. The image will look best if it is 40x40 pixels in size. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e., /usr/local/groundwork/nagios/share/images/logos).);
		} elsif ($prop eq 'icon_image_alt') {
			$docs{$prop} = q(Icon image alt: Optional. This variable is used to define an optional string that is used in the ALT tag of the image specified by the <icon_image> argument. The ALT tag is used in the status, extended information and statusmap CGIs.);
		} elsif ($prop eq 'vrml_image') {
			$docs{$prop} = q(VRML image: Optional. This variable is used to define the name of a GIF, PNG, or JPG image that should be associated with this host. This image will be used as the texture map for the specified host in the statuswrl CGI. Unlike the image you use for the <icon_image> variable, this one should probably not have any transparency. If it does, the host object will look a bit wierd. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e., /usr/local/groundwork/nagios/share/images/logos).);
		} elsif ($prop eq 'statusmap_image') {
			$docs{$prop} = q(Statusmap image: Optional. This variable is used to define the name of an image that should be associated with this host in the statusmap CGI. You can specify a JPEG, PNG, and GIF image if you want, although it is strongly suggested that you use a GD2 format image, as other image formats will result in a lot of wasted CPU time when the statusmap image is generated. GD2 images can be created from PNG images by using the pngtogd2 utility supplied with Thomas Boutell's gd library. The GD2 images should be created in uncompressed format to minimize CPU load when the statusmap CGI is generating the network map image. The image will look best if it is 40x40 pixels in size. You can leave these option blank if you are not using the statusmap CGI. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e., /usr/local/groundwork/nagios/share/images/logos).);
		} elsif ($prop eq '2d_coords') {
			$docs{$prop} = q(2d coords: Optional. This variable is used to define coordinates to use when drawing the host in the statusmap CGI. Coordinates should be given in positive integers, as the correspond to physical pixels in the generated image. The origin for drawing (0,0) is in the upper left hand corner of the image and extends in the positive x direction (to the right) along the top of the image and in the positive y direction (down) along the left hand side of the image. For reference, the size of the icons drawn is usually about 40x40 pixels (text takes a little extra space). The coordinates you specify here are for the upper left hand corner of the host icon that is drawn. Note:  Don't worry about what the maximum x and y coordinates that you can use are. The CGI will automatically calculate the maximum dimensions of the image it creates based on the largest x and y coordinates you specify.);
		} elsif ($prop eq '3d_coords') {
			$docs{$prop} = q(3d coords: Optional. This variable is used to set coordinates to use when drawing the host in the statuswrl CGI. Coordinates can be positive or negative real numbers. The origin for drawing is (0.0,0.0,0.0). For reference, the size of the host cubes drawn is 0.5 units on each side (text takes a little more space). The coordinates you specify here are used as the center of the host cube.);

# hostgroup
		} elsif ($obj eq 'hostgroups' && $prop eq 'alias') {
			$docs{$prop} = q(Alias: Required. This directive is used to define a longer name or description used to identify the host group. It is provided to allow you to more easily identify a particular host group.);
		} elsif ($obj eq 'hostgroups' && $prop eq 'notes') {
			$docs{$prop} = q(Notes: Optional. This field is intended to describe common features of the host group (e.g., the business unit, the geographical location, or the team responsible for maintenance). This information is shown on the host group detail page within the status viewer.);
		} elsif ($obj eq 'hostgroups' && $prop eq 'members') {
			$docs{$prop} = q(Members: Required. This is a list of the short names of hosts that should be included in this group.);
		} elsif ($obj eq 'hostgroups' && $prop eq 'contactgroup') {
			$docs{$prop} = q(Contactgroup: Required Nagios 1.x. This is a list of the contact groups that should be notified whenever there are problems (or recoveries) with any of the hosts in this host group. When writing for 2.x and up, contact groups are correctly assigned to the hosts.);
		} elsif ($obj eq 'hostgroups' && $prop eq 'hostgroup_escalation_id') {
			$docs{$prop} = q(Hostgroup escalation tree: Optional. Select the hostgroup escalation tree applicable to this hostgroup (see Escalations -> Escalation Trees). (Note that users of Nagios 2.x and up may use this directive or the host escalation tree directive to achieve the same result.));
		} elsif ($obj eq 'hostgroups' && $prop eq 'host_escalation_id') {
			$docs{$prop} = q(Host escalation tree: Optional. Select the host escalation tree applicable to this hostgroup (see Escalations -> Escalation Trees). All hosts in the hostgroup receive the same host escalation tree.);
		} elsif ($obj eq 'hostgroups' && $prop eq 'service_escalation_id') {
			$docs{$prop} = q(Service escalation tree: Optional. Select the service escalation tree applicable to this hostgroup (see Escalations -> Escalation Trees). All services on each host in the hostgroup receive the same service escalation tree.);

# service template
		} elsif ($obj eq 'service_templates' && $prop eq 'template') {
			if ($view eq 'service_template') {
			    $docs{$prop} = q(Service template: Optional. If you wish to base this service template on another template, with a few changes, select the service template most suitable as a base for this template. If you do so, note inheritance (the left check box) on directives below. To override a particular base-template value, first uncheck the left check box, then provide a custom value.);
			}
			else {
			    # $view eq 'service'
			    $docs{$prop} = q(Service template: Required. Select the service template most suitable for this service. Note inheritance (the left check box) on directives below. To override a particular template value, first uncheck its left check box, then provide a custom value.);
			}
		} elsif ($obj eq 'service_templates' && $prop eq 'is_volatile') {
			$docs{$prop} = q(Is volatile: This directive is used to denote whether the service is 'volatile'. Services are normally not volatile. More information on volatile service and how they differ from normal services can be found in the Nagios documentation. Unchecked = service is not volatile, checked = service is volatile.);
		} elsif ($obj eq 'service_templates' && $prop eq 'check_period') {
			$docs{$prop} = q(Check period: Required. This directive is used to specify the short name of the time period during which active checks of this service can be made.);
		} elsif ($obj eq 'service_templates' && $prop eq 'max_check_attempts') {
			$docs{$prop} = q(Max check attempts: Required. This directive is used to define the number of times that Nagios will retry the service check command if it returns any state other than an OK state. Setting this value to 1 will cause Nagios to generate an alert without retrying the service check again.);
		} elsif ($obj eq 'service_templates' && $prop eq 'normal_check_interval') {
			$docs{$prop} = q(Normal check interval: Required. This directive is used to define the number of 'time units' to wait before scheduling the next 'regular' check of the service. 'Regular' checks are those that occur when the service is in an OK state or when the service is in a non-OK state, but has already been rechecked max_attempts number of times. Unless you've changed the interval_length directive from the default value of 60, this number will mean minutes.);
		} elsif ($obj eq 'service_templates' && $prop eq 'retry_check_interval') {
			$docs{$prop} = q(Retry check interval: Required. This directive is used to define the number of 'time units' to wait before scheduling a re-check of the service. Services are rescheduled at the retry interval when they have changed to a non-OK state. Once the service has been retried max_attempts times without a change in its status, it will revert to being scheduled at its 'normal' rate as defined by the normal_check_interval value. Unless you've changed the interval_length directive from the default value of 60, this number will mean minutes.);
		} elsif ($obj eq 'service_templates' && $prop eq 'active_checks_enabled') {
			$docs{$prop} = q(Active checks enabled: Optional. This directive is used to determine whether or not active checks of this service are enabled. Values:  unchecked = disable active service checks, checked = enable active service checks.);
		} elsif ($obj eq 'service_templates' && $prop eq 'passive_checks_enabled') {
			$docs{$prop} = q(Passive checks enabled: Optional. This directive is used to determine whether or not passive checks of this service are enabled. Values:  unchecked = disable passive service checks, checked = enable passive service checks.);
		} elsif ($obj eq 'service_templates' && $prop eq 'parallelize_check') {
			# Nagios 1.x and 2.x only.  Obsolete starting with Nagios 3.x.
			$docs{$prop} = q(Parallelize check: Optional. This directive is used to determine whether or not the service check can be parallelized. By default, all service checks are parallelized. Disabling parallel checks of services can result in serious performance problems. Values:  unchecked = service check cannot be parallelized (use with caution!), checked = service check can be parallelized.);
		} elsif ($obj eq 'service_templates' && $prop eq 'obsess_over_service') {
			$docs{$prop} = q(Obsess over service: This value determines whether or not Nagios will 'obsess' over service checks results and run the obsessive compulsive service processor command you define. This option is useful for performing distributed monitoring. If you're not doing distributed monitoring, don't enable this option.);
		} elsif ($obj eq 'service_templates' && $prop eq 'check_freshness') {
			$docs{$prop} = q(Check freshness: Optional. This directive is used to determine whether or not freshness checks are enabled for this service. Values:  unchecked = disable freshness checks, checked = enable freshness checks.);
		} elsif ($obj eq 'service_templates' && $prop eq 'freshness_threshold') {
			$docs{$prop} = q(Freshness threshold: Optional. This directive is used to specify the freshness threshold (in seconds) for this service. If you set this directive to a value of 0, Nagios will determine a freshness threshold to use automatically.);
		} elsif ($obj eq 'service_templates' && $prop eq 'notifications_enabled') {
			$docs{$prop} = q(Notifications enabled: Optional. This directive is used to determine whether or not notifications for this service are enabled. Values:  unchecked = disable service notifications, checked = enable service notifications.);
		} elsif ($obj eq 'service_templates' && $prop eq 'notification_interval') {
			$docs{$prop} = q(Notification interval: Required. This directive is used to define the number of 'time units' to wait before re-notifying a contact that this service is still in a non-OK state. Unless you've changed the interval_length directive from the default value of 60, this number will mean minutes. If you set this value to 0, Nagios will not re-notify contacts about problems for this service -- only one problem notification will be sent out, unless there has been a state change.);
		} elsif ($obj eq 'service_templates' && $prop eq 'notification_period') {
			$docs{$prop} = q(Notification period: Required. This directive is used to specify the short name of the time period during which notifications of events for this service can be sent out to contacts. No service notifications will be sent out during times which is not covered by the time period.);
		} elsif ($obj eq 'service_templates' && $prop eq 'notification_options') {
			$docs{$prop} = q(Notification options: Required. This directive is used to determine when notifications for the service should be sent out. Valid options are a combination of one or more of the following: Warning checked = send notifications on a WARNING state; Unknown checked = send notifications on an UNKNOWN state; Critical checked = send notifications on a CRITICAL state; and Recovery checked = send notifications on recoveries (OK state). If you specify None as an option, no service notifications will be sent out.);
		} elsif ($obj eq 'service_templates' && $prop eq 'stalking_options') {
			$docs{$prop} = q(Stalking options: Optional. This directive determines which service states 'stalking' is enabled for. Valid options are a combination of one or more of the following: Okay checked = stalk on OK states, Warning checked = stalk on WARNING states, Critical checked = stalk on CRITICAL states, and Unknown checked = stalk on UNKNOWN states.);
		} elsif ($obj eq 'service_templates' && $prop eq 'event_handler_enabled') {
			$docs{$prop} = q(Event handler enabled: Optional. This directive is used to determine whether or not the event handler for this service is enabled. Values:  unchecked = disable service event handler, checked = enable service event handler.);
		} elsif ($obj eq 'service_templates' && $prop eq 'event_handler') {
			$docs{$prop} = q(Event handler: Optional. This directive is used to specify the short name of the command that should be run whenever a change in the state of the service is detected (i.e., whenever it goes down or recovers). The maximum amount of time that the event handler command can run is controlled by the event_handler_timeout option.);
		} elsif ($obj eq 'service_templates' && $prop eq 'flap_detection_enabled') {
			$docs{$prop} = q(Flap detection enabled: Optional. This directive is used to determine whether or not flap detection is enabled for this service. Values:  unchecked = disable service flap detection, checked = enable service flap detection.);
		} elsif ($obj eq 'service_templates' && $prop eq 'low_flap_threshold') {
			$docs{$prop} = q(Low flap threshold: Optional. This directive is used to specify the low state change threshold used in flap detection for this service. If you set this directive to a value of 0, the program-wide value specified by the low_service_flap_threshold directive will be used.);
		} elsif ($obj eq 'service_templates' && $prop eq 'high_flap_threshold') {
			$docs{$prop} = q(High flap threshold: Optional. This directive is used to specify the high state change threshold used in flap detection for this service. If you set this directive to a value of 0, the program-wide value specified by the high_service_flap_threshold directive will be used.);
		} elsif ($obj eq 'service_templates' && $prop eq 'retain_status_information') {
			$docs{$prop} = q(Retain status information: Optional. This directive is used to determine whether or not status-related information about the service is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive. Value:  unchecked = disable status information retention, checked = enable status information retention.);
		} elsif ($obj eq 'service_templates' && $prop eq 'retain_nonstatus_information') {
			$docs{$prop} = q(Retain nonstatus information: Optional. This directive is used to determine whether or not non-status information about the service is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive. Value:  unchecked = disable non-status information retention, checked = enable non-status information retention.);
		} elsif ($obj eq 'service_templates' && $prop eq 'check_command') {
			$docs{$prop} = q(Check command: Optional, sets the default value. Select the command that Nagios will run to check the status of the service.);
		} elsif ($obj eq 'service_templates' && $prop eq 'command_line') {
			$docs{$prop} = q(Command line: Optional, sets the default value. If check command requires arguments, enter the check command with command arguments separated by a ! character. Example: check-disk!/dev/sda1);
		} elsif ($obj eq 'service_templates' && $prop eq 'process_perf_data') {
			$docs{$prop} = q(Process perf data: Optional. This directive is used to determine whether or not the processing of performance data is enabled for this service. Values:  unchecked = disable performance data processing, checked = enable performance data processing.);
		} elsif ($obj eq 'service_templates' && $prop eq 'contactgroup') {
			$docs{$prop} = q(Contact groups: This is a list of the short names of the contact groups that should be notified whenever there are problems (or recoveries) with this service.);

# service_dependency_templates
		} elsif ($obj eq 'service_dependency_templates' && $prop eq 'service_name') {
			$docs{$prop} = q(Master service name: Required. Specify the master service name.);
		} elsif ($obj eq 'service_dependency_templates' && $prop eq 'execution_failure_criteria') {
			$docs{$prop} = q(Execution failure criteria: Optional. This directive is used to specify the criteria that determine when the dependent service should not be executed. If the service that is being depended upon is in one of the failure states you specify, the dependent service will not be executed. Valid options are a combination of one or more of the following:  Okay checked = fail on an OK state, Warning checked = fail on a WARNING state, Unknown checked = fail on an UNKNOWN state, and Critical checked = fail on a CRITICAL state. If you specify n (none) as an option, the execution dependency will never fail and checks of the dependent service will always be executed. Example:  If you specify o,c,u in this field, the dependent service will not be executed if the service that's being depended upon is in either an OK, a CRITICAL, or an UNKNOWN state.);
		} elsif ($obj eq 'service_dependency_templates' && $prop eq 'notification_failure_criteria') {
			$docs{$prop} = q(Notification failure criteria: Optional. This directive is used to define the criteria that determine when notifications for the dependent service should not be sent out. If the service that is being depended upon is in one of the failure states you specify, notifications for the dependent service will not be sent to contacts. Valid options are a combination of one or more of the following:  Okay checked = fail on an OK state, Warning checked = fail on a WARNING state, Unknown checked = fail on an UNKNOWN state, and Critical checked = fail on a CRITICAL state. If you specify n (none) as an option, the notification dependency will never fail and notifications for the dependent service will always be sent out. Example:  If you specify w in this field, the notifications for the dependent service will not be sent out if the service that is being depended upon is in a WARNING state.);
# contact template
		} elsif ($obj eq 'contact_templates' && $prop eq 'host_notification_period') {
			$docs{$prop} = q(Host notification period: Required. This directive is used to specify the short name of the time period during which the contact can be notified about host problems or recoveries. You can think of this as an 'on call' time for host notifications for the contact. Read the documentation on time periods for more information on how this works and potential problems that may result from improper use.);
		} elsif ($obj eq 'contact_templates' && $prop eq 'service_notification_period') {
			$docs{$prop} = q(Service notification period: Required. This directive is used to specify the short name of the time period during which the contact can be notified about service problems or recoveries. You can think of this as an 'on call' time for service notifications for the contact. Read the documentation on time periods for more information on how this works and potential problems that may result from improper use.);
		} elsif ($obj eq 'contact_templates' && $prop eq 'host_notification_options') {
			$docs{$prop} = q(Host notification options: Required. This directive is used to define the host states for which notifications can be sent out to this contact. Valid options are a combination of one or more of the following:  Down checked = notify on DOWN host states; Unreachable checked = notify on UNREACHABLE host states; and Recovery checked = notify on host recoveries (UP states). If you specify None as an option, the contact will not receive any type of host notifications.);
		} elsif ($obj eq 'contact_templates' && $prop eq 'service_notification_options') {
			$docs{$prop} = q(Service notification options: Required. This directive is used to define the service states for which notifications can be sent out to this contact. Valid options are a combination of one or more of the following:  Warning checked = notify on WARNING service states; Unknown checked = notify on UNKNOWN service states; Critical checked = notify on CRITICAL service states; and Recovery checked = notify on service recoveries (OK states). Users of Nagios 2.x and up may also specify notifications on flapping starts and stops for hosts and services. If you specify None as an option, the contact will not receive any type of service notifications.);
		} elsif ($obj eq 'contact_templates' && $prop eq 'host_notification_commands') {
			$docs{$prop} = q(Host notification commands: Optional. This directive is used to define a list of the short names of the commands used to notify the contact of a host problem or recovery. All notification commands are executed when the contact needs to be notified. The maximum amount of time that a notification command can run is controlled by the notification_timeout option.);
		} elsif ($obj eq 'contact_templates' && $prop eq 'service_notification_commands') {
			$docs{$prop} = q(Service notification commands: Optional. This directive is used to define a list of the short names of the commands used to notify the contact of a service problem or recovery. All notification commands are executed when the contact needs to be notified. The maximum amount of time that a notification command can run is controlled by the notification_timeout option.);

# contacts
		} elsif ($obj eq 'contacts' && $prop eq 'template') {
			$docs{$prop} = q(Contact template: Required. Select the contact template most suitable for this contact. Note inheritance (the left check box) on directives below. To override the template value, uncheck the left check box.);
		} elsif ($obj eq 'contacts' && $prop eq 'alias') {
			$docs{$prop} = q(Alias: Required. This directive is used to define a longer name or description for the contact. Under the rights circumstances, the $CONTACTALIAS$ macro will contain this value.);
		} elsif ($obj eq 'contacts' && $prop eq 'email') {
			$docs{$prop} = q(Email: Optional. This directive is used to define an email address for the contact. Depending on how you configure your notification commands, it can be used to send out an alert email to the contact. Under the right circumstances, the $CONTACTEMAIL$ macro will contain this value.);
		} elsif ($obj eq 'contacts' && $prop eq 'pager') {
			$docs{$prop} = q(Pager: Optional. This directive is used to define a pager number for the contact. It can also be an email address to a pager gateway (e.g. pagejoe@pagenet.com). Depending on how you configure your notification commands, it can be used to send out an alert page to the contact. Under the right circumstances, the $CONTACTPAGER$ macro will contain this value.);
		} elsif ($obj eq 'contacts' && $prop eq 'notification') {
			$docs{$prop} = q(Pager: Required. Select the period for which this contact is available to receive notifications.);

# contactgroups
		} elsif ($obj eq 'contactgroups' && $prop eq 'alias') {
			$docs{$prop} = q(Alias: Required. This directive is used to define a longer name or description used to identify the contact group.);
		} elsif ($obj eq 'contactgroups' && $prop eq 'contact') {
			$docs{$prop} = q(Contacts: Required. Assign contacts to the group.);

# timeperiods
		} elsif ($obj eq 'time_periods' && $prop eq 'alias') {
			$docs{$prop} = q(Alias: Required. This directive is a longer name or description used to identify the time period.);
		} elsif ($obj eq 'time_periods' && $prop eq 'sunday') {
			$docs{$prop} = q(Sunday-Saturday: Optional. The Sunday through Saturday directives are comma-delimited lists of time ranges that are 'valid' times for a particular day of the week. Notice that there are seven different days for which you can define time ranges (Sunday through Saturday). Each time range is in the form of HH:MM-HH:MM, where hours are specified on a 24-hour clock. For example, 00:15-24:00 means 12:15 in the morning (just after midnight) for this day until the following midnight (a 23 hour, 45 minute total time range). If you wish to exclude an entire day from the timeperiod, simply do not include it in the timeperiod definition.);

# commands
		} elsif ($obj eq 'commands' && $prop eq 'type') {
			$docs{$prop} = q(Type: Required. Specify command type: check = service/host check commands, handlers; notify = notification commands; other = other commands (i.e., performance data collectors).);
		} elsif ($obj eq 'commands' && $prop eq 'command_line') {
			$docs{$prop} = q(Command line: Required. This directive is used to define what is actually executed by Nagios when the command is used for service or host checks, notifications, or event handlers. Before the command line is executed, all valid macros are replaced with their respective values. See the documentation on macros for determining when you can use different macros. Note that the command line is not surrounded in quotes. Also, if you want to pass a dollar sign ($) on the command line, you have to escape it with another dollar sign.);
		} elsif ($obj eq 'commands' && $prop eq 'usage') {
			$docs{$prop} = q(Usage: This shows how the command is defined on the service.);

# escalation_templates
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'first_notification') {
			$docs{$prop} = q(First notification: Required. This directive is a number that identifies the first notification for which this escalation is effective. For instance, if you set this value to 3, this escalation will only be used if the host is down or unreachable long enough for a third notification to go out or if the service is in a non-OK state long enough for a third notification to go out.);
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'last_notification') {
			$docs{$prop} = q(Last notification: Required. This directive is a number that identifies the last notification for which this escalation is effective. For instance, if you set this value to 5, this escalation will not be used if more than five notifications are sent out for the host or service. Setting this value to 0 means to keep using this escalation entry forever (no matter how many notifications go out).);
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'notification_interval') {
			$docs{$prop} = q(Notification interval: Required. This directive is used to determine the time interval (Unless you have changed the interval_length directive from the default value of 60, this number will mean minutes.) at which notifications should be made while this escalation is valid. If you specify a value of 0 for the interval, Nagios will send the first notification only, and will then prevent any more problem notifications from being sent out for the host. Specifying any other value will send continuous notifications at the time interval specified. Note:  If multiple escalation entries for a host overlap for one or more notification ranges, the smallest notification interval from all escalation entries is used.);
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'service_description') {
			$docs{$prop} = q(Service description: Required. This directive is used to identify the description of the service the escalation should apply to.);
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'escalation_period') {
			$docs{$prop} = q(Escalation period: Optional. This directive is used to specify the short name of the time period during which this escalation is valid. If this directive is not specified, the escalation is considered to be valid during all times.);
		} elsif ($obj =~ /service_escalation_templates/ && $prop eq 'escalation_options') {
			$docs{$prop} = q(Escalation options: Optional. This directive is used to define the criteria that determine when this service escalation is used. The escalation is used only if the service is in one of the states specified in this directive. If this directive is not specified in a service escalation, the escalation is considered to be valid during all service states. Valid options are a combination of one or more of the following: recovery = escalate on an OK (recovery) state, warning = escalate on a WARNING state, unknown = escalate on an UNKNOWN state, and critical = escalate on a CRITICAL state. Example: If you specify warning in this field, the escalation will only be used if the service is in a WARNING state.);
		} elsif ($obj =~ /host_escalation_templates|hostgroup_escalation_templates/ && $prop eq 'escalation_options') {
			$docs{$prop} = q(Escalation options: Optional. This directive is used to define the criteria that determine when this host escalation is used. The escalation is used only if the host is in one of the states specified in this directive. If this directive is not specified in a host escalation, the escalation is considered to be valid during all host states. Valid options are a combination of one or more of the following: recovery = escalate on an UP (recovery) state, down = escalate on a DOWN state, and unreachable = escalate on an UNREACHABLE state. Example: If you specify d in this field, the escalation will only be used if the host is in a DOWN state.);
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'escalation_period') {
			$docs{$prop} = q(Escalation period: This directive is used to specify the short name of the time period during which this escalation is valid. If this directive is not specified, the escalation is considered to be valid during all times.);
		} elsif ($obj =~ /escalation_templates/ && $prop eq 'escalation_options') {
			$docs{'escalation_options'} = q(Escalation options: This directive is used to define the criteria that determine when this service escalation is used. The escalation is used only if the service is in one of the states specified in this directive. If this directive is not specified in a service escalation, the escalation is considered to be valid during all service states. Valid options are a combination of one or more of the following: r = escalate on an OK (recovery) state, w = escalate on a WARNING state, u = escalate on an UNKNOWN state, and c = escalate on a CRITICAL state. Example: If you specify w in this field, the escalation will only be used if the service is in a WARNING state.);

# host template, service template, contact template, and corresponding objects
		} elsif ($prop eq 'custom_object_variables') {
			$docs{$prop} = q(You may define and manage <a href='http://nagios.sourceforge.net/docs/3_0/customobjectvars.html' target='_blank'>custom object variables</a> here.<p class=append>Each variable defined in a template will normally be inherited by templates and objects that directly or indirectly reference that template. Those templates and objects can either suppress the inheritance, or override the inherited value with one of their own choosing.</p><p class=append>Templates and objects can also have additional variables defined. Adding and then suppressing such a template-level or object-level variable (i.e., one not potentially inherited from some ancestor template) won't do anything except guard against future inheritance from a modified ancestor template.</p>);
		}
	}
	return %docs;
}

sub services() {
	my %docs = ();
	$docs{'name'} = q(FIX MINOR:  describe service and service template naming constraints);
	$docs{'description'} = q(Description: Optional. Store comments or instructions here.);
	$docs{'service_template'} = q(Service template: Required.  This option sets the default template for this service name definition in 'Hosts -> Host Wizard' and 'Hosts -> Modify -> Services -> Service Detail'.);
	$docs{'use_parent_check'} = q(Inherit template check: If checked, the check command and command line options are derived from the parent service template.);
	$docs{'use_template_command'} = q(Inherit check: If checked, the check command and command line options are derived from the service template. Be careful to ensure the service template has a check command defined before checking this option.);
	$docs{'check_command'} = q(Check command: If 'Inherit template check' is unchecked, select the command that Nagios will run to check the status of the service.);
	$docs{'command_line'} = q(Command line: If 'Inherit template check' is unchecked and if check command requires arguments, enter the check command with command arguments separated by a ! character. Example: check-disk!/dev/sda1);
	$docs{'dependency'} = q(Service dependency template: Optional. Select the template that defines a master service relationship on a given host. Monarch will create a service dependency relationship on a host assigned this service name. To define a dependency for a service running on a different host use 'Hosts -> Modify -> Services -> Service Dependency' and select the master host. Be careful to ensure that the master service is assigned to the master host definition and is included in the relevant service profiles.);
	$docs{'master_host'} = q(Master host: Select the host on which the master service runs. Choose 'same host' if the master and dependent services reside on the same host.);
	$docs{'master_service'} = q(This is the service referenced by the chosen service dependency.);
	$docs{'extinfo'} = q(Extended service info template: Optional. Defines extended service information for this service name. The template controls the icon and url link as seen in Nagios for hosts assigned this service definition.);
	$docs{'escalation'} = q(Service escalation tree: Optional. Select an escalation tree appropriate for this service name. To avoid amplified notifications (i.e., multiple notifications for the same event), a service escalation tree assigned to a service name should not also be assigned to the host or the host group.);
	$docs{'externals'} = q(Externals: Custom client specific option.);
	$docs{'dependencies'} = q(Add or remove service dependencies here. To add a dependency, select from the dependency list and after the screen refreshes, choose the appropriate host, or select same host if the dependency is for services on the same host.);
	$docs{'service_check'} = q(If you are satisfied with the check as inherited from the template, do nothing on this page. Otherwise uncheck the inherit checkbox and make the necessary changes. Use the test button to check the argument values, but bear in mind that the check command is run under the web servers account, so there may be issues with certain checks.);
	$docs{'service_externals'} = q(Externals are used to create configuration files for external applications, such as the GroundWork Distributed Monitoring Agents. A service external provides the detail relevant to a particular service, that will end up in such a file.);
	$docs{'service_profiles'} = q(Add or remove service profiles using this service. Adding or removing a service profile here has no effect on the service profile's member hosts until the Apply tab is used on the service profile (or host profile), or the profile is applied on the individual hosts.);
	$docs{'profiles'} = q(Select the service profiles that should reference this service.);
	$docs{'apply'} = q(Select what Service properties to apply at this time from the listed options. Applying the service check, contact groups, service extended info, service escalation, dependencies, and/or service externals will modify the corresponding values for this service on the hosts where it is running.<p class=append>If you select <i>Replace existing host service properties</i>, all service properties are removed from the service on the listed hosts, and replaced with those from this service.</p><p class=append><i>Merge with existing host service properties</i> means that any existing service property already on a listed host's service, but <i>not</i> in this service, remains unchanged on the host service, while service properties in this service are added or updated. Note that if you removed service properties or values from this service, those now-unreferenced service property values will not be deleted from the host services when you perform this merge operation. To make that happen, you will need to either use <i>Replace existing host service properties</i>, or go to the host service records and adjust them directly.</p><p class=append>Merging with existing host service externals is treated specially. Only host service externals which were never modified after being applied to the host service will be updated in a merge operation. This behavior preserves local overrides to the host service external values.</p>);
	$docs{'caution'} = q(Applying a service at this point will modify the current service configuration across probably multiple hosts. Before taking this action, be sure to double-check:<ul><li>your service changes<li>the set of target hosts that reference this service<li>which service properties you wish to apply from the service to the host services<li>how you want to modify the existing host services</ul>);
	$docs{'macro_arguments'} = q(If this service check is run from an external source and not directly by Nagios, you can specify here a set of strings that can be referenced by $ARG#$ macros (<tt>$ARG1$</tt>, <tt>$ARG2$</tt>, ...) in your service externals for this service.  Note that if you define Multiple Instances (for a host service, not here), a special <tt>$INSTANCESUFFIX$</tt> macro is also available.  This can be used to simplify construction of per-instance externals arguments, by inheriting the base-service externals arguments.  The expansion of <tt>$INSTANCESUFFIX$</tt> will omit a leading underscore in an instance name suffix, making it a practical substitution for some uses.);
	$docs{'externals_arguments'} = q(<p>Externals arguments:  You may specify here a series of <tt>!</tt>-separated strings which will be substituted into $ARG#$ macro references (that is, <tt>$ARG1$</tt>, <tt>$ARG2$</tt>, ...) within externals associated with this service check.  These strings will form the initial values for a new host service using this generic service.  They can be further customized at the host-service level.</p>);
	return %docs;
}

sub service_profiles() {
	my %docs = ();
	$docs{'name'} = q(FIX MINOR:  describe service profile naming constraints);
	$docs{'description'} = q(Description: Optional. Store comments or instructions here.);
	$docs{'services'} = q(Services: Required. Select services from the right hand list to be included in this profile. Where service dependencies have been assigned to service names, be careful to include the master service names as defined in the dependency templates.);
	$docs{'file'} = q(File: Required. Select the default file for services in the profile. To add files go to 'Control -> Files -> Add a host/service file'.);
	$docs{'assign_hosts'} = q(Add or remove hosts to be managed by this profile. After saving, use the Apply tab to instantiate changes to the host. Removing a host means the host is no longer managed by this profile. The host will retain its properties until the host is assigned and applied to another profile, or modified individually.);
	$docs{'assign_hostgroups'} = q(Add or remove host groups to be managed by this profile. After saving, use the Apply tab to instantiate changes to the member hosts. Removing a host group means the host group is no longer managed by this profile. The member hosts will retain their properties until the host group is assigned and applied to another profile, or the member hosts are modified individually.);
	$docs{'host_profiles'} = q(Add or remove host profiles to which this profile is assigned. Adding or removing a host profile here has no effect on the host profile's member hosts until either the Apply tab is used on the host profile, or the profile is applied on the individual hosts.);
	$docs{'apply'} = q(Select <i>Apply to hostgroups</i> and/or <i>Apply to hosts</i> to push changes to hosts in hostgroups or individual hosts that reference this service profile.<p class=append>If you select <i>Replace existing services</i>, all services are removed from the hosts and new ones are added from the profile.</p><p class=append><i>Merge with existing services</i> means any existing service already on the host but not in this service profile remains unchanged on the host, while services in this service profile are added or updated. Note that if you removed services from the service profile, those now-unreferenced services will not be deleted from the hosts when you perform this merge operation. To make that happen, use the <i>Hosts -> Delete host services</i> screen.</p>);
	$docs{'caution'} = q(Applying a service profile at this point will modify the current service configuration across probably multiple hosts. Before taking this action, be sure to double-check:<ul><li>your service profile changes<li>your chosen set of target hosts that reference this service profile<li>how you want to modify the existing services</ul>);
	return %docs;
}

sub host_profile_profile() {
	my %docs = ();
	$docs{'description'} = q(Description: Optional. Store comments or instructions here.);
	$docs{'extended_host_info_template'} = q(Extended host info template: Optional. Defines extended host information for this host profile. The template controls the icon and url link as seen in Nagios for hosts assigned this profile.);
	$docs{'file'} = q(File: Required. Select the default file for hosts assigned this profile. To add files go to 'Control -> Files -> Add a host/service file'.);
	return %docs;
}

sub host_profile() {
	my %docs = ();
	$docs{'name'} = q(FIX MINOR:  describe host profile naming constraints);
	$docs{'hostgroups'} = q(Add or remove host groups for hosts using this profile. After saving, use the Apply tab to push changes to the hosts. This option also sets the default host group or host groups in Hosts -> Host Wizard.);
	$docs{'assign_hosts'} = q(Add or remove hosts to be managed by this profile. After saving, use the Apply tab to instantiate changes to the host. Removing a host means the host is no longer managed by this profile. The host will retain its properties until the host is assigned and applied to another profile, or modified individually.);
	$docs{'host_externals'} = q(Externals are used to create configuration files for external applications, such as the GroundWork Distributed Monitoring Agents. A host external provides the detail relevant to a particular host, that will end up in such a file.);
	$docs{'assign_hostgroups'} = q(Add or remove host groups to be managed by this profile. After saving, use the Apply tab to instantiate changes to the member hosts. Removing a host group means the host group is no longer managed by this profile. The member hosts will retain their properties until the host group is assigned and applied to another profile, or the member hosts are modified individually.);
	$docs{'parents'} = q(Parentage is used for physical dependency analysis during outages. Add or remove parent hosts for hosts using this profile. After saving, use the Apply tab to push changes to the hosts. This option also sets the default parents in Hosts -> Host Wizard.);
	$docs{'description'} = q(Description: Optional. Store comments or instructions here.);
	$docs{'extended_host_info_template'} = q(Extended host info template: Optional. Defines extended host information for this host profile. The template controls the icon and url link as seen in Nagios for hosts assigned this profile.);
	$docs{'template'} = q(Template: Required. Select the host template most suitable for this host profile.);
	$docs{'file'} = q(File: Required. Select the file name associated with hosts using this host profile.);
	$docs{'service_profile'} = q(Service profile: Required. Select the default service profile for this host profile.);
	$docs{'escalations'} = q(Add or remove escalation trees for hosts using this profile. Assigning a service escalation tree sets the escalation tree for all services on hosts using this profile. After saving, use the <i>Apply</i> tab to push changes to the hosts.);
	$docs{'host_escalation_tree'} = q(Host escalation tree: Optional. Select an escalation tree appropriate for hosts assigned this profile. A host escalation tree assigned to a host using this profile should not also be assigned to a hostgroup in which the host is a member.);
	$docs{'service_escalation_tree'} = q(Service escalation tree: Optional. Select an escalation tree appropriate for all services on hosts using this profile. When a service escalation tree is assigned to a host, all services on that host will use the same escalation tree. To use different escalation trees for different services on the same host, each service must have its own escalation tree. In that case, do not assign a service escalation tree here.);
	$docs{'service_profiles'} = q(Add or remove service profiles for hosts using this profile. After saving, use the Apply tab to push changes to the hosts. This option also sets the default service profiles in the Hosts -> Host Wizard.);
	$docs{'profiles'} = q(Select the service profiles that should be part of this host profile.);
	$docs{'apply'} = q(Select <i>Apply to hostgroups</i> and/or <i>Apply to hosts</i> to push changes to the hosts in hostgroups or individual hosts that reference this host profile.<p class=append>Select what Host properties to apply at this time from the listed options. Applying parents, hostgroups, escalations, contact groups, detail, and/or host externals will modify the corresponding values found on the target hosts.</p><p class=append>If you select <i>Replace existing services</i>, all services are removed from the hosts and new ones are added from the profiles.</p><p class=append><i>Merge with existing services</i> means any existing service already on the host but not in this host profile remains unchanged on the host, while services in the host profile are added or updated. Note that if you removed service profiles from the host profile or services from the service profiles still referenced by the host profile, those now-unreferenced services will not be deleted from the hosts when you perform this merge operation. To make that happen, use the <i>Hosts -> Delete host services</i> screen.</p><p class=append>Merging with existing host externals is treated specially. Only host externals which were never modified after being applied to the host will be updated in a merge operation. This behavior preserves local overrides to the host external values.</p>);
	$docs{'caution'} = q(Applying a host profile at this point will modify the current service configuration across probably multiple hosts. Before taking this action, be sure to double-check:<ul><li>your host profile changes<li>your chosen set of target hosts that reference this host profile<li>which host properties you wish to apply from the profile to the hosts<li>how you want to modify the existing services</ul>);
	return %docs;
}

sub host_wizard_vitals() {
	my %docs = ();
	$docs{'alias'} = q(Alias: Required. This directive is used to define a longer name or description used to identify the host. It is provided to allow you to more easily identify a particular host.);
	$docs{'address'} = q(Address: Required. This directive is used to define the address of the host. Normally, this is an IP address, although it could really be anything you want (so long as it can be used to check the status of the host). You can use a FQDN to identify the host instead of an IP address, but if DNS services are not available this could cause problems. When used properly, the $HOSTADDRESS$ macro will contain this address. Note: If you do not specify an address directive in a host definition, the name of the host will be used as its address. A word of caution about doing this, however -- if DNS fails, most of your service checks will fail because the plugins will be unable to resolve the host name.);
	$docs{'notes'} = q(Notes: Optional. This field is intended to hold a free-text description of this item. It is displayed in the status viewer, and can be included in notifications via the $HOSTNOTES$ macro. It is commonly used to provide additional information about the item such as the team in charge of maintenance, the asset tag, or other identifying data.);
	$docs{'host_profile'} = q(Host profile: Optional. Host Profiles can be used to aid the design and management of hosts.);

	return %docs;
}

sub host_wizard_attribs_1() {
	my %docs = ();
	$docs{'host_template'} = q(Host template: Required. Select the host template most suitable for this host.);
	$docs{'parents'} = q(Parents: Optional. Assign this host one or more parents, for purposes of physical dependency analysis during outages. Parent-child relationships may also be managed via 'Hosts -> Parent Child'.);
	$docs{'file'} = q(File: Required. Select the file for this host. To add files go to 'Control -> Files -> Add a host/service file'.);
	return %docs;
}

sub host_wizard_attribs_2() {
	my %docs = ();
	$docs{'hostgroups'} = q(Hostgroups: Optional. Assign this host one or more hostgroups. Hostgroups  may also be managed via 'Hosts -> Hostgroups'.);
	$docs{'extinfo'} = q(Extended host info template: Optional. Defines extended host information for this host profile. The template controls the icon and url link as seen in Nagios.);
	$docs{'coords2d'} = q(2d status map coords: Optional. Defines the host's position in the Nagios 2d status map. Coordinates should be given in positive integers, as they correspond to physical pixels in the generated image. The origin for drawing (0,0) is in the upper left hand corner of the image and extends in the positive x direction (to the right) along the top of the image and in the positive y direction (down) along the left hand side of the image. For reference, the size of the icons drawn is usually about 40x40 pixels (text takes a little extra space). The coordinates you specify here are for the upper left hand corner of the host icon that is drawn. Note: Don't worry about what the maximum x and y coordinates that you can use are. The CGI will automatically calculate the maximum dimensions of the image it creates based on the largest x and y coordinates you specify.);
	$docs{'coords3d'} = q(3d status map coords: Optional. Defines the host's position in the Nagios 3d status map.  Coordinates can be positive or negative real numbers. The origin for drawing is (0.0,0.0,0.0). For reference, the size of the host cubes drawn is 0.5 units on each side (text takes a little more space). The coordinates you specify here are used as the center of the host cube.);
	$docs{'host_escalation_tree'} = q(Host escalation tree: Optional. Select an escalation tree appropriate for this host. To avoid amplified notifications (i.e., multiple notifications for the same event), a host escalation tree assigned to this host should not also be assigned to a hostgroup in which the host is a member.);
	$docs{'service_escalation_tree'} = q(Service escalation tree: Optional. Select an escalation tree appropriate for services on this host. When a service escalation tree is assigned to a host, all services on that host use the same escalation tree. To avoid amplified notifications (i.e., multiple notifications for the same event), a service escalation tree assigned to a service name should not also be assigned to the host or the hostgroup.);
	$docs{'service_profile'} = q(Service profile: Optional. Select a service profile for this host. This sets up a default set of services.);
	return %docs;
}

sub host_wizard_select_services() {
	my %docs = ();
	$docs{'services'} = q(By default, the list of services is derived from the service profile selected in the last step. Each service has an option to Include/Modify/discard.<br><ul><li>Include: Accept this service as is with its default settings.</li><li>Modify: Accept this service but prompt for changes.</li><li>Discard: Do not include this service on this host.</li><li>Add to list: Add a service not included in the profile.</li></ul>);
	$docs{'file'} = q(File: Required. Select the default file for services assigned this host. To add files go to 'Control -> Files -> Add a host/service file'.);
	return %docs;
}

sub host_wizard_service_detail() {
	my %docs = ();
	$docs{'notes'} = q(Notes: Optional. This field is intended to hold a free-text description of this service. It is displayed in the status viewer, and can be included in notifications via the $SERVICENOTES$ macro. It is commonly used to provide details of the purpose or intended characteristics of the service.);
	$docs{'template'} = q(Service template: Required.  Select the appropriate service template for this service.);
	$docs{'use_template_command'} = q(Inherit check from template: If checked, the check command and command line options are derived from the service template. Be careful to ensure the service template has a check command defined before checking this option.);
	$docs{'check_command'} = q(Check command: If 'Inherit check from template' is unchecked, select the command that Nagios will run to check the status of the service.);
	$docs{'command_line'} = q(Command line: If 'Inherit check from template' is unchecked and if check command requires arguments, enter the check command with command arguments separated by a ! character. Example: check-disk!/dev/sda1);
	$docs{'dependency'} = q(Service dependency template: Optional. Select the template that defines a master service relationship on this host. Monarch will create one service dependency relationship on this host setting this service name as the dependent service. To define a dependency for a service running on a different host use 'Hosts -> Modify -> Services -> Service Dependency' and select the master host. Be careful to ensure that the master service is included in the list of services for this host.);
	$docs{'extinfo'} = q(Extended service info template: Optional. Defines extended service information for this service name. The template controls the icon and url link as seen in Nagios.);
	$docs{'service_escalation_tree'} = q(Service escalation tree: Optional. Select an escalation tree appropriate for this service name. To avoid amplified notifications (i.e., multiple notifications for the same event), a service escalation tree assigned to a service name should not also be assigned to the host or one of the host's hostgroups.);
	$docs{'inherit_ext_args'} = q(<p>Inherit from generic service:  This option controls whether or not the externals arguments for this host service are inherited from the generic service on which the host service is based.);
	$docs{'externals_arguments'} = q(<p>Externals arguments:  You may specify here a series of <tt>!</tt>-separated strings which will be substituted into $ARG#$ macro references (that is, <tt>$ARG1$</tt>, <tt>$ARG2$</tt>, ...) within externals associated with this service check.</p>);
	return %docs;
}

sub escalations() {
	my %docs = ();
	$docs{'host_hostgroup'} = q(Assigning a host group sets the default host escalation tree for all hosts in the host group.);
	$docs{'service_hostgroup'} = q(Assigning a host group sets the default service escalation tree for all services on all hosts in the host group.);
	$docs{'host_host'}  = q(Assigning a host sets the host escalation tree for the host.);
	$docs{'service_host'} = q(Assigning a host sets the default service escalation tree for all services on the host.);
	$docs{'servicegroup'} = q(Assigning a service group sets the default service escalation tree for all services in the service group.);
	$docs{'service'} = q(Assigning a service sets the service escalation tree for the service, and selecting <i>Apply to hosts</i> propagates the escalation tree to all hosts assigned this service.);
	$docs{'contactgroup'} = q(Required. This directive is used to identify the short name of the contact group that should be notified when the host or service notification is escalated.);
	$docs{'detail'} = q(Select escalation type: 1. Hostgroup: Nagios v. 1.x defines a hostgroup escalation; Nagios v. 2.x and up define a host escalation. 2. Host: Defines a host escalation. 3. Service: Defines a service escalation.);
	$docs{'escalation_tree'} = q(Add escalation: Add the selected escalation to this escalation tree.<br>Modify groups: Modify the list of contact groups associated with this escalation. At least one contact group is required.<br>Remove escalation: Remove this escalation from this escalation tree.<br>);
	return %docs;
}

sub manage_hosts_vitals() {
	my %docs = ();
	$docs{'alias'} = q(Alias: Required. This directive is used to define a longer name or description used to identify the host. It is provided to allow you to more easily identify a particular host.);
	$docs{'address'} = q(Address: Required. This directive is used to define the address of the host. Normally, this is an IP address, although it could really be anything you want (so long as it can be used to check the status of the host). You can use a FQDN to identify the host instead of an IP address, but if DNS services are not available this could cause problems. When used properly, the $HOSTADDRESS$ macro will contain this address. Note: If you do not specify an address directive in a host definition, the name of the host will be used as its address. A word of caution about doing this, however -- if DNS fails, most of your service checks will fail because the plugins will be unable to resolve the host name.);
	$docs{'notes'} = q(Notes: Optional. This field is intended to hold a free-text description of this item. It is displayed in the status viewer, and can be included in notifications via the $HOSTNOTES$ macro. It is commonly used to provide additional information about the item such as the team in charge of maintenance, the asset tag, or other identifying data.);
	$docs{'host_template'} = q(Host template: Required. Select the host template most suitable for this host. Note inheritance (the left check box) on directives below. To override the template value, uncheck the left check box.);
	$docs{'checks_enabled'} = q(This directive is used to determine whether or not checks of this host are enabled. Values: unchecked = disable host checks, checked = enable host checks.);
	$docs{'extinfo'} = q(Extended host info template: Optional. Defines extended host information for this host profile. The template controls the icon and url link as seen in Nagios.);
	$docs{'coords2d'} = q(2d status map coords: Optional. Defines the host's position in the Nagios 2d status map. Coordinates should be given in positive integers, as they correspond to physical pixels in the generated image. The origin for drawing (0,0) is in the upper left hand corner of the image and extends in the positive x direction (to the right) along the top of the image and in the positive y direction (down) along the left hand side of the image. For reference, the size of the icons drawn is usually about 40x40 pixels (text takes a little extra space). The coordinates you specify here are for the upper left hand corner of the host icon that is drawn. Note: Don't worry about what the maximum x and y coordinates that you can use are. The CGI will automatically calculate the maximum dimensions of the image it creates based on the largest x and y coordinates you specify.);
	$docs{'coords3d'} = q(3d status map coords: Optional. Defines the host's position in the Nagios 3d status map.  Coordinates can be positive or negative real numbers. The origin for drawing is (0.0,0.0,0.0). For reference, the size of the host cubes drawn is 0.5 units on each side (text takes a little more space). The coordinates you specify here are used as the center of the host cube.);
	$docs{'file'} = q(File: Required. Select the file for this host. To add files go to 'Control -> Files -> Add a host/service file'.);
	return %docs;
}

sub manage_hosts_host_profile() {
	my %docs = ();
	$docs{'how_to'} = q(Assign and apply a host profile (along with the service profiles it references, and the services they reference).<p class=append>The replace option will remove all service profiles and services from this host and replace them with those listed here that are associated with the selected host profile. Merge will leave any existing service profiles and services unchanged.</p>);
	$docs{'host_profile'} = q(Host profile: Optional. Host Profiles can be used to aid the design and management of hosts.);

	return %docs;
}

# FIX MAJOR NOW:  Should "replace" drop even the service profiles (and their services) associated with the host profile?
# Describe the decision on this, one way or the other, in the 'how_to' text.
sub manage_hosts_service_profiles() {
	my %docs = ();
	$docs{'how_to'} = q(Assign and apply service profiles (along with the services they reference) to this host.<p class=append>Only the service profiles you choose explicitly will be assigned and applied here. By default, no existing service profiles referenced by the host profile will be applied here. You may choose to include some of those as well.</p><p class=append>The replace option will remove all service profiles and services not referenced via the host profile, and replace them with those listed here. Merge will leave any existing service profiles and services unchanged.</p>);
	$docs{'host_profile'} = q(Host profile: Optional. Host Profiles can be used to aid the design and management of hosts. To change this selection, see the Host Profile tab above.);
	$docs{'service_profile'} = q(Service profile: Optional. Select any additional service profiles you wish to apply to this host. This sets up a default set of services.);

	return %docs;
}

sub manage_hosts_apply_profile() {
	my %docs = ();
	$docs{'host_profile'} = q(Host profile: Optional. Host Profiles can be used to aid the design and management of hosts.);
	$docs{'service_profile'} = q(Service profile: Optional. Select a service profile for this host. This sets up a default set of services.);

	return %docs;
}

sub manage_hosts_parents() {
	my %docs = ();
	$docs{'parents'} = q(Parents: Optional. Assign this host one or more parents, for purposes of physical dependency analysis during outages. Parent-child relationships may also be managed via 'Hosts -> Parent Child'.);
	return %docs;
}

sub manage_hosts_hostgroups() {
	my %docs = ();
	$docs{'hostgroups'} = q(Hostgroups: Optional. Assign this host one or more hostgroups. Hostgroups  may also be managed via 'Hosts -> Hostgroups'.);
	return %docs;
}

sub manage_hosts_escalations() {
	my %docs = ();
	$docs{'escalations'} = q(Escalation trees: Optional. Select host and service escalation trees appropriate for this host. When a service escalation tree is assigned here, all services on this host will use the same escalation tree. To use different escalation trees for different services, each service must have its own escalation tree. In that case, do not assign a service escalation tree here.);
	$docs{'host_escalation_tree'} = q(Host escalation tree: Optional. Select an escalation tree appropriate for this host. To avoid amplified notifications (i.e., multiple notifications for the same event), a host escalation tree assigned to this host should not also be assigned to a hostgroup in which the host is a member.);
	$docs{'service_escalation_tree'} = q(Service escalation tree: Optional. Select an escalation tree appropriate for all services on this host. When a service escalation tree is assigned here, all services on this host will use the same escalation tree. To use different escalation trees for different services, each service must have its own escalation tree. In that case, do not assign a service escalation tree here.);
	return %docs;
}

sub manage_hosts_host_externals() {
	my %docs = ();
	$docs{'host_externals'} = q(Externals are used to create configuration files for external applications, such as the GroundWork Distributed Monitoring Agents. A host external provides the detail relevant to a particular host, that will end up in such a file.<p class=append>The host externals you manage here originate as generic host externals, established uner Configuration -> Hosts -> Host externals. But once you apply a host external to a particular host, that copy becomes independently modifiable. You can choose to manage changes to the copies from the generic host external, or modify the individual copies and manage them separately.</p>);
	return %docs;
}

sub manage_hosts_services() {
	my %docs = ();
	$docs{'services'} = q(Add, modify and remove services for this host. Managing services from this page will in all likelihood put the host out of sync with its service profiles. After making changes, use caution when applying profiles to this host.);
	return %docs;
}

sub manage_hosts_service_externals() {
	my %docs = ();
	$docs{'service_externals'} = q(Externals are used to create configuration files for external applications, such as the GroundWork Distributed Monitoring Agents. A service external provides the detail relevant to a particular service, that will end up in such a file.<p class=append>The service externals you manage here originate as generic service externals, established uner Configuration -> Services -> Service externals. But once you apply a service external to a particular host service, that copy becomes independently modifiable. You can choose to manage changes to the copies from the generic service external, or modify the individual copies and manage them separately.</p>);
	return %docs;
}

sub servicegroups() {
	my %docs = ();
	$docs{'name'} = q();
	$docs{'alias'} = q(Alias: Required. This directive is used to define a longer name or description used to identify the service group. It is provided to allow you to more easily identify a particular service group.);
	$docs{'notes'} = q(Notes: Optional. This field is intended to describe common features of the service group (e.g., the usage, function, or specific application software being monitored). This information is shown on the service group detail page within the status viewer.);
	$docs{'service_escalation_tree'} = q(Service escalation tree: Optional. Select the service escalation tree applicable to this service group (see Escalations -> Escalation Trees).  FIX MINOR:  Add a warning here about amplified notifications and assigning the same service escalation tree to a host or hostgroup?  Or a note about all services in the service group receiving same service escalation tree?);
	return %docs;
}

sub manage_hosts_service_detail() {
	my %docs = ();
	$docs{'notes'} = q(Notes: Optional. This field is intended to hold a free-text description of this service. It is displayed in the status viewer, and can be included in notifications via the $SERVICENOTES$ macro. It is commonly used to provide details of the purpose or intended characteristics of the service.);
	$docs{'template'} = q(Service template: Required.  Select the appropriate service template for this service.);
	$docs{'use_template_command'} = q(Inherit check from template: If checked, the check command and command line options are derived from the service template. Be careful to ensure the service template has a check command defined before checking this option.);
	$docs{'check_command'} = q(Check command: If 'Inherit check from template' is unchecked, select the command that Nagios will run to check the status of the service.);
	$docs{'command_line'} = q(Command line: If 'Inherit check from template' is unchecked and if check command requires arguments, enter the check command with command arguments separated by a ! character. Example: check-disk!/dev/sda1);
	$docs{'extinfo'} = q(Extended service info template: Optional. Defines extended service information for this service name. The template controls the icon and url link as seen in Nagios.);
	$docs{'service_escalation_tree'} = q(Service escalation tree: Optional. Select an escalation tree appropriate for this service name. To avoid amplified notifications (i.e., multiple notifications for the same event), a service escalation tree assigned to a service name should not also be assigned to the host or one of the host's hostgroups.);
	return %docs;
}

sub manage_hosts_service_check() {
	my %docs = ();
	$docs{'service_check'} = q(If you are satisfied with the check as inherited from the template, do nothing on this page. Otherwise uncheck the inherit checkbox and make the necessary changes. Use the test button to check the argument values, but bear in mind that the check command is run under the web servers account, so there may be issues with certain checks.);
	$docs{'use_template_command'} = q(Inherit check from template: If checked, the check command and command line options are derived from the service template. Be careful to ensure the service template has a check command defined before checking this option.);
	$docs{'check_command'} = q(Check command: If 'Inherit check from template' is unchecked, select the command that Nagios will run to check the status of the service.);
	$docs{'command_line'} = q(Command line: If 'Inherit check from template' is unchecked and if check command requires arguments, enter the check command with command arguments separated by a ! character. Example: check-disk!/dev/sda1);
	$docs{'service_instance'} = q(If this check is the same as other checks on this host, where the check command is the same, all of the settings on the service detail page are the same, and only the arguments differ, you can define a set of checks here without creating new services. For example, a disk check can be defined for multiple partitions, or an SNMP check on a network device can be defined for multiple interfaces. Enter an explicit suffix to add a single instance, or enter a range of numbers to add a list of numbered instances prefixed with an underscore. The instance name suffixes are appended to the service name, so we recommend using an underscore for the first character in the suffix.<p class=append>Service instances can be set active or inactive. If any service instances are defined, the base unsuffixed service does not appear in the configuration; only the active instances appear. If some of the instances for a service are set inactive, those particular instances will be ignored, and any active instances will still be in play. If all instances for a service are set inactive, neither the instances nor the base unsuffixed service will appear in the configuration.</p>);
	$docs{'macro_arguments'} = q(If this service check is run from an external source and not directly by Nagios, you can specify here a set of strings that can be referenced by $ARG#$ macros (<tt>$ARG1$</tt>, <tt>$ARG2$</tt>, ...) in your service externals for this service.  Note that if you define Multiple Instances (see below), a special <tt>$INSTANCESUFFIX$</tt> macro is also available.  This can be used to simplify construction of per-instance externals arguments, by inheriting the base-service externals arguments.  The expansion of <tt>$INSTANCESUFFIX$</tt> will omit a leading underscore in an instance name suffix, making it a practical substitution for some uses.);
	$docs{'inherit_ext_args'} = q(<p>Inherit from generic service:  This option controls whether or not the externals arguments for this host service are inherited from the generic service on which the host service is based.);
	$docs{'externals_arguments'} = q(<p>Externals arguments:  You may specify here a series of <tt>!</tt>-separated strings which will be substituted into $ARG#$ macro references (that is, <tt>$ARG1$</tt>, <tt>$ARG2$</tt>, ...) within externals associated with this service check.</p>);
	return %docs;
}

sub manage_hosts_service_dependencies() {
	my %docs = ();
	$docs{'dependencies'} = q(Add or remove service dependencies here. To add a dependency, select from the dependency list and after the screen refreshes, choose the appropriate host.);
	$docs{'dependency'} = q(Service dependency: Select the service dependency template that defines a master service relationship on this host.);
	$docs{'master_host'} = q(Select from the list a host where the master service resides.);
	$docs{'master_service'} = q(This is the service referenced by the chosen service dependency.);
	return %docs;
}

sub parent_child() {
	my %docs = ();
	$docs{'physical_dependency'} = q(Parent-child relationships are used to describe the physical paths taken to transfer monitoring information from various nodes all the way to the central monitoring server. This helps during outages to suppress both pointless status checks and redundant alarms and notifications.);
	$docs{'parent_host'} = q(Select a host on which other (child) hosts depend for physical transfer of monitoring information on the way to the top-level monitoring server. This will define part of a physical dependency relationship, used to suppress excess checks and notifications during outages.);
	$docs{'children'} = q(Select the hosts that should be treated as children of the Parent host you selected above, for purposes of physical-dependency analysis during outages.);
	return %docs;
}

sub externals() {
	my %docs = ();
	$docs{'apply_host'} = q(The <i>Replace existing externals</i> and <i>Merge with existing externals</i> actions allow you to apply the external definition you just edited to existing externals already associated with hosts. These actions are entirely optional, and you may or may not want to execute one of them at this time.<p class=append><i>Replace existing externals</i> will overwrite all copies of this external for all the hosts where they were previously established, regardless of whether those individual copies were subsequently edited.</p><p class=append><i>Merge with existing externals</i> will only overwrite those previously established host externals which have not been modified since they were initially attached or last applied from here to particular hosts. This allows you to preserve any local overrides you have in place. An applied host external can be manually marked as modified even if the text remains unchanged, to protect it from future mass updates here.</p>);
	$docs{'apply_service'} = q(The <i>Replace existing externals</i> and <i>Merge with existing externals</i> actions allow you to apply the external definition you just edited to existing externals already associated with services on hosts. These actions are entirely optional, and you may or may not want to execute one of them at this time.<p class=append><i>Replace existing externals</i> will overwrite all copies of this external for all the host services where they were previously established, regardless of whether those individual copies were subsequently edited.</p><p class=append><i>Merge with existing externals</i> will only overwrite those previously established host service externals which have not been modified since they were initially attached or last applied from here to individual services on particular hosts. This allows you to preserve any local overrides you have in place. An applied host service external can be manually marked as modified even if the text remains unchanged, to protect it from future mass updates here.</p>);
	$docs{'reset_host'} = q(<i>Reset to Generic Detail</i> ignores the content of the Detail above, brings back the original text from the generic host external, and marks this host external as unmodified. That allows this host external to be subject to mass update in Merge operations run from the generic host external.<p class=append><i>Save</i> captures your edits above, and marks this host external as modified. That will prevent it from being updated during Merge operations run from the generic host external.</p>);
	$docs{'reset_service'} = q(<i>Reset to Generic Detail</i> ignores the content of the Detail above, brings back the original text from the generic service external, and marks this host service external as unmodified. That allows this host service external to be subject to mass update in Merge operations run from the generic service external.<p class=append><i>Save</i> captures your edits above, and marks this host service external as modified. That will prevent it from being updated during Merge operations run from the generic service external.</p>);
	$docs{'mark_host'} = q(<i>Mark as Modified</i> ignores any changes to the content of the Detail above, and just marks this host external as modified from the original text of the generic host external. That prevents this host external from being changed during Merge operations run from the generic host external.<p class=append><i>Save</i> captures your edits above, and marks this host external as modified. That will prevent it from being updated during Merge operations run from the generic host external.</p>);
	$docs{'mark_service'} = q(<i>Mark as Modified</i> ignores any changes to the content of the Detail above, and just marks this host service external as modified from the original text of the generic service external. That prevents this host service external from being changed during Merge operations run from the generic service external.<p class=append><i>Save</i> captures your edits above, and marks this host service external as modified. That will prevent it from being updated during Merge operations run from the generic service external.</p>);
	return %docs;
}

sub setup() {
	my %docs = ();
	$docs{'login_authentication'} = q(Login authentication: Select none, active or passive. none = no authentication -- all users have full control; active = users are prompted to login and access checks are enabled; passive = no login if user account is passed in URL but access checks are enabled (single sign-on method).);
	$docs{'session_timeout'} = q(Session timeout: With login authentication active, this is the number of seconds of inactivity before a user is prompted to login.);
	$docs{'monarch_version'} = q(Monarch version: Release of Monarch in use, as saved in the Monarch database.);
	$docs{'nagios_version'} = q(Nagios version: Release of Nagios in use, as saved in the Monarch database.);
	$docs{'nagios_etc'} = q(Nagios etc: Path to the folder containing nagios.cfg.);
	$docs{'nagios_bin'} = q(Nagios bin: Path to the folder containing the nagios binary.);
	$docs{'monarch_home'} = q(Monarch home: The Monarch installation path. Your web server must have read write access.);
	$docs{'backup_home'} = q(Backup dir: This folder is used to backup your Nagios files and the Monarch database. Your web server must have read/write access.);
	$docs{'max_tree_nodes'} = q(Max tree nodes: The number of hosts or services to appear in the left menu tree before the list is segmented. The larger the number the longer page loads will take. Default=500);
	$docs{'max_unlocked_backups'} = q(Max unlocked backups: The maximum number of unlocked Monarch backups that will remain in the system after a successful Commit.  This number must be either 0 or an empty string (to disable all such automatic deletions), or at least 10.);
	$docs{'enable_externals'} = q(Enable externals: This is an advanced feature that requires some knowledge of Perl. Externals are configuration data not directly related to Nagios, but which can be useful when integrating other tools. Externals can be assigned to hosts and services. Your knowledge of Perl may be required to modify MonarchExternals.pm. Check this box and Save Setup to display the Build Externals option in the left-side navigation panel, along with options in other screens to view and edit externals. Select Build Externals here under Control to execute the code in MonarchExternals.pm.);
	return %docs;
}

sub backups() {
	my %docs = ();
	$docs{'commit'} = q(<p>Annotation: Enter a description of what configuration changes are motivating you to put the setup into production at this time.  This information will be displayed in the list of backups in the Configuration > Control > &quot;Back up and restore&quot; screen to help you figure out later on which backups are most important to you.  The more descriptive you are now, the less confusion will be present later on.</p><p class=append>The automatic backup taken at this time will include a set of the Nagios config files that mirrors the content of the <tt>monarch</tt> database, along with a separate copy of that database data.  Restoring this backup will restore only the database content; a subsequent Commit would be needed to put that data back into production.</p>);
	$docs{'annotation'} = q(<p>Annotation: Enter a description of what configuration changes are motivating you to capture a backup at this time.  This information will be displayed in the list of backups in the &quot;Back up and restore&quot; screen to help you figure out later on which backups are most important to you.  The more descriptive you are now, the less confusion will be present later on.</p><p class=append>Note that a manually-initiated backup taken at this time will include the current running copies of Nagios config files, along with the current content of the <tt>monarch</tt> database.  The database will contain any changes made since the last Commit, and will therefore not necessarily generate the same set of Nagios config files captured in this backup.  Restoring this backup will restore only the database content; a subsequent Commit would be needed to put that data back into production.</p>);
	$docs{'lock'} = q(Lock: If this box is checked, this new backup will be marked as locked and will not be subject to the limit on the number of unlocked backups.  Instead, it will be saved indefinitely unless it is later unlocked. The limit is set by the &quot;Max unlocked backups&quot; option in Configuration > Control > Setup.);
	$docs{'restore_advice'} = q(This restore operation only affects the Monarch database.  Nagios remains running with the same configuration it had before the restore.  The restored data will not be placed into production until you run a separate Commit.);
	$docs{'restore'} = q(Do you really want to restore the following backup?&nbsp; <span style="color: #CC0000; font-weight: bold;">Doing so will first destroy your existing setup.</span>&nbsp; Also, make sure that nobody else is trying to make configuration changes at this time.);
	$docs{'unlock'} = q(Do you really want to unlock the following backup(s)?  This will make them subject to possible automatic deletion when the &quot;Max unlocked backups&quot; parameter (set in Control > Setup) is exceeded during a Commit operation.);
	$docs{'delete'} = q(Do you really want to delete the following backup(s)?);
	$docs{'explain'} = q(A &quot;locked&quot; backup is one which is not subject to the limit on the number of backups that will remain in the system after a successful Commit.  That limit is set by the &quot;Max unlocked backups&quot; option in Control > Setup.  Unlocking a backup makes it subject to that limit.  When the limit is reached during a Commit, the oldest extra unlocked backups will be deleted.);
	return %docs;
}

sub ez_defaults() {
	my %docs = ();
	$docs{'profile'} = q(Host profile: Required. Select the appropriate host profile for all hosts added with this tool. This should in most circumstances be a simple ping profile.);
	$docs{'contactgroup'} = q(Contact group: Required. Select the appropriate contact group for all contacts added with this tool.);
	$docs{'contact_template'} = q(Contact template: Required. Select the appropriate contact template for all contacts added with this tool.);
	return %docs;
}

sub ez_host() {
	my %docs = ();
	$docs{'hostgroups'} = q(Assign host groups or let the profile assign them. If the selected profile shows host groups, do nothing and they will be assigned to this host. Otherwise, add host groups to override those on the profile.);
	return %docs;
}

sub monarch_groups() {
	my %docs = ();
	$docs{'contactgroups'} = q(Selecting a contact group here will provide the default contact group for hosts and services where no contact group has been defined, and it WILL OVERRIDE the contact groups defined on host templates and service templates. Contact groups assigned to sub groups will in turn override these contact groups.);
	$docs{'status'} = q(Setting the group inactive will remove the member hosts and their services from Nagios. The configurations of these hosts will still be preserved within Monarch. Hosts can be reinstated by simply removing them from the inactive group or removing the inactive setting for the group.);
	$docs{'inactive'} = q(Setting the group inactive will remove the member hosts and their services from Nagios, along with any parent relationships, host dependencies, service dependencies, and similar setup. This can be useful, for instance, in the early stages of setting up new hosts, before their configuration is complete.);
	$docs{'sync_hosts'} = q(If the group is inactive, the Status Viewer (GroundWork Monitor) will also not show these hosts, unless you Sync hosts to Foundation. This might be useful for hosts which are monitored via some non-Nagios mechanism which feeds its results directly to Foundation.);
	$docs{'build_instance_properties'} = q(These properties are required only if you wish to use this group as part of a distributed Nagios environment. It is not necessary to set these values to perform a pre-flight check for this group.);
	$docs{'location'} = q(Build folder: The build folder is usually /usr/local/groundwork/nagios/etc/{hostname} where you have replaced {hostname} with the actual standby or child server hostname used to name the group. In general, this may be any directory writeable by the 'nagios' user where you wish to store the configuration files.  An incorrect entry or a directory with incorrect permissions will cause the build instance to fail.  For a Monarch group used simply to reference hosts for generating externals, you must specify /usr/local/groundwork/apache2/htdocs/{GDMAConfigDir} instead, where you have replaced {GDMAConfigDir} with the value of the GDMAConfigDir option in the GDMA client gdma_auto.conf config file (usually just 'gdma').);
	$docs{'nagios_etc'} = q(Nagios etc folder: For a Monarch group used to manage a child server, enter the path of the Nagios configuration directory on the target host (usually /usr/local/groundwork/nagios/etc). This value will only be used to construct pathnames for entries inside the generated nagios.cfg file, but it must reflect the actual location on the target host where the Nagios object configuration files will reside. For a Monarch group used simply to reference hosts for generating externals, you must leave this field empty.);
	$docs{'use_hosts'} = q(Force hosts: Select this option to dictate the list of hosts to be included in this instance. This option will override the sub group host lists while still applying the macros from those groups where common members reside.);
	$docs{'host_active_checks_enabled'} = q(Host active checks enabled: First choose whether the 'Active checks enabled' option for host checks in this group should be inherited from the main configuration (or from the parent group, if this is a sub-group). If not, then the second box that will appear here will control all the settings:  unchecked = active checks disabled, checked = active checks enabled. If this setting is not inherited, your explicit choice here will override the settings in the main configuration (or the parent group) for these host checks, when the configuration for the top-level group is created. If a given host belongs to multiple direct or indirect subgroups of the top group, and one subgroup inherits and one does not, the choice for the subgroup that does not inherit will rule.);
	$docs{'host_passive_checks_enabled'} = q(Host passive checks enabled: First choose whether the 'Passive checks enabled' option for host checks in this group should be inherited from the main configuration (or from the parent group, if this is a sub-group). If not, then the second box that will appear here will control all the settings:  unchecked = passive checks disabled, checked = passive checks enabled. If this setting is not inherited, your explicit choice here will override the settings in the main configuration (or the parent group) for these host checks, when the configuration for the top-level group is created. If a given host belongs to multiple direct or indirect subgroups of the top group, and one subgroup inherits and one does not, the choice for the subgroup that does not inherit will rule.);
	$docs{'service_active_checks_enabled'} = q(Service active checks enabled: First choose whether the 'Active checks enabled' option for service checks in this group should be inherited from the main configuration (or from the parent group, if this is a sub-group). If not, then the second box that will appear here will control all the settings:  unchecked = active checks disabled, checked = active checks enabled. If this setting is not inherited, your explicit choice here will override the settings in the main configuration (or the parent group) for these service checks, when the configuration for the top-level group is created. If a given host belongs to multiple direct or indirect subgroups of the top group, and one subgroup inherits and one does not, the choice for the subgroup that does not inherit will rule.);
	$docs{'service_passive_checks_enabled'} = q(Service passive checks enabled: First choose whether the 'Passive checks enabled' option for service checks in this group should be inherited from the main configuration (or from the parent group, if this is a sub-group). If not, then the second box that will appear here will control all the settings:  unchecked = passive checks disabled, checked = passive checks enabled. If this setting is not inherited, your explicit choice here will override the settings in the main configuration (or the parent group) for these service checks, when the configuration for the top-level group is created. If a given host belongs to multiple direct or indirect subgroups of the top group, and one subgroup inherits and one does not, the choice for the subgroup that does not inherit will rule.);
	$docs{'assign_hosts'} = q(Assign hosts individually or by host group. The preferred method is to assign host groups; new hosts will then be included here when they are assigned to such a host group.);
	$docs{'sub_groups'} = q(Sub groups are mostly useful only in special circumstances, in particular to build multiple instances of Nagios. Select from the bottom list and click 'Add Group(s)' to assign groups. Select from the upper list and click 'Remove' to un-assign groups.);
	$docs{'macros'} = q(Select macros from the bottom list and click 'Add Macro(s)' to assign them to the group. Adjust the values as needed and select 'Save' to apply them to the group.<p class=append>To use the label option, you must select 'Enable label' and enter a value, then click 'Save' to apply it to the group. The value is appended to the service description on services where the macro is found, so we suggest using an underscore as the first character.</p>);
	return %docs;
}

sub monarch_macros() {
	my %docs = ();
	$docs{'macros'} = q(Group macros extend the Nagios $ARG#$ macros (that is, <tt>$ARG1$</tt>, <tt>$ARG2$</tt>, ...) on service checks. Use names that are unique and not likely in the least to match some other part of the check command string. The values defined here become the default values when the macros are assigned to a group. Adjust the values as needed and click 'Save'. Note that changing a value here will not be applied to groups where the macro is already assigned.);
	return %docs;
}

sub access_list() {
	my %docs = ();
	$docs{'groups'} = q(To add, modify or delete groups and macros select Manage, and then choose the groups to which members of this user group have access. Access includes pre-flight checks and the capability to build and deploy instances. When a new group is defined by a member of this user group, all members will automatically have access.);
	$docs{'ez'} = q(Select Enable to allow access to the EZ interface for this user group, and then select a view option. Main-EZ: The main view is the default interface when users log in. EZ-Main: The EZ view is the default interface when users log in. EZ: The EZ view is the only interface available when users login. Deselect Enable to hide the EZ view.);
	return %docs;
}

sub nagios_cfg() {
	my %docs = ();
	$docs{'log_file'} = q(Log file: This is the main log file where service and host events are logged for historical purposes.  This should be the first option specified in the config file!);
	$docs{'object_cache_file'} = q(Object cache file: This directive is used to specify a file in which a cached copy of object definitions should be stored. The cache file is (re)created every time Nagios is (re)started and is used by the CGIs. It is intended to speed up config file caching in the CGIs and allow you to edit the source object config files while Nagios is running without affecting the output displayed in the CGIs.);
	$docs{'resource_file'} = q(Resource file: This is an optional resource file that contains $USERx$ macro definitions. Multiple resource files can be specified by using multiple resource_file definitions.  The CGIs will not attempt to read the contents of resource files, so information that is considered to be sensitive (usernames, passwords, etc) can be defined as macros in this file and restrictive permissions (600) can be placed on this file.);
	$docs{'status_file'} = q(Status file: This is where the current status of all monitored services and hosts is stored.  Its contents are read and processed by the CGIs. The contents of the status file are deleted every time Nagios restarts.);
	$docs{'website_url'} = q(Website URL:  The base URL used to access Nagios CGI pages.  It is used in the construction of values for the $HOSTINFOURL$ and $SERVICEINFOURL$ macros.  This value would be http://localhost/nagios-app in the GroundWork context, except that the protocol might be https instead, and you will need to replace localhost with the hostname of your GroundWork server as otherwise used to access the GroundWork user interface (probably using a fully-qualified hostname).);

	$docs{'aggregate_status_updates'} = q(Aggregated status updates option: This option, supported only in Nagios versions 1.x and 2.x, determines whether or not Nagios will aggregate updates of host, service, and program status data. If you do not enable this option, status data is updated every time a host or service check occurs. This can result in high CPU loads and file I/O if you are monitoring a lot of services. If you want Nagios to only update status data (in the status file) every few seconds (as determined by the status_update_interval option), enable this option. If you want immediate updates, disable it. I would highly recommend using aggregated updates (even at short intervals) unless you have good reason not to. In Nagios 3.x, aggregated updates are always used, so this option for turning them on and off is not available.);
	$docs{'status_update_interval'} = q(Aggregated status data update interval: This setting determines how often (in seconds) Nagios will update status data in the status file. The minimum update interval is five seconds. If you have disabled aggregated status updates (with the aggregate_status_updates option, which is available only if you are running an older 1.x or 2.x version of Nagios), this option has no effect.);

	$docs{'nagios_user'} = q(Nagios user: This determines the effective user that Nagios should run as. You can either supply a username or a UID.);
	$docs{'nagios_group'} = q(Nagios group: This determines the effective group that Nagios should run as. You can either supply a group name or a GID.);

	$docs{'enable_notifications'} = q(Enable notifications: This option determines whether or not Nagios will send out notifications when it initially (re)starts. If this option is disabled, Nagios will not send out notifications for any host or service. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you'll have to use the appropriate external command or change it via the web interface.);
	$docs{'execute_service_checks'} = q(Execute service checks: This option determines whether or not Nagios will execute service checks when it initially (re)starts. If this option is disabled, Nagios will not actively execute any service checks and will remain in a sort of 'sleep' mode (it can still accept passive checks unless you've disabled them). This option is most often used when configuring backup monitoring servers, as described in the documentation on redundancy, or when setting up a distributed monitoring environment. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you'll have to use the appropriate external command or change it via the web interface.);
	$docs{'accept_passive_service_checks'} = q(Accept passive service checks: This option determines whether or not Nagios will accept passive service checks when it initially (re)starts. If this option is disabled, Nagios will not accept any passive service checks. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you'll have to use the appropriate external command or change it via the web interface.);

	$docs{'enable_event_handlers'} = q(Enable event handlers: This option determines whether or not Nagios will run event handlers when it initially (re)starts. If this option is disabled, Nagios will not run any host or service event handlers. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you'll have to use the appropriate external command or change it via the web interface.);

	$docs{'check_external_commands'} = q(Check external commands: This option allows you to specify whether or not Nagios should check for external commands (in the command file defined below).  By default Nagios will *not* check for external commands, just to be on the cautious side.  If you want to be able to use the CGI command interface you will have to enable this.  Setting this value to unchecked disables command checking (the default), other values enable it.);
	$docs{'command_check_interval'} = q(Command check interval: This is the interval at which Nagios should check for external commands. This period is specified here as a multiple of the interval_length that you specify later.  If you leave that at its default value of 60 (seconds), a value of 1 here will cause Nagios to check for external commands every minute.  If you specify a number followed by an 's' (e.g., 15s), this will be interpreted to mean actual seconds rather than a multiple of the interval_length variable. Note: In addition to reading the external command file at regularly scheduled intervals, Nagios will also check for external commands after event handlers are executed. NOTE: Setting this value to -1 causes Nagios to check the external command file as often as possible.);
	$docs{'command_file'} = q(External command file: This is the file that Nagios checks for external command requests. It is also where the command CGI will write commands that are submitted by users, so it must be writeable by the user that the web server is running as (under Linux, usually 'nobody').  Permissions should be set at the directory level instead of on the file, as the file is deleted every time its contents are processed.);
	$docs{'comment_file'} = q(Comment file: This is the file that Nagios will use for storing host and service comments.);
	$docs{'downtime_file'} = q(Downtime file: This is the file that Nagios will use for storing host and service downtime data.);
	$docs{'lock_file'} = q(Lock file: This is the lockfile that Nagios will use to store its PID number in when it is running in daemon mode.);
	$docs{'temp_file'} = q(Temp file: This is a temporary file that is used as scratch space when Nagios updates the status log, cleans the comment file, etc.  This file is created, used, and deleted throughout the time that Nagios is running.);
	$docs{'temp_path'} = q(<p>Temp path:  This is a directory (such as <tt>/usr/local/groundwork/nagios/tmp</tt>) that Nagios can use as scratch space for creating temporary files used during the monitoring process. You should run tmpwatch, or a similiar utility, on this directory occasionally to delete files older than 24 hours.</p>);
	$docs{'log_rotation_method'} = q(Log rotation method: This is the log rotation method that Nagios should use to rotate the main log file. Values are as follows. n = None -- don't rotate the log. h = Hourly rotation (top of the hour). d = Daily rotation (midnight every day). w = Weekly rotation (midnight on Saturday evening). m = Monthly rotation (midnight last day of month).);
	$docs{'log_archive_path'} = q(Log archive path: This is the directory where archived (rotated) log files should be placed (assuming you've chosen to do log rotation).);
	$docs{'use_syslog'} = q(Use syslog: If you want messages logged to the syslog facility as well as the NetAlarm log file, set this option to checked.  If not, set it to unchecked.);
	$docs{'log_notifications'} = q(Log notifications: If you don't want notifications to be logged, set this value to unchecked. If notifications should be logged, set the value to checked.);
	$docs{'log_service_retries'} = q(Log service retries: If you don't want service check retries to be logged, set this value to unchecked.  If retries should be logged, set the value to checked.);
	$docs{'log_host_retries'} = q(Log host retries: If you don't want host check retries to be logged, set this value to unchecked.  If retries should be logged, set the value to checked.);
	$docs{'log_event_handlers'} = q(Log event handlers: If you don't want host and service event handlers to be logged, set this value to unchecked.  If event handlers should be logged, set the value to checked.);
	$docs{'log_initial_states'} = q(Log initial states: If you want Nagios to log all initial host and service states to the main log file (the first time the service or host is checked) you can enable this option by setting this value to checked.  If you are not using an external application that does long term state statistics reporting, you do not need to enable this option.  In this case, set the value to unchecked.);
	$docs{'log_external_commands'} = q(Log external commands: If you don't want Nagios to log external commands, set this value to unchecked.  If external commands should be logged, set this value to checked. Note: This option does not include logging of passive service checks -- see the option below for controlling whether or not passive checks are logged.);
	$docs{'log_passive_service_checks'} = q(Log passive service checks: If you don't want Nagios to log passive service checks, set this value to unchecked.  If passive service checks should be logged, set this value to checked.);
	$docs{'global_host_event_handler'} = q(Global host event handler: This option allows you to specify a host event handler command that is to be run for every host state change. The global event handler is executed immediately prior to the event handler that you have optionally specified in each host definition. The command argument is the short name of a command definition that you define in your host configuration file. Read the Nagios HTML docs for more information.);
	$docs{'global_service_event_handler'} = q(Global service event handler: This option allows you to specify a service event handler command that is to be run for every host state change. The global event handler is executed immediately prior to the event handler that you have optionally specified in each service definition. The command argument is the short name of a command definition that you define in your host configuration file. Read the Nagios HTML docs for more information.);
	$docs{'inter_check_delay_method'} = q(Inter check delay method: Inter check delay method: This is the method that Nagios should use when initially 'spreading out' service checks when it starts monitoring. The default is to use smart delay calculation, which will try to space all service checks out evenly to minimize CPU load. Using the dumb setting will cause all checks to be scheduled at the same time (with no delay between them)!  This is not a good thing for production, but is useful when testing the parallelization functionality. None: selected = None -- don't use any delay between checks. Dumb: selected = Use a 'dumb' delay of 1 second between checks. Smart: selected = Use 'smart' inter-check delay calculation. Delay: selected = Enter an user-specified delay of x.xx seconds.);
	$docs{'service_interleave_factor'} = q(Service interleave factor: This variable determines how service checks are interleaved. Interleaving the service checks allows for a more even distribution of service checks and reduced load on remote hosts.  Setting this value to 1 is equivalent to how versions of Nagios previous to 0.0.5 did service checks.  Set this value to s (smart) for automatic calculation of the interleave factor unless you have a specific reason to change it. Smart: selected = Use 'smart' interleave factor calculation. Value: selected = Enter an interleave factor of x, where x is a number greater than or equal to 1.);
	$docs{'max_concurrent_checks'} = q(Max concurrent checks: This option allows you to specify the maximum number of service checks that can be run in parallel at any given time. Specifying a value of 1 for this variable essentially prevents any service checks from being run in parallel. Specifying a value of 0 (the default) does not place any restrictions on the number of concurrent checks. You'll have to modify this value based on the system resources you have available on the machine that runs Nagios, as it directly affects the maximum load that will be imposed on the system (processor utilization, memory, etc.).);
	$docs{'service_reaper_frequency'} = q(Service reaper frequency: This is the frequency (in seconds!) that Nagios will process the results of services that have been checked.);
	$docs{'sleep_time'} = q(<p>Sleep time: This is the number of seconds to sleep between checking for system events and service checks that need to be run.  We would recommend <b>not</b> changing this from its default value of 1 second.</p>);
	$docs{'notification_timeout'} = q(<p>Notification timeout: This is the maximum number of seconds that Nagios will allow notification commands to be run. If a notification command exceeds this time limit, it will be killed and a warning will be logged.</p><p class=append>There is often widespread confusion as to what this option really does. It is meant to be used as a last-ditch mechanism to kill off commands which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each notification command finishes executing within this time limit. If a notification command runs longer than this limit, Nagios will think it is a runaway process and kill it off.</p>);
	$docs{'service_check_timeout'} = q(<p>Service check timeout: This is the maximum number of seconds that Nagios will allow service checks to run. If checks exceed this limit, they are killed and a CRITICAL state is returned. A timeout error will also be logged.</p><p class=append>There is often widespread confusion as to what this option really does. It is meant to be used as a last-ditch mechanism to kill off plugins which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each service check normally finishes executing within this time limit. If a service check runs longer than this limit, Nagios will think it is a runaway process and kill it off.</p>);
	$docs{'host_check_timeout'} = q(<p>Host check timeout: This is the maximum number of seconds that Nagios will allow host checks to run. If checks exceed this limit, they are killed, a CRITICAL state is returned, and the host will be assumed to be DOWN. A timeout error will also be logged.</p><p class=append>There is often widespread confusion as to what this option really does. It is meant to be used as a last-ditch mechanism to kill off plugins which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each host check normally finishes executing within this time limit. If a host check runs longer than this limit, Nagios will think it is a runaway process and kill it off.</p>);
	$docs{'ocsp_timeout'} = q(OCSP timeout: This is the maximum number of seconds that Nagios will allow an obsessive compulsive service processor command to be run. If a command exceeds this time limit, it will be killed and a warning will be logged.);
	$docs{'ochp_timeout'} = q(OCHP timeout: This is the maximum number of seconds that Nagios will allow an obsessive compulsive host processor command to be run. If a command exceeds this time limit, it will be killed and a warning will be logged.);
	$docs{'perfdata_timeout'} = q(Performance data timeout: This is the maximum number of seconds that Nagios will allow a host performance data processor command or service performance data processor command to be run. If a command exceeds this time limit, it will be killed and a warning will be logged.);
	$docs{'event_handler_timeout'} = q(<p>Event handler timeout: This is the maximum number of seconds that Nagios will allow event handlers to be run. If an event handler exceeds this time limit, it will be killed and a warning will be logged.</p><p class=append>There is often widespread confusion as to what this option really does. It is meant to be used as a last-ditch mechanism to kill off commands which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each event handler command normally finishes executing within this time limit. If an event handler runs longer than this limit, Nagios will think it is a runaway process and kill it off.</p>);
	$docs{'retain_state_information'} = q(Retain state information: This setting determines whether or not Nagios will save state information for services and hosts before it shuts down. Upon startup Nagios will reload all saved service and host state information before starting to monitor.  This is useful for maintaining long-term data on state statistics, etc, but will slow Nagios down a bit when it (re)starts.  Since it's only a one-time penalty, I think it's well worth the additional startup delay. Checked = enabled.);
	$docs{'state_retention_file'} = q(State retention file: This is the file that Nagios should use to store host and service state information before it shuts down. The state information in this file is also read immediately prior to starting to monitor the network when Nagios is restarted. This file is used only if the preserve_state_information variable is checked.);
	$docs{'retention_update_interval'} = q(Retention update interval: This setting determines how often (in minutes) that Nagios will automatically save retention data during normal operation. If you set this value to 0, Nagios will not save retention data at regular intervals, but it will still save retention data before shutting down or restarting.  If you have disabled state retention, this option has no effect.);
	$docs{'use_retained_program_state'} = q(Use retained program state: This setting determines whether or not Nagios will set program status variables based on the values saved in the retention file.  If you want to use retained program status information, set this value to 1.  If not, set this value to 0.);
	$docs{'use_retained_scheduling_info'} = q(Use retained scheduling info: This setting determines whether or not Nagios will retain scheduling info (next check times) for hosts and services when it restarts. If you are adding a large number (or percentage) of hosts and services, it is recommended that this option be disabled when you first restart Nagios, as it can adversely skew the spread of initial checks. Otherwise you will probably want to leave it enabled.);
	$docs{'retained_host_attribute_mask'} = q(<p>Retained host attribute mask:<br>The standard setting for this option is 0.</p><p class=append>WARNING: This is an advanced feature. You will need to read the Nagios source code to use alternate values for this option effectively.</p><p class=append>This option determines which host attributes are NOT retained across program restarts. The value for this option is a bitwise AND of values specified by the &quot;MODATTR_&quot; definitions in the <tt>include/common.h</tt> source code file. By default (i.e., with a setting of 0), all host attributes are retained.</p>);
	$docs{'retained_process_host_attribute_mask'} = q(<p>Retained process host attribute mask:<br>The standard setting for this option is 0.</p><p class=append>WARNING: This is an advanced feature. You will need to read the Nagios source code to use alternate values for this option effectively.</p><p class=append>This option determines which host process attributes are NOT retained across program restarts. The value for this option is a bitwise AND of values specified by the &quot;MODATTR_&quot; definitions in the <tt>include/common.h</tt> source code file. By default (i.e., with a setting of 0), all host process attributes are retained.</p>);
	$docs{'retained_contact_host_attribute_mask'} = q(<p>Retained contact host attribute mask:<br>The standard setting for this option is 0.</p><p class=append>WARNING: This is an advanced feature. You will need to read the Nagios source code to use alternate values for this option effectively.</p><p class=append>This option determines which host contact attributes are NOT retained across program restarts. The value for this option is a bitwise AND of values specified by the &quot;MODATTR_&quot; definitions in the <tt>include/common.h</tt> source code file. By default (i.e., with a setting of 0), all host contact attributes are retained.</p>);
	$docs{'retained_service_attribute_mask'} = q(<p>Retained service attribute mask:<br>The standard setting for this option is 0.</p><p class=append>WARNING: This is an advanced feature. You will need to read the Nagios source code to use alternate values for this option effectively.</p><p class=append>This option determines which service attributes are NOT retained across program restarts. The value for this option is a bitwise AND of values specified by the &quot;MODATTR_&quot; definitions in the <tt>include/common.h</tt> source code file. By default (i.e., with a setting of 0), all service attributes are retained.</p>);
	$docs{'retained_process_service_attribute_mask'} = q(<p>Retained process service attribute mask:<br>The standard setting for this option is 0.</p><p class=append>WARNING: This is an advanced feature. You will need to read the Nagios source code to use alternate values for this option effectively.</p><p class=append>This option determines which service process attributes are NOT retained across program restarts. The value for this option is a bitwise AND of values specified by the &quot;MODATTR_&quot; definitions in the <tt>include/common.h</tt> source code file. By default (i.e., with a setting of 0), all service process attributes are retained.</p>);
	$docs{'retained_contact_service_attribute_mask'} = q(<p>Retained contact service attribute mask:<br>The standard setting for this option is 0.</p><p class=append>WARNING: This is an advanced feature. You will need to read the Nagios source code to use alternate values for this option effectively.</p><p class=append>This option determines which service contact attributes are NOT retained across program restarts. The value for this option is a bitwise AND of values specified by the &quot;MODATTR_&quot; definitions in the <tt>include/common.h</tt> source code file. By default (i.e., with a setting of 0), all service contact attributes are retained.</p>);
	$docs{'interval_length'} = q(Timing interval length: This is the seconds per unit interval as used in the host/contact/service configuration files.  Setting this to 60 means that each interval is one minute long (60 seconds).  Other settings have not been tested much, so your mileage is likely to vary ...);
	$docs{'execute_service_checks'} = q(Execute service checks: This determines whether or not Nagios will actively execute service checks when it initially starts.  If this option is disabled, checks are not actively made, but Nagios can still receive and process passive check results that come in.  Unless you're implementing redundant hosts or have a special need for disabling the execution of service checks, leave this enabled! Values: checked = enable checks, unchecked = disable checks.);
	$docs{'accept_passive_service_checks'} = q(Accept passive service checks: This determines whether or not Nagios will accept passive service check results when it initially (re)starts. Values: checked = accept passive checks, unchecked = reject passive checks.);
	$docs{'process_performance_data'} = q(Process performance data: This determines whether or not Nagios will process performance data returned from service and host checks.  If this option is enabled, host performance data will be processed using the host perfdata command (defined below) and service performance data will be processed using the service perfdata command (also defined below).  Read the HTML docs for more information on performance data. Values: checked = process performance data, unchecked = do not process performance data.);
	$docs{'use_aggressive_host_checking'} = q(Use aggressive host checking: Nagios tries to be smart about how and when it checks the status of hosts. In general, disabling this option will allow Nagios to make some smarter decisions and check hosts a bit faster. Enabling this option will increase the amount of time required to check hosts, but may improve reliability a bit. Unless you have problems with Nagios not recognizing that a host recovered, it is strongly recommended that you DO NOT enable this option. Values: checked = enable aggressive host checking, unchecked = do not aggressively check hosts.);
	$docs{'obsess_over_services'} = q(Obsess over services: This determines whether or not Nagios will obsess over service checks and run the ocsp_command defined below.  Unless you're planning on implementing distributed monitoring, do not enable this option.  Read the HTML docs for more information on implementing distributed monitoring. Values: checked = obsess over services, unchecked = do not obsess (default).);
	$docs{'ocsp_command'} = q(OCSP command: This is the command that is run for every service check that is processed by Nagios.  This command is executed only if the obsess_over_service option (above) is set to 1 (checked).  The command argument is the short name of a command definition that you define in your host configuration file. Read the HTML docs for more information on implementing distributed monitoring.);
	$docs{'check_for_orphaned_hosts'} = q(Check for orphaned hosts:  This option allows you to enable or disable checks for orphaned host checks. Orphaned host checks are checks which have been executed and have been removed from the event queue, but have not had any results reported in a long time. Since no results have come back in for the host, it is not rescheduled in the event queue. This can cause host checks to stop being executed. Normally it is very rare for this to happen, but it might happen if an external user or process killed off the process that was being used to execute a host check. If this option is enabled and Nagios finds that results for a particular host check have not come back, it will log an error message and reschedule the host check. If you start seeing host checks that never seem to get rescheduled, enable this option and see if you notice any log messages about orphaned hosts.);
	$docs{'check_for_orphaned_services'} = q(Check for orphaned services: This option allows you to enable or disable checks for orphaned service checks. Orphaned service checks are checks which have been executed and have been removed from the event queue, but have not had any results reported in a long time. Since no results have come back in for the service, it is not rescheduled in the event queue. This can cause service checks to stop being executed. Normally it is very rare for this to happen, but it might happen if an external user or process killed off the process that was being used to execute a service check. If this option is enabled and Nagios finds that results for a particular service check have not come back, it will log an error message and reschedule the service check. If you start seeing service checks that never seem to get rescheduled, enable this option and see if you notice any log messages about orphaned services.);
	$docs{'check_service_freshness'} = q(Check service freshness: This option determines whether or not Nagios will periodically check the 'freshness' of service results.  Enabling this option is useful for ensuring passive checks are received in a timely manner. Values: checked = enabled freshness checking, unchecked = disable freshness checking.);
	$docs{'service_freshness_check_interval'} = q(Service freshness check interval: This setting determines how often (in seconds) Nagios will check the 'freshness' of service check results.  If you have disabled service freshness checking, this option has no effect.);
	$docs{'additional_freshness_latency'} = q(Additional freshness latency: This option determines the number of seconds Nagios will add to any host or service freshness threshold it automatically calculates (e.g., those thresholds not specified explicitly by the user). More information on freshness checking can be found at: http://nagios.sourceforge.net/docs/3_0/freshness.html);
	$docs{'enable_flap_detection'} = q(Enable flap detection: This option determines whether or not Nagios will try to detect hosts and services that are 'flapping'. Flapping occurs when a host or service changes between states too frequently.  When Nagios detects that a host or service is flapping, it will temporarily suppress notifications for that host/service until it stops flapping.  Flap detection is very experimental, so read the HTML documentation before enabling this feature! Values: checked = enable flap detection. unchecked = disable flap detection (default).);
	$docs{'host_flap_detection_thresholds'} = q(Host flap detection thresholds: Read the Nagios HTML documentation on flap detection for an explanation of what this option does.  This option has no effect if flap detection is disabled.);
	$docs{'service_flap_detection_thresholds'} = q(Service flap detection thresholds: Read the Nagios HTML documentation on flap detection for an explanation of what this option does.  This option has no effect if flap detection is disabled.);
	$docs{'enable_predictive_host_dependency_checks'} = q(Enable predictive host dependency checks: This option determines whether or not Nagios will execute predictive checks of hosts that are being depended upon (as defined for host dependencies at http://nagios.sourceforge.net/docs/3_0/dependencychecks.html) for a particular host when it changes state. Predictive checks help ensure that the dependency logic is as accurate as possible. More information on how predictive checks work can be found at: http://nagios.sourceforge.net/docs/3_0/dependencychecks.html);
	$docs{'enable_predictive_service_dependency_checks'} = q(Enable predictive service dependency checks: This option determines whether or not Nagios will execute predictive checks of services that are being depended upon (as defined for service dependencies at http://nagios.sourceforge.net/docs/3_0/objectdefinitions.html#servicedependency) for a particular service when it changes state. Predictive checks help ensure that the dependency logic is as accurate as possible. More information on how predictive checks work can be found at: http://nagios.sourceforge.net/docs/3_0/dependencychecks.html);
	$docs{'soft_state_dependencies'} = q(Soft service dependencies: This option determines whether or not Nagios will use soft service state information when checking service dependencies. Normally Nagios will only use the latest hard service state when checking dependencies. If you want it to use the latest state (regardless of whether it's a soft or hard state type), enable this option.);
	$docs{'use_timezone'} = q(<p>Use timezone:  This option allows you to override the default timezone (e.g., America/Los_Angeles) that this instance of Nagios runs in. If this option is left blank (the usual setting), Nagios will use the system-configured timezone.</p><p class=append>
	NOTE: If you use this option to specify a custom timezone on a server where you will view Nagios CGI screens, you will also need to alter the Apache configuration directives for the CGIs to specify the timezone you want. For example:
	</p>
<pre class=help>
&amp;lt;Directory &quot;/usr/local/groundwork/nagios/sbin/&quot;&amp;gt;
SetEnv TZ &quot;US/Mountain&quot;
...
&amp;lt;/Directory&amp;gt;</pre>);
	$docs{'date_format'} = q(Date format: This option determines how short dates are displayed. US: MM-DD-YYYY HH:MM:SS, Euro DD-MM-YYYY HH:MM:SS, ISO8601 YYYY-MM-DD HH:MM:SS,Strict-ISO8601 YYYY-MM-DDTHH:MM:SS);
	$docs{'illegal_object_name_chars'} = q(Illegal object name chars: This option allows you to specify illegal characters that cannot be used in host names, service descriptions, or names of other object types.);
	$docs{'illegal_macro_output_chars'} = q(<p>Illegal macro output chars: This option allows you to specify illegal characters that are stripped from macros before being used in notifications, event handlers, etc.  This DOES NOT affect macros used in service or host check commands. The following macros are stripped of the characters you specify: <tt>$HOSTOUTPUT$</tt>, <tt>$HOSTPERFDATA$</tt>, <tt>$HOSTACKAUTHOR$</tt>, <tt>$HOSTACKCOMMENT$</tt>, <tt>$SERVICEOUTPUT$</tt>, <tt>$SERVICEPERFDATA$</tt>, <tt>$SERVICEACKAUTHOR$</tt>, and <tt>$SERVICEACKCOMMENT$</tt>.</p>);
	$docs{'admin_email'} = q(Admin email: The email address of the administrator of *this* machine (the one doing the monitoring).  Nagios never uses this value itself, but you can access this value by using the $ADMINEMAIL$ macro in your notification commands.);
	$docs{'admin_pager'} = q(Admin pager: The pager number/address for the administrator of *this* machine. Nagios never uses this value itself, but you can access this value by using the $ADMINPAGER$ macro in your notification commands.);
	# 2.0
	# FIX MINOR:  the object_cache_file_file directive is now obsolete
	$docs{'object_cache_file_file'} = q(Object cache file: This directive is used to specify a file in which a cached copy of object definitions should be stored. The cache file is (re)created every time Nagios is (re)started and is used by the CGIs. It is intended to speed up config file caching in the CGIs and allow you to edit the source object config files while Nagios is running without affecting the output displayed in the CGIs.);
	$docs{'execute_host_checks'} = q(Host check execution option: This option determines whether or not Nagios will execute on-demand and regularly scheduled host checks when it initially (re)starts. If this option is disabled, Nagios will not actively execute any host checks, although it can still accept passive host checks unless you've disabled them. This option is most often used when configuring backup monitoring servers, as described in the documentation on redundancy, or when setting up a distributed monitoring environment. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you'll have to use the appropriate external command or change it via the web interface. Checked = Execute host checks.);
	$docs{'accept_passive_host_checks'} = q(Passive host check acceptance option: This option determines whether or not Nagios will accept passive host checks when it initially (re)starts. If this option is disabled, Nagios will not accept any passive host checks. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you'll have to use the appropriate external command or change it via the web interface. Checked = Accept passive host checks.);
	$docs{'log_passive_checks'} = q(Passive check logging option: This variable determines whether or not Nagios will log passive host and service checks that it receives from the external command file. If you are setting up a distributed monitoring environment or plan on handling a large number of passive checks on a regular basis, you may wish to disable this option so your log file doesn't get too large. Checked = Log passive checks.);
	$docs{'service_inter_check_delay_method'} = q(Service inter-check delay method: This option allows you to control how service checks are initially 'spread out' in the event queue. Using a 'smart' delay calculation (the default) will cause Nagios to calculate an average check interval and spread initial checks of all services out over that interval, thereby helping to eliminate CPU load spikes. Using no delay is generally not recommended unless you are testing the service check parallelization functionality. Using no delay will cause all service checks to be scheduled for execution at the same time. This means that you will generally have large CPU spikes when the services are all executed in parallel. Values are as follows: None = Don't use any delay -- schedule all service checks to run immediately (i.e., at the same time!). Dumb = Use a delay of 1 second between service checks. Smart = Use a delay calculation to spread service checks out evenly. Enter a user-specificed delay of x.xx seconds.);
	$docs{'max_service_check_spread'} = q(Maximum service check spread: This option determines the maximum number of minutes from when Nagios starts that all services (that are scheduled to be regularly checked) are checked. This option will automatically adjust the service inter-check delay (if necessary) to ensure that the initial checks of all services occur within the timeframe you specify. In general, this option will not have an effect on service check scheduling if scheduling information is being retained using the use_retained_scheduling_info option.);
	$docs{'host_inter_check_delay_method'} = q(Host inter-check delay method: This option allows you to control how host checks that are scheduled to be checked on a regular basis are initially 'spread out' in the event queue. Using a 'smart' delay calculation (the default) will cause Nagios to calculate an average check interval and spread initial checks of all hosts out over that interval, thereby helping to eliminate CPU load spikes. Using no delay is generally not recommended. Using no delay will cause all host checks to be scheduled for execution at the same time. Values are as follows: None = Don't use any delay -- schedule all host checks to run immediately (i.e., at the same time!). Dumb = Use a 'dumb' delay of 1 second between host checks. Smart = Use a 'smart' delay calculation to spread host checks out evenly (default). Use a user-specified delay of x.xx seconds.);
	$docs{'max_host_check_spread'} = q(Maximum host check spread: This option determines the maximum number of minutes from when Nagios starts that all hosts (that are scheduled to be regularly checked) are checked. This option will automatically adjust the host inter-check delay (if necessary) to ensure that the initial checks of all hosts occur within the timeframe you specify. In general, this option will not have an effect on host check scheduling if scheduling information is being retained using the use_retained_scheduling_info option.);
	$docs{'auto_reschedule_checks'} = q(Auto-rescheduling option: This option determines whether or not Nagios will attempt to automatically reschedule active host and service checks to 'smooth' them out over time. This can help to balance the load on the monitoring server, as it will attempt to keep the time between consecutive checks consistent, at the expense of executing checks on a more rigid schedule. Checked = enabled. WARNING: THIS IS AN EXPERIMENTAL FEATURE AND MAY BE REMOVED IN FUTURE VERSIONS. ENABLING THIS OPTION CAN DEGRADE PERFORMANCE - RATHER THAN INCREASE IT - IF USED IMPROPERLY!);
	$docs{'auto_rescheduling_interval'} = q(Auto-rescheduling interval: This option determines how often (in seconds) Nagios will attempt to automatically reschedule checks. This option only has an effect if the auto_reschedule_checks option is enabled. WARNING: THIS IS AN EXPERIMENTAL FEATURE AND MAY BE REMOVED IN FUTURE VERSIONS. ENABLING THE AUTO-RESCHEDULING OPTION CAN DEGRADE PERFORMANCE - RATHER THAN INCREASE IT - IF USED IMPROPERLY!);
	$docs{'auto_rescheduling_window'} = q(Auto-rescheduling window: This option determines the 'window' of time (in seconds) that Nagios will look at when automatically rescheduling checks. Only host and service checks that occur in the next X seconds (determined by this variable) will be rescheduled. This option only has an effect if the auto_reschedule_checks option is enabled. WARNING: THIS IS AN EXPERIMENTAL FEATURE AND MAY BE REMOVED IN FUTURE VERSIONS. ENABLING THE AUTO-RESCHEDULING OPTION CAN DEGRADE PERFORMANCE - RATHER THAN INCREASE IT - IF USED IMPROPERLY!);
	$docs{'obsess_over_hosts'} = q(Obsess over hosts option: This value determines whether or not Nagios will 'obsess' over host check results and run the obsessive compulsive host processor command you define. I know -- funny name, but it was all I could think of. This option is useful for performing distributed monitoring. If you're not doing distributed monitoring, don't enable this option. Checked = enabled.);
	$docs{'ochp_command'} = q(Obsessive compulsive host processor command: This option allows you to specify a command to be run after every host check, which can be useful in distributed monitoring. This command is executed after any event handler or notification command. The command argument is the short name of a command definition that you define in your object configuration file. The maximum amount of time that this command can run is controlled by the ochp_timeout option. This command is only executed if the obsess_over_hosts option is enabled globally and if the obsess_over_host directive in the host definition is enabled.);
	$docs{'host_perfdata_command'} = q(Host performance data processing command: This option allows you to specify a command to be run after every host check to process host performance data that may be returned from the check. The command argument is the short name of a command definition that you define in your object configuration file. This command is only executed if the process_performance_data option is enabled globally and if the process_perf_data directive in the host definition is enabled.);
	$docs{'service_perfdata_command'} = q(Service performance data processing command: This option allows you to specify a command to be run after every service check to process service performance data that may be returned from the check. The command argument is the short name of a command definition that you define in your object configuration file. This command is only executed if the process_performance_data option is enabled globally and if the process_perf_data directive in the service definition is enabled.);
	$docs{'host_perfdata_file'} = q(Host performance data file: This option allows you to specify a file to which host performance data will be written after every host check. Data will be written to the performance file as specified by the host_perfdata_file_template option. Performance data is only written to this file if the process_performance_data option is enabled globally and if the process_perf_data directive in the host definition is enabled.);
	$docs{'service_perfdata_file'} = q(Service performance data file: This option allows you to specify a file to which service performance data will be written after every service check. Data will be written to the performance file as specified by the service_perfdata_file_template option. Performance data is only written to this file if the process_performance_data option is enabled globally and if the process_perf_data directive in the service definition is enabled.);
	$docs{'host_perfdata_file_template'} = q(Host performance data file template: This option determines what (and how) data is written to the host performance data file. The template may contain macros, special characters (\t for tab, \r for carriage return, \n for newline) and plain text. A newline is automatically added after each write to the performance data file.);
	$docs{'service_perfdata_file_template'} = q(Service performance data file template: This option determines what (and how) data is written to the service performance data file. The template may contain macros, special characters (\t for tab, \r for carriage return, \n for newline) and plain text. A newline is automatically added after each write to the performance data file.);
	$docs{'host_perfdata_file_mode'} = q(Host performance data file mode: This option determines whether the host performance data file is opened in write or append mode. Unless the file is a named pipe, you will probably want to use the default mode of append. a = Open file in append mode. w = Open file in write mode.);
	$docs{'service_perfdata_file_mode'} = q(Service performance data file mode: This option determines whether the service performance data file is opened in write or append mode. Unless the file is a named pipe, you will probably want to use the default mode of append. a = Open file in append mode. w = Open file in write mode.);
	$docs{'host_perfdata_file_processing_interval'} = q(Host performance data file processing interval: This option allows you to specify the interval (in seconds) at which the host performance data file is processed using the host performance data file processing command. A value of 0 indicates that the performance data file should not be processed at regular intervals.);
	$docs{'service_perfdata_file_processing_interval'} = q(Service performance data file processing interval: This option allows you to specify the interval (in seconds) at which the service performance data file is processed using the service performance data file processing command. A value of 0 indicates that the performance data file should not be processed at regular intervals.);
	$docs{'host_perfdata_file_processing_command'} = q(Host performance data file processing command: This option allows you to specify the command that should be executed to process the host performance data file. The command argument is the short name of a command definition that you define in your object configuration file. The interval at which this command is executed is determined by the host_perfdata_file_processing_interval directive.);
	$docs{'service_perfdata_file_processing_command'} = q(Service performance data file processing command: This option allows you to specify the command that should be executed to process the service performance data file. The command argument is the short name of a command definition that you define in your object configuration file. The interval at which this command is executed is determined by the service_perfdata_file_processing_interval directive.);
	$docs{'check_host_freshness'} = q(Host freshness checking option: This option determines whether or not Nagios will periodically check the 'freshness' of host checks. Enabling this option is useful for helping to ensure that passive host checks are received in a timely manner. Checked = enabled.);
	$docs{'host_freshness_check_interval'} = q(Host freshness check interval: This setting determines how often (in seconds) Nagios will periodically check the 'freshness' of host check results. If you have disabled host freshness checking (with the check_host_freshness option), this option has no effect.);
	$docs{'event_broker_options'} = q(This option controls what (if any) data gets sent to the event broker and, in turn, to any loaded event broker modules. This is an advanced option. When in doubt, either broker nothing (if not using event broker modules) or broker everything (if using event broker modules). Possible values are 0 (broker nothing), -1 (broker everything), and particular numeric bitmasks (see BROKER_* definitions in the source code [include/broker.h] for other values that can be ORed together).);
	$docs{'broker_module'} = q(This directive is used to specify an event broker module that should by loaded by Nagios at startup. Currently, GroundWork only supports one such event broker module. Arguments that should be passed to the module at startup are separated from the module path by a space.);
	$docs{'debug_level'} = q(<p>Debug level: This option determines what type of information Nagios should write to the debug_file. This value is a logical OR of the values below.</p>
	<p class=append>
	<ul>
	<li>-1 = Log everything
        <li>0 = Log nothing (default)
	<li>1 = Function enter/exit information
	<li>2 = Config information
	<li>4 = Process information
	<li>8 = Scheduled event information
	<li>16 = Host/service check information
	<li>32 = Notification information
	<li>64 = Event broker information
	<li>128 = External commands
	<li>256 = Commands
	<li>512 = Downtime
	<li>1024 = Comments
	<li>2048 = Macro processing
	<li>4096 = IPC (polling, in Nagios 4)
	<li>8192 = Scheduling (in Nagios 4)
	</ul>
	</p>
	<p class=append>NOTICE:  Debug logging imposes a heavy performance penalty on the system, creating a very high load on the disk.  You should only log as much as you need to in order to debug a particular problem, and only keep the logging in place until the problem is resolved.</p>);
	$docs{'debug_verbosity'} = q(<p>Debug verbosity: This option determines how much debugging information Nagios should write to the debug file.</p>
	<p class=append>NOTICE:  Debug logging imposes a heavy performance penalty on the system, creating a very high load on the disk.  You should only log as much as you need to in order to debug a particular problem, and only keep the logging in place until the problem is resolved.</p>);
	$docs{'debug_file'} = q(Debug file: This option determines where Nagios should write debugging information. What (if any) information is written is determined by the debug level and debug verbosity options. You can have Nagios automatically rotate the debug file when it reaches a certain size by using the max debug file size option.);
	$docs{'max_debug_file_size'} = q(Max debug file size: This option determines the maximum size (in bytes) of the debug file. If the file grows larger than this size, it will be renamed with a .old extension. If a file already exists with a .old extension, it will automatically be deleted. This helps ensure that your disk space usage doesn't get out of control when debugging Nagios. Leaving this option empty will invoke a default value of 1000000; setting this option to 0 will disable automatic debug file rotation.);
	$docs{'use_regexp_matching'} = q(Regular expression matching option: This option determines whether or not various directives in your object definitions will be processed as regular expressions. Checked = Use regular expression matching.);
	$docs{'use_true_regexp_matching'} = q(True regular expression matching option: If you've enabled regular expression matching of various object directives using the use_regexp_matching option, this option will determine when object directives are treated as regular expressions. If this option is disabled (the default), directives will only be treated as regular expressions if the contain a * or ? wildcard character. If this option is enabled, all appropriate directives will be treated as regular expression -- be careful when enabling this! Checked = Use true regular expression matching.);
	$docs{'misc_directives'} = q(Add name = value pairs to be included in the nagios.cfg file.);
	# 3.x (selected options -- may add more later)
	$docs{'precached_object_file'} = q(Precached object file option: This directive is used to specify a file in which a pre-processed, pre-cached copy of object definitions should be stored. This file can be used to drastically improve startup times in large/complex Nagios installations.);
	$docs{'external_command_buffer_slots'} = q(External command buffer slots option: Note: This is an advanced feature. This option determines how many buffer slots Nagios will reserve for caching external commands that have been read from the external command file by a worker thread, but have not yet been processed by the main thread of the Nagios deamon. Each slot can hold one external command, so this option essentially determines how many commands can be buffered. For installations where you process a large number of passive checks (e.g. distributed setups), you may need to increase this number. You should consider using MRTG to graph Nagios' usage of external command buffers.);
	$docs{'check_result_reaper_frequency'} = q(Check result reaper frequency option: This option allows you to control the frequency (in seconds) of check result 'reaper' events. 'Reaper' events process the results from host and service checks that have finished executing. These events consitute the core of the monitoring logic in Nagios.);
	$docs{'max_check_result_reaper_time'} = q(Max check result reaper time option: This option allows you to control the maximum amount of time (in seconds) that host and service check result 'reaper' events are allowed to run. 'Reaper' events process the results from host and service checks that have finished executing. If there are a lot of results to process, reaper events may take a long time to finish, which might delay timely execution of new host and service checks. This variable allows you to limit the amount of time that an individual reaper event will run before it hands control back over to Nagios for other portions of the monitoring logic.);
	$docs{'check_result_path'} = q(Check result path option: This option determines which directory Nagios will use to temporarily store host and service check results before they are processed. This directory should not be used to store any other files, as Nagios will periodically clean this directory of old file (see the max_check_result_file_age option for more information).);
	$docs{'max_check_result_file_age'} = q(Max check result file age option: This option determines the maximum age in seconds that Nagios will consider check result files found in the check_result_path directory to be valid. Check result files that are older that this threshold will be deleted by Nagios and the check results they contain will not be processed. By using a value of zero (0) with this option, Nagios will process all check result files -- even if they're older than your hardware :-\).);
	$docs{'translate_passive_host_checks'} = q(Translate passive host checks option: This option determines whether or not Nagios will translate DOWN/UNREACHABLE passive host check results to their 'correct' state from the viewpoint of the local Nagios instance. This can be very useful in distributed and failover monitoring installations.);
	$docs{'passive_host_checks_are_soft'} = q(Passive host checks are soft option: This option determines whether or not Nagios will treat passive host checks as HARD states or SOFT states. By default, a passive host check result will put a host into a HARD state type. You can change this behavior by enabling this option. This can be very useful when certain types of host-check probing (such as fping) are in play, so the usual retry intervals still apply to these host checks before HARD states are recognized.);
	$docs{'cached_host_check_horizon'} = q(Cached host check horizon option: This option determines the maximum amount of time (in seconds) that the state of a previous host check is considered current. Cached host states (from host checks that were performed more recently than the time specified by this value) can improve host check performance immensely. Too high of a value for this option may result in (temporarily) inaccurate host states, while a low value may result in a performance hit for host checks. Use a value of 0 if you want to disable host check caching.);
	$docs{'cached_service_check_horizon'} = q(Cached service check horizon option: This option determines the maximum amount of time (in seconds) that the state of a previous service check is considered current. Cached service states (from service checks that were performed more recently than the time specified by this value) can improve service check performance when a lot of service dependencies are used. Too high of a value for this option may result in inaccuracies in the service dependency logic. Use a value of 0 if you want to disable service check caching.);
	$docs{'large_installation_tweaks'} = q(The large installation tweaks option is documented in the Nagios manual only insofar as it modifies the default values of the additional three options shown here. But those options are always set explicitly here, so such defaulting should have no effect. You need to set those other options exactly how you want them to be, and not depend on any defaulted behavior. However, the large installation tweaks option also affects the flapping detection logic and the use of precached objects, so the value you set here still matters.);
	$docs{'use_large_installation_tweaks'} = q(Use large installation tweaks option: This option determines whether or not the Nagios daemon will take several shortcuts to improve performance. These shortcuts result in the loss of a few features, but larger installations will likely see a lot of benefit from doing so.);
	$docs{'enable_environment_macros'} = q(Enable environment macros option: This option determines whether or not the Nagios daemon will make all standard macros available as environment variables to your check, notification, event hander, etc. commands. In large Nagios installations this can be problematic because it takes additional memory and (more importantly) CPU to compute the values of all macros and make them available to the environment.);
	$docs{'child_processes_fork_twice'} = q(Child processes fork twice option: This option determines whether or not Nagios will fork() child processes twice when it executes host and service checks. By default, Nagios fork()s twice. However, if the use_large_installation_tweaks option is enabled, it will only fork() once. By defining this option in your configuration file (as it will always be, in the GroundWork-generated Nagios configuration files), you are able to override things to get the behavior you want.);
	$docs{'free_child_process_memory'} = q(Free child process memory option: This option determines whether or not Nagios will free memory in child processes when they are fork()ed off from the main process. By default, Nagios frees memory. However, if the use_large_installation_tweaks option is enabled, it will not. By defining this option in your configuration file (as it will always be, in the GroundWork-generated Nagios configuration files), you are able to override things to get the behavior you want.);

	return %docs;
}

sub cgi_cfg() {
	my %docs = ();
	$docs{'physical_html_path'} = q(Physical HTML path: This is the path where the HTML files for Nagios reside.  This value is used to locate the logo images needed by the statusmap and statuswrl CGIs.);
	$docs{'url_html_path'} = q(URL HTML path: This is the path portion of the URL that corresponds to the physical location of the Nagios HTML files (as defined above). This value is used by the CGIs to locate the online documentation and graphics.  If you access the Nagios pages with a URL like http://www.myhost.com/nagios, this value should be '/nagios' (without the quotes).);
	$docs{'show_context_help'} = q(Context sensitive help: This option determines whether or not a context-sensitive help icon will be displayed for most of the CGIs. Values: unchecked = disables context-sensitive help, checked = enables context-sensitive help.);
	$docs{'nagios_check_command'} = q(Nagios check command: This is the full path and filename of the program used to check the status of the Nagios process.  It is used only by the CGIs and is completely optional.  However, if you don't use it, you'll see warning messages in the CGIs about the Nagios process not running and you won't be able to execute any commands from the web interface.  The program should follow the same rules as plugins; the return codes are the same as for the plugins, it should have timeout protection, it should output something to STDIO, etc. (Note: If you are using the check_nagios plugin here, the first argument should be the physical path to the status log, the second argument is the number of minutes that the status log contents should be 'fresher' than, and the third argument is the string that should be matched from the output of the 'ps' command to locate the running Nagios process.  That process string is going to vary depending on how you start Nagios.  Run the 'ps' command manually to see what the command line entry for the Nagios process looks like.));
	$docs{'use_authentication'} = q(Use authentication: This option controls whether or not the CGIs will use any authentication when displaying host and service information, as well as committing commands to Nagios for processing. Read the HTML documentation to learn how the authorization works! (NOTE: It is a really *bad* idea to disable authorization, unless you plan on removing the command CGI (cmd.cgi)!)  Failure to do so will leave you wide open to kiddies messing with Nagios and possibly hitting you with a denial of service attack by filling up your drive by continuously writing to your command file! Setting this value to unchecked will cause the CGIs to *not* use authentication (bad idea), while checked will make them use the authentication functions (the default).);
	$docs{'default_user_name'} = q(Default user: Setting this variable will define a default user name that can access pages without authentication.  This allows people within a secure domain (i.e., behind a firewall) to see the current status without authenticating.  You may want to use this to avoid basic authentication if you are not using a secure server since basic authentication transmits passwords in the clear. Important:  Do not define a default username unless you are running a secure web server and are sure that everyone who has access to the CGIs has been authenticated in some manner!  If you define this variable, anyone who has not authenticated to the web server will inherit all rights you assign to this user!);

	$docs{'authorized_for_read_only'} = q(<p>Read-only access: This option is a comma-delimited list of usernames that have read-only rights in the CGIs. This will block any service or host commands normally shown on the extinfo CGI pages. It will also block comments from being shown to read-only users. You may use an asterisk (*) to authorize any user who has authenticated to the web server.</p><p class=append>This option is for privilege restriction, not for privilege granting.  It constrains access otherwise granted by the other options.  A user will need to be granted access via one of the other options to see objects in the first place.</p>);
	$docs{'authorized_contactgroup_for_read_only'} = q(<p>Contactgroup read-only access: This option is a comma-delimited list of contactgroup names whose associated contacts have read-only rights in the CGIs. This will block any service or host commands normally shown on the extinfo CGI pages. It will also block comments from being shown to read-only users.</p><p class=append>This option is for privilege restriction, not for privilege granting.  It constrains access otherwise granted by the other options.  A contact will need to be granted access via one of the other options to see objects in the first place.</p>);

	$docs{'authorized_for_configuration_information'} = q(Configuration information access: This option is a comma-separated list of all usernames that can view ALL configuration information (hosts, commands, etc). By default, users can only view configuration information for the hosts and services they are contacts for. You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_configuration_information'} = q(Contactgroup configuration information access: This option is a comma-separated list of contactgroup names whose associated contacts can view ALL configuration information (hosts, commands, etc). By default, users can only view configuration information for the hosts and services they are contacts for.);
	$docs{'authorized_for_system_information'} = q(System/process information access: This option is a comma-separated list of all usernames that have access to viewing the Nagios process information as provided by the Extended Information CGI (extinfo.cgi).  By default, *no one* has access to this unless you choose to not use authorization.  You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_system_information'} = q(Contactgroup system/process information access: This option is a comma-separated list of contactgroup names whose associated contacts have access to viewing the Nagios process information as provided by the Extended Information CGI (extinfo.cgi).  By default, *no one* has access to this unless you choose to not use authorization.);
	$docs{'authorized_for_system_commands'} = q(System/process command access: This option is a comma-separated list of all usernames that can issue shutdown and restart commands to Nagios via the command CGI (cmd.cgi).  Users in this list can also change the program mode to active or standby. By default, *no one* has access to this unless you choose to not use authorization. You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_system_commands'} = q(Contactgroup system/process command access: This option is a comma-separated list of contactgroup names whose associated contacts can issue shutdown and restart commands to Nagios via the command CGI (cmd.cgi).  These users can also change the program mode to active or standby. By default, *no one* has access to this unless you choose to not use authorization.);

	$docs{'authorized_for_all_hosts'} = q(Global host information access: This is a comma-separated list of names of authenticated users who can view status and configuration information for all hosts. Users in this list are also automatically authorized to view information for all services. Users in this list are not automatically authorized to issue commands for all hosts or services. If you want these users to be able to issue commands for all hosts and services as well, you must add them to the authorized_for_all_host_commands variable. You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_all_hosts'} = q(Contactgroup global host information access: This is a comma-separated list of contactgroup names whose associated contacts can view status and configuration information for all hosts. These users are also automatically authorized to view information for all services. These users are not automatically authorized to issue commands for all hosts or services. If you want these users to be able to issue commands for all hosts and services as well, you must add them to the authorized_contactgroup_for_all_host_commands variable.);
	$docs{'authorized_for_all_host_commands'} = q(Global host command access: This is a comma-separated list of names of authenticated users who can issue commands for all hosts via the command CGI. Users in this list are also automatically authorized to issue commands for all services. Users in this list are not automatically authorized to view status or configuration information for all hosts or services. If you want these users to be able to view status and configuration information for all hosts and services as well, you must add them to the authorized_for_all_hosts variable. You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_all_host_commands'} = q(Contactgroup global host command access: This is a comma-separated list of contactgroup names whose associated contacts can issue commands for all hosts via the command CGI. These users are also automatically authorized to issue commands for all services. These users are not automatically authorized to view status or configuration information for all hosts or services. If you want these users to be able to view status and configuration information for all hosts and services as well, you must add them to the authorized_contactgroup_for_all_hosts variable.);

	$docs{'authorized_for_all_services'} = q(Global service information access: This is a comma-separated list of names of authenticated users who can view status and configuration information for all services. Users in this list are not automatically authorized to view information for all hosts. Users in this list are not automatically authorized to issue commands for all services. If you want these users to be able to issue commands for all services as well, you must add them to the authorized_for_all_service_commands variable. You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_all_services'} = q(Contactgroup global service information access: This is a comma-separated list of contactgroup names whose associated contacts can view status and configuration information for all services. These users are not automatically authorized to view information for all hosts. These users are not automatically authorized to issue commands for all services. If you want these users to be able to issue commands for all services as well, you must add them to the authorized_contactgroup_for_all_service_commands variable.);
	$docs{'authorized_for_all_service_commands'} = q(Global service command access: This is a comma-separated list of names of authenticated users who can issue commands for all services via the command CGI. Users in this list are not automatically authorized to issue commands for all hosts. Users in this list are not automatically authorized to view status or configuration information for all hosts. If you want these users to be able to view status and configuration information for all services as well, you must add them to the authorized_for_all_services variable. You may use an asterisk (*) to authorize any user who has authenticated to the web server.);
	$docs{'authorized_contactgroup_for_all_service_commands'} = q(Contactgroup global service command access: This is a comma-separated list of contactgroup names whose associated contacts can issue commands for all services via the command CGI. These users are not automatically authorized to issue commands for all hosts. These users are not automatically authorized to view status or configuration information for all hosts. If you want these users to be able to view status and configuration information for all services as well, you must add them to the authorized_contactgroup_for_all_services variable.);

	$docs{'lock_author_names'} = q(Lock author names: This option allows you to restrict users from changing the author name when submitting comments, acknowledgements, and scheduled downtime from the web interface. If this option is enabled, users will be unable to change the author name associated with the command request.);
	$docs{'statusmap_background_image'} = q(Statusmap background image: This option allows you to specify an image to be used as a background in the statusmap CGI.  It is assumed that the image resides in the HTML images path (i.e., /usr/local/groundwork/nagios/share/images). This path is automatically determined by appending '/images' to the path specified by the 'physical_html_path' directive. Note:  The image file must be in GD2 format!);
	$docs{'default_statusmap_layout'} = q(Default statusmap layout: This option allows you to specify the default layout method the statusmap CGI should use for drawing hosts.  If you do not use this option, the default is to use user-defined coordinates.  Valid options are as follows: User-defined coordinates, Depth layers, Collapsed tree, Balanced tree, Circular, Circular (Marked Up).);
	$docs{'default_statuswrl_layout'} = q(Default statuswrl layout: This option allows you to specify the default layout method the statuswrl (VRML) CGI should use for drawing hosts.  If you do not use this option, the default is to use user-defined coordinates.  Valid options are as follows: User-defined coordinates, Collapsed tree, Balanced tree, Circular.);
	$docs{'statuswrl_include'} = q(Statuswrl include: This option allows you to include your own objects in the generated VRML world.  It is assumed that the file resides in the HTML path (i.e., /usr/local/groundwork/nagios/share).);
	$docs{'ping_syntax'} = q(Ping syntax: This option determines what syntax should be used when attempting to ping a host from the WAP interface (using the statuswml CGI).  You must include the full path to the ping binary, along with all required options.  The $HOSTADDRESS$ macro is substituted with the address of the host before the command is executed.);
	$docs{'refresh_rate'} = q(Refresh rate: This option allows you to specify the refresh rate in seconds of various CGIs (status, statusmap, extinfo, and outages).);
	$docs{'sound_options'} = q(Audio alerts: These options allow you to specify an optional audio file that should be played in your browser window when there are problems on the network.  The audio files are used only in the status CGI.  Only the sound for the most critical problem will be played.  Order of importance (higher to lower) is as follows: unreachable hosts, down hosts, critical services, warning services, and unknown services. If there are no visible problems, the sound file optionally specified by the 'normal_sound' variable will be played. Note: All audio files must be placed in the /media subdirectory under the HTML path (i.e., /usr/local/groundwork/nagios/share/media/ ).);
	$docs{'ddb'} = q(Database directives: These config directives are only used if you compiled Nagios with database support.);
	$docs{'result_limit'} = q(Result limit: This option allows you to specify the default number of items shown in certain CGI screens (hosts, and service detail).  (The Nagios CGIs do not always count correctly, so this is an approximation.)  You may set this to 0 to show all items by default.);
	$docs{'use_pending_states'} = q(Use pending states:  This option determines what states should be displayed in the web interface for hosts/services that have not yet been checked.  0 (unchecked) means leave hosts/services that have not been checked yet in their original state.  1 (checked) means mark hosts/services that have not been checked yet as PENDING.);
	$docs{'ack_no_sticky'} = q(Ack no sticky:  This option affects the default setting of a checkbox for acknowledgements in Nagios CGI screens.  Enabling ack_no_sticky will default &quot;Sticky&nbsp;Acknowledgement&quot; to be unchecked.);
	$docs{'ack_no_send'} = q(Ack no send:  This option affects the default setting of a checkbox for acknowledgements in Nagios CGI screens.  Enabling ack_no_send will default &quot;Send&nbsp;Notification&quot; to be unchecked.);
	$docs{'tac_cgi_hard_only'} = q(TAC CGI hard only:  This option controls whether only HARD states are counted in the Tactical Overview, or if both HARD and SOFT states are counted.  Set to 1 (checked) to show only HARD states. Defaults to 0 (unchecked), showing both HARD and SOFT states.);
	return %docs;
}

sub import_wizard() {
	my %docs = ();
	$docs{'step_1_title'} = q(Step 1: Upload File);
	$docs{'step_1'} = q(Select your text file and the field delimiter.);
	$docs{'step_2_title'} = q(Step 2: Set Schema);
	$docs{'step_2'} = q(Map file data to import fields. Name and address are required for successful import.);
	$docs{'step_3_title'} = q(Step 3: Process Hosts);
	$docs{'step_3'} = q(WARNING: SERIOUS HARM TO THE DATABASE CAN RESULT IF THE DATA BELOW HAS ERRORS (COMMAS IN HOST NAMES, FOR EXAMPLE). USE THE BACK BUTTON TO CHANGE THE DELIMITER IF NECESSARY.<br><br>The results of your import appear in the first of the larger boxes below. You may select the hosts by clicking the left checkbox. Some of the hosts may be highlighted, so note the color coded key. Any host marked 'exception' will be removed from the list and ignored should you attempt to add it. Any host marked exists will be updated should you attempt to add it. Click columns and keys to sort.);

	return %docs;
}

sub discover_wizard() {
	my %docs = ();
	$docs{'step_1_title'} = q(Step 1: Scan Parameters);
	$docs{'step_1'} = q(WARNING: THIS FEATURE DOES A LIMITED Nmap PORT SCAN TO GUESS THE OPERATING SYSTEM.<br><br>The range of ports can be found in /usr/local/groundwork/core/monarch/bin/nmap_scan_one.pl. Nmap also does a reverse DNS lookup to resolve host names from their addresses. This requires that DNS is properly configured.<br><br>To continue, enter a single IP address to discover one host or enter a range to scan part of a subnet. To sweep an entire subnet, set the fourth octet to *.);
	$docs{'step_2_title'} = q(Step 2: Scanning ...);
	$docs{'step_2'} = q(Wait for scan to finish before moving to the next step.);
	$docs{'step_3_title'} = q(Step 3: Process Hosts);
	$docs{'step_3'} = q(The results of your scan appear in the first of the larger boxes below. You may select the hosts by clicking the left checkbox. Some of the hosts may be highlighted, so note the color coded key. Any host marked 'exception' will be removed from the list and ignored should you attempt to add it. Any host marked exists will be updated should you attempt to add it. Click columns and keys to sort.);

	return %docs;
}

sub profile_importer() {
	my %docs = ();
	$docs{'profile_uploader'} = q(Upload a file from your desktop. Profile files can be generated from the Export button found on the main Host Profile page or the main Service Profile page. The uploaded file must have a <tt>".xml"</tt> filename extension. Choose "Overwrite existing file" if you wish to replace a file of the same name in the import folder.);
	$docs{'profile_importer'} = q(Select from the list of files found in the folder indicated below. Choose 'Overwrite existing objects' if you wish to replace all matching time periods, commands, templates, services, and profiles. You may also select and remove files from the folder.);
	$docs{'profile_delete'} = q(The following files will be deleted if you choose to proceed.  This affects only the profile files in the filesystem; objects already in the database from profiles which have previously been imported will be left untouched.);
	$docs{'upload_folder'} = q(This is the server directory where the uploaded profile file will reside.);
	$docs{'import_folder'} = q(This is the server directory where the profile file(s) displayed here reside.);
	$docs{'overwrite_file'} = q(Normally, an existing file in the Upload folder will be left as-is if you try to upload a file of the same name, to prevent accidental data destruction.  If you need to overwrite an existing file, you must check this box before running the upload.);
	$docs{'overwrite_objects'} = q(Normally, existing objects and sub-objects also defined in your imported profile(s) will be left as-is in the database.  There is a tradeoff here.  This default action preserves the integrity of existing setup that uses these objects, but it also means that some parts of your newly imported objects will use existing definitions instead of any different definitions in the profile file(s) being imported.  If you need to overwrite ALL the old definitions of such objects, you must check this box before running the import.  BE CAREFUL with this option, as it applies to ALL objects in the imported profile file(s).);
	return %docs;
}

sub import_nagios_config() {
	my %docs = ();
	# FIX LATER:  edit the list of kept object types
	$docs{'purge_all_and_import_3x'} = q(<p class=append><b><i>This operation will delete data.</i></b>  Importing from a Nagios pre-cached objects file will purge almost all of your existing configuration.  Most object types will be lost; only a few will be kept.</p>
<p class=append>
<table class="a_b_comparison" align="center">
<tr>
<th class="col_a">Lost Object Types</th>
<th class="col_b">Kept Object Types</th>
</tr>
<tr><td class="col_a">commands</td><td class="col_b">???</td></tr>
<tr><td class="col_a">contacts</td><td class="col_b">???</td></tr>
<tr><td class="col_a">contact groups</td><td class="col_b">???</td></tr>
<tr><td class="col_a">hosts</td><td class="col_b">???</td></tr>
<tr><td class="col_a">host dependencies</td><td class="col_b">???</td></tr>
<tr><td class="col_a">host escalations</td><td class="col_b">???</td></tr>
<tr><td class="col_a">host groups</td><td class="col_b">???</td></tr>
<tr><td class="col_a">services</td><td class="col_b">???</td></tr>
<tr><td class="col_a">service dependencies</td><td class="col_b">???</td></tr>
<tr><td class="col_a">service escalations</td><td class="col_b">???</td></tr>
<tr><td class="col_a">service groups</td><td class="col_b">???</td></tr>
<tr><td class="col_a">time periods</td><td class="col_b">???</td></tr>
</table>
</p>
	<p class=append>We recommend use of this operation only during initialization of a fresh system (say, when adopting GroundWork to replace a bare Nagios 3 installation).</p><p class=append>Are you sure you want to continue?</p>);
	return %docs;
}

1;
