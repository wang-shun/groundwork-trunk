# MonArch - Groundwork Monitor Architect
# MonarchInstrument.pm
#
############################################################################
# Release 3.1
# September 2009
############################################################################
#
# Original author: Carlos McEvilly
#
# Copyright 2008, 2009 GroundWork Open Source, Inc. (GroundWork)
# All rights reserved. This program is free software; you can redistribute
# it and/or modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

use strict;

package Instrument;

my $debug = 0;

=pod

=head1 SYNOPSIS

MonarchInstrument can be used to add comments to HTML or other output
showing the context in which the HTML was generated. This is useful
for understanding how a particular page or other output was generated.

Once the show_trace_as_<language>_comment() calls are inserted into
code as shown below, the output can be turned off at any time by
editing MonarchInstrument.pm and setting the value of $debug to 0.

=over 4

 use MonarchInstrument;

 my $html;
 $html = qq{<html>
    @{[&$Instrument::show_trace_as_html_comment()]}
    <body>\n<p>some content</p>\n</body>\n</html>};

=back

-or-

=over 4

 $html  = "<html>\n";
 $html .= &$Instrument::show_trace_as_html_comment();
 $html .= "<body>\n<p>some content</p>\n</body>\n</html>\n";

=back

The above examples will emit HTML like the following:

=over 4

 <html>
 <!--generated by Go::go() called from /www/cgi-bin/file.cgi line 55-->
 <body>
 <p>some content</p>
 </body>
 </html>

=back

Full list of available subroutines:

=over 4

 show_trace_as_text();
 show_trace_as_html();
 show_trace_as_html_comment();
 show_trace_as_shell_comment();
 show_trace_as_batch_comment();
 show_trace_as_javascript_comment();

=back

=cut

our $show_trace_as_text               = create_trace_reporter( $debug, "text" );
our $show_trace_as_html               = create_trace_reporter( $debug, "html" );
our $show_trace_as_html_comment       = create_trace_reporter( $debug, "html_comment" );
our $show_trace_as_shell_comment      = create_trace_reporter( $debug, "shell" );
our $show_trace_as_batch_comment      = create_trace_reporter( $debug, "batch" );
our $show_trace_as_javascript_comment = create_trace_reporter( $debug, "javascript" );

sub create_trace_reporter {
    my $debug = shift;
    my $lang = shift || 'html_comment';

    my %template_by_lang = (
	'html'         => "\n<span class=\"monarch_instrument_trace\">TRACE</span>\n",
	'html_comment' => "\n<!--TRACE-->\n",
	'javascript'   => "\n// TRACE\n",
	'text'         => "TRACE\n",
	'shell'        => "# TRACE\n",
	'batch'        => "rem TRACE\n",
    );
    my $template = $template_by_lang{ lc($lang) };

    # return a closure so we can call this by $show_trace_<language> from inside qq() blocks
    return sub {
	return '' unless ( $debug && defined($template) );
	my ( $package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask ) = caller(1);

	#$filename =~ s{.*/}{};
	my $trace  = "generated by $subroutine() called from $filename line $line ";
	my $output = $template;
	$output =~ s{TRACE}{$trace};
	return $output;
    };

}

1;

