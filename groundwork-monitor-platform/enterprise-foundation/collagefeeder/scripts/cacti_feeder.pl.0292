#!/usr/local/groundwork/perl/bin/perl
# Cacti feeder - integrates Cacti with GroundWork 
#
# Copyright 2014 GroundWork OpenSource
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# Revision History
#       Dominic Nicholas 4/14 -  v 0.2.0 - Initial Version
#       Dominic Nicholas 4/14 -  v 0.2.1 - Various JIRA's - see check-in comments for this version
#       Dominic Nicholas 5/14 -  v 0.2.3 - Various JIRA's - see check-in comments for this version
#       Dominic Nicholas 5/14 -  v 0.2.4 - Fixed issue with filter_out_non_state_changed_cacti_hosts_and_services() where
#                                          on state-change-only cycles, events weren't geting filtered correctly.
#       Dominic Nicholas 5/14 -  v 0.2.5 - Minor cleanup and Feeder.pm version increase
#       Dominic Nicholas 5/14 -  v 0.2.6 - version bump for fix to Feeder.pm
#       Dominic Nicholas 5/14 -  v 0.2.7 - some comment cleanup, and version bump for Feeder.pm minor fix
#       Dominic Nicholas 5/14 -  v 0.2.8 - support and minor refactoring for standalone mysql cacti instance put in place
#       Dominic Nicholas 5/14 -  v 0.2.9 - Minor fix to post_events_and_notifications so that status graphs stay in sync with host status
#       Dominic Nicholas 7/21 -  v 0.2.9.1 - fixed remove_cacti_objects_from_foundation error logging about no hosts.
#       Dominic Nicholas 10/15 -  v 0.2.9.2 - lowercasing of hostnames
#
# KNOWN ISSUES/QUESTIONS
# - if feeder adds a hostgroup, then eventually that hostgroup has no services created by this feeder, should that hg be removed ?
#     - eg: default_hostgroups has cactigroup and nagiosgroup entries, where nagiosgroup is an hg created by NAGIOS
#           Feeder detects a threshold on host localhost and adds it to localhost host in GW, and creates cactigroup
#           Later, feeder detects threshold was removed. Then deletes it from localhost in GW. cactigroup remains. 
# - Feeder.pm : If a host or service in Foundation has a ':' (colon) in it, audit trail will probably fail - see 'TBD API FIX' 
#
# TBD
# - As with any software, there is always a lot TBD. That complete list is not documented here yet.
# - fig out how to send -v output to screen not log
# - documentation of this feeder and Feeder.pm, including tests file format and examples
# - more validation of expected data structure/properties throughout
# - emulate find cacti graphs 

use 5.0;
use warnings;
use strict;

use version; 
my $VERSION = qv('0.2.9.2'); 
use GW::RAPID "0.5.3";
use JSON;
use Data::Dumper; $Data::Dumper::Indent = 2; $Data::Dumper::Sortkeys = 1;
use Log::Log4perl qw(get_logger);
use Getopt::Long;
use Time::HiRes;
use POSIX qw(strftime);
use Time::Local;
use Sys::Hostname;
use TypedConfig qw(); # leave qw() on to address minor bug in TypedConfig.pm
use DBI;
use GW::Feeder "0.2.7";
use File::Basename;

my $feeder_name = "cacti_feeder"; # Feeder name var - will key various things off this
my $config_file = '/usr/local/groundwork/config/cacti_feeder.conf'; # Config file for this feeder
Log::Log4perl::init('/usr/local/groundwork/config/cacti_feeder.log4perl.conf'); # log4perl configuraiton file initialization
my $logger = get_logger("GW.$feeder_name"); # logger object
my ( $dbh_cacti, $feeder, $tests_config ) = undef; # Various globals
my ( $help, $show_version, $once) = undef; # CLI option vars

# check for other cacti feeders running - there can only be one :)
$logger->logexit("Another $feeder_name is running - quitting") if ( perl_script_process_count( basename($0) ) > 1 ) ;

# supported versions of cacti
my %supported_cacti_versions = ( '0.8.7g' => undef, '0.8.8b' => undef );

# =================================================================================
main();
# =================================================================================

# ---------------------------------------------------------------------------------
sub main
{
    # main sub that does initialiation, processing loop etc
    
    my ( $start_time, $cycle_count, $total_cycle_time_taken, $events_retrieved, $events_sent, $retrieve_time, $send_time ) ; 
    my ( $total_events, $total_events_processed );
    my $started_at = localtime;

    # read and process cli opts
    initialize_options(); 

    # log app start
    $logger->info("INFO  ======== $feeder_name started at $started_at =======");

    # Set options up for new feeder
    my %feeder_options = (

        # The log4perl logger
        logger => $logger, 

        # Feeder specific options to retrieve and type-check.
        # Access standard or specific properties with $feeder->{properties}->{propertname}, eg $feeder->{properties}->{cycle_time}
        feeder_specific_properties => { 
                                        always_send_full_updates => 'boolean',
                                        cacti_system_indicator_file => 'scalar',
                                        cacti_system_indicator_check_frequency => 'number',
                                        cacti_system_test_tweaks_file => 'scalar',
                                        cactidbhost => 'scalar',
                                        cactidbtype => 'scalar',
                                        cactidbname => 'scalar',
                                        cactidbpass => 'scalar',
                                        cactidbport => 'number',
                                        cactidbuser => 'scalar',
                                        constrain_to_hostgroups => 'hash',
                                        check_bl_fail_count    => 'boolean',
                                        check_thold_fail_count => 'boolean',
                                        default_hostgroups => 'hash',
                                        full_update_frequency => 'number',
                                        host_bundle_size => 'number',
                                        hostgroup_bundle_size => 'number',
                                        service_bundle_size => 'number',
                                      }

    );

    # Create a new feeder object
    $feeder = GW::Feeder->new( $feeder_name, $config_file, \%feeder_options ) ;

    # Bail out if the feeder failed to instantiate.  But don't bail too fast, as we'll
    # likely just be restarted right away and encounter the exact same problem again.
    if (not $feeder) {
        $logger->fatal("ERROR Couldn't create feeder object - will sleep and then quit");
        sleep 60;
        exit (1);
    }

    # Wait for a license to be installed before doing anything else
    while ( not $feeder->license_installed() ) { 
        $logger->fatal( "FATAL Waiting a few minutes for a license to be installed" );
        sleep 120;
    }

    # validate of feeder-specific options  
    validate_feeder_specific_options(); # this doesn't do much yet 

    # set up interrupt handlers
    $feeder->initialize_interrupt_handlers();

    # Initialize a feeder hostgroup, virtual feeder host , feeder health service, and any other feeder specific services as defined in <feeder_services> conf hash
    if ( not $feeder->initialize_health_objects( $started_at ) ) { 
        $logger->error("ERROR initializing feeder health objects");
        # TBD completely bail or continue ?
    }
        
    # Bail out if processing is disabled
    if ( not $feeder->{enable_processing} ) {
        $feeder->terminate_feeder("ERROR The feeder is currently disabled. To enable it, set enable_processing to yes. Sleeping forever.", -1); 
    }

    # Establish a connection to the Cacti database
    initialize_cacti_database_connection();  

    # Process Cacti states in a never ending cycle
    $cycle_count = 1;
    CYCLE: while ( 1 )
    {
        # Wait until there's instruction from the cacti system to proceed.
        # For now, that just means wait for a file to show up in the filesystem.
        while ( not check_cacti_system_indicator() ) { 
            $logger->info("Waiting for $feeder->{cacti_system_indicator_check_frequency} seconds before checking for something to do...");
            sleep $feeder->{cacti_system_indicator_check_frequency};
        }
        
        $start_time = Time::HiRes::time() ; 
        $logger->info( "INFO  -------- Starting cycle $cycle_count --------" ); 

        # Try to read tests file each cycle so can test dynamically
        read_cacti_system_test_tweaks_file();

        # Do a quick cacti db connection test and if connected go process Cacti things
        if ( cacti_db_connection_ok() ) {
            process_cacti( $cycle_count, \$total_events, \$total_events_processed );
        }
        else {
            # Try to reinitialize the cacti db connection and wait for next cycle
            # This case is a bit tricky to test - better than nothing for now TBD improve.
            # report_feeder_error may fail but worth a try.
            $feeder->report_feeder_error( "DATABASE ERROR - Cacti database connection not ok - attempting to re-initializing it.") ;  
            if ( not initialize_cacti_database_connection() ) {
                $feeder->report_feeder_error("DATABASE ERROR Failed to initialize database connection - nothing will be processed. Sleeping 30 seconds before continuing." ); 
                sleep 30;
                # Don't increment cycle count since nothing was really processed, and don't want to skip it based on full_update_frequency mechanism
                next CYCLE;
            }
        }

        # converts audit into events in foundation, and empties it
        $feeder->flush_audit() ;  # this will produce its own errors if necessary

        # Update feeder stats services
        $total_cycle_time_taken = sprintf "%0.2f", Time::HiRes::time() - $start_time ;
        update_feeder_stats( $cycle_count, $total_cycle_time_taken, $total_events, $total_events_processed );  

        if ( $once ) {
            $logger->info( "INFO  Run-once option supplied - exiting" );
            $feeder->terminate_feeder("Feeder shut down", undef, 'OK'); # want to update feeder health host/service in a friendly way
        };

        # Reset the indicator from the cacti system that this feeder has done processing stuff.
        # if the reset fails, then the feeder will be stuck in a processing loop which means noogies 
        reset_cacti_system_indicator();


        $cycle_count++;

    }

}

# ----------------------------------------------------------------------------------------------------------------
sub process_cacti
{
    # This routine processes 'cacti events'. Everything hinges around the main sql statement below. This gets
    # a set of data for cacti hosts and their interfaces with thresholds applied. Each row of data is turned into
    # an 'event' . This is not the same as a GroundWork event, but just a collection of data that might mean Foundation
    # needs updating in some way to reflect the state of Cacti hosts/interfaces.
    # An event starts of with a bunch of properties, such as HostId, Host, Device, ServiceDescription, CactiServiceState etc
    # Some of these properties have some resemblance to those used in various REST API methods.
    # These data are needed for adding the cacti host, adding it to a hostgroup, and adding its interface as a GW service etc
    # As the event gets processed, other properties might be addded to it eg FoundationServiceState,
    # or, the original complete set of events might get filtered down possibly more than once depending on conf options, etc

    # Arguments:
    # - cycle iteration from main loop in main() and used in update frequency mechanism 
    # - ref to a total available # of events that could have been processed as returned from the big query
    # - ref to a total available # of events that were actually processed 
    # Returns 1 on success, 0 otherwise

    my ( $cycle_iteration, $ref_total_events, $ref_total_events_processed ) = @_;
    my ( $sql, $sth, $row, $now, $host_name, 
         $thold_alarm, $bl_alarm, $service_state, $message, $lastread_value, 
         %cacti_event, @cacti_events, %hosts_states, $cacti_version,
       );

    # Check that the cacti system meets requirements
    if ( not cacti_system_requirements_met( \$cacti_version ) ) {        
        $feeder->report_feeder_error("ERROR Some Cacti system requirements were not met - no processing will be done.");
        return;
    }

    # Get the cacti query appropriate for the version of cacti in use
    if ( not generate_cacti_query( \$sql, $cacti_version ) ) { 
        $feeder->report_feeder_error("ERROR Could not set the main Cacti query - no processing will be done.");
        return;
    }

    $logger->debug("DEBUG process_cacti() : SQL = '$sql'" );
    $sth = $dbh_cacti->prepare($sql);

    $logger->trace("TRACE running cacti sql query against cacti database ...");
    $sth->execute() or do { $feeder->report_feeder_error( "SQL ERROR failed to execute sql '$sql' : $@" ); return; };

    # This loop builds an array of cacti event objects. This original complete set can then get reduced further by following operations.
    ${$ref_total_events} = 0;
    while ( $row = $sth->fetchrow_hashref() )  {

        # Get time in format consumable by Foundation REST API later on
        $now = get_current_time();

        # Get the hostname for a given host id
        $host_name = get_cacti_hostname( $row->{host_id} ); 
	$host_name = lc $host_name; # 0.2.9.2

        # If you delete hosts from within the cacti interface, you can end up with a row here that has no host name
        # possibly due to a problem with cacti or with the query above. Regardless of cause for now just log it and move on. TBD research and fix this.
        if ( not $host_name ) { $feeder->report_feeder_error("CACTI ERROR - A cacti host without name was selected in process_cacti() - skipping it"); next; }

        $thold_alarm = ( $row->{thold_enabled} eq 'on' ) && $row->{thold_alert} && ((! $feeder->{check_thold_fail_count} ) || ( $row->{thold_fail_count} >= $row->{thold_fail_trigger}) );
        
        # Depending on which version of cacti is in use, bl_enabled column may or may not exist
        if ( $cacti_version eq '0.8.7g' ) {
            $bl_alarm    = ( $row->{bl_enabled}    eq 'on' ) && $row->   {bl_alert} && ((! $feeder->{check_bl_fail_count}    ) || ( $row->   {bl_fail_count} >= $row->   {bl_fail_trigger}) );
        } 
        elsif ( $cacti_version eq '0.8.8b' ) {
            $bl_alarm = 0; # baseline alarm mechanism different in 0.8.8b
        }
        else {
            $feeder->report_feeder_error("ERROR Unrecognized version of cacti $cacti_version - skipping cacti event"); 
            next;
        }

        # NOTE if change the possible service_state values here, change them in Feeder.pm->new() too
        if ( $thold_alarm || $bl_alarm ) {
            # Note from original cacti feeder - not sure if note about ScheduledDowntimeDepth is still applicable.
            # if ScheduledDowntimeDepth = 0, then Foundation translates CRITICAL to UNSCHEDULED CRITICAL.
            # In cacti there's currently no notion of scheduled downtime so use UNSCHEDULED CRITICAL, and ScheduledDowntimeDepth = 0
            $service_state = 'UNSCHEDULED CRITICAL';
        }
        else {
            $service_state = 'OK';
        }

        $message = 'Thresholds currently disabled'; # this message will become the service status message

        # Get the last value of the interface name
        if ( $row->{lastread} ) { 
            $lastread_value = $row->{lastread}; }
        else { 
            $lastread_value='n/a'; 
        }

        if ( $row->{thold_enabled} eq 'on' ) {
            $message = "Threshold status is $service_state, value=$lastread_value THOLD_HI=$row->{thold_hi} THOLD_LOW=$row->{thold_low}";
        }

      # if ( $row->{bl_enabled} eq 'on' ) {
      #     $message = "Baseline status is $service_state, value=$lastread_value BASELINE_UP=$row->{bl_pct_up} BASELINE_DOWN=$row->{bl_pct_down}";
      # }

        # Gather together all data needed for adding the cacti host, adding it to a hostgroup, and adding its interface as a service
        $cacti_event{HostId}                        = $row->{host_id};               # the cacti system host id
        $cacti_event{Host}                          = $host_name;                    # set earlier, and is the cacti system hostname 
        $cacti_event{Device}                        = $host_name;                    # device will be set to hostname
        $cacti_event{ServiceDescription}            = $row->{name};                  # service name will be the interface name
        $cacti_event{CactiServiceState}             = $service_state;                # cacti service state, translated into GW state
        $cacti_event{LastPluginOutput}              = $message;                      # service status message
        $cacti_event{HostGroup}                     = $feeder->{default_hostgroups}; # this is a hash with keys = hostgroups

        # record this cacti_event object for processing efficiently later
        push( @cacti_events, { %cacti_event } );

        ${$ref_total_events}++;

    }


    # Process the events set .....

    # Record the initial event set size as the size that was processed 
    # Even if there are errors during processing, the were 'processed'
    ${$ref_total_events_processed} = $#cacti_events + 1; 

    # If constraining hostsgroups are defined in the conf, then restrict the set of cacti events
    # to those whose hosts are members of the hostgroups in Foundation.
    # NOTE: Constraining at this point means any proceeding operations will only apply to this set of constrained events.
    if ( defined $feeder->{constrain_to_hostgroups} and scalar keys %{$feeder->{constrain_to_hostgroups}}  > 0 ) {
        if ( not constrain_to_hostgroups( \@cacti_events )  ) {
            $feeder->report_feeder_error( "CONSTRAINING TO HOSTGROUPS ERROR occurred getting hostgroups for hosts - skipping all processing of cacti events" ) ;
            return 0;
        }
    }


    # Get states for hosts as they are seen in the Cacti events set, and as they are seen in Foundation.
    # This will be used later for notification and event logic.
    # This sets FoundationHostState's in %hosts_states for hosts that exist in Foundation.
    # If this procedure fails at the API level, or the cacti hosts don't exist in Foundation, 
    # then FoundationHostStates won't get set, and it will seem as though these hosts don't exist in Foundation.
    get_hosts_states( \@cacti_events, \%hosts_states ); 

    # If an existent and non empty cacti_system_test_tweaks_file has been read, go process it.
    # If processing the test file fails, testing will be skipped.
    if ( defined $tests_config and scalar keys %{$tests_config} ) {
        cacti_system_test_tweaks( \@cacti_events, \%hosts_states ); 
        # Again, record the new event set size as the size that was processed (even if there are errors, the were 'processed')
        ${$ref_total_events_processed} = $#cacti_events + 1; 
    }

    # Check for cacti hosts and/or services that have been removed from Cacti and remove them from Foundation.
    # NOTE: This only applies to hosts/services that this feeder created (or whatever agentId ie guid is set to).
    # This is not really a full sychronization of Foundation, just the first part. The adding of things is done later.
    # If this fails, a partial or non removal will result.
#die Dumper \@cacti_events;
    remove_cacti_objects_from_foundation( \@cacti_events, \%hosts_states );

    # Get all of the current Foundation hosts' services states and set them directly back into each cacti event object.
    # Here %hosts_states is passed in because it provides a convenient unique list of hosts to work with.
    # If this fails at the API level:
    #   - some if not all service states will not be set back into event in the FoundationServiceState property
    #   - don't carry on but flag an error
    if ( not get_and_set_foundation_service_states( \@cacti_events, \%hosts_states ) ) {
        $feeder->report_feeder_error( "ERROR getting and setting Foundation service states on Cacti events - ending any further processing of cacti events" ) ;
        return 0;
    }

    # If necessary, reduce the set of cacti host and service events to only those which are having a state change.
    # Only do this filtering if a) always_send_full_updates = false, and b) we're on a full_update_frequency cycle, and c) its not the very first cycle
    if ( not $feeder->{always_send_full_updates} and ( $cycle_iteration % $feeder->{full_update_frequency} != 0 ) and ( $cycle_iteration != 1 )  ) {
        filter_out_non_state_changed_cacti_hosts_and_services( \@cacti_events, \%hosts_states );
        # Again, record the new event set size as the size that was processed (even if there are errors, the were 'processed')
        ${$ref_total_events_processed} = $#cacti_events + 1; 
    }
    
    # Create and/or update foundation hosts with their cacti hosts states
    if ( not upsert_foundation_hosts_with_cacti_host_states( \%hosts_states ) ) {
        $feeder->report_feeder_error( "FOUNDATION UPDATE ERROR occurred upserting hosts - ending any further processing of cacti events" ) ;
        return 0;
    }   
        
    # Upsert foundation hostgroups with cacti hosts memberships 
    # If this fails, its worth trying to continue on.
    upsert_foundation_hostgroups_with_cacti_hosts( \@cacti_events );

    # Upsert foundation hosts services with their cacti hosts services states
    # If this fails, should still carry on because even if Foundation services failed to be upserted,
    # state information is still available for use in notification logic.
    upsert_foundation_cacti_services( \@cacti_events );

    # Check for state changes, posting events and notifications if necessary
    # If this fails, at least an error will have been logged.
    post_events_and_notifications( \@cacti_events, \%hosts_states );

    return 1;
}


# ----------------------------------------------------------------------------------------------------------------
sub post_events_and_notifications
{
    # Takes a ref to an array of cacti event hashes, and a ref to a hash of host states (for a list of hosts)
    # Looks for state changes for hosts and services.
    # Posts notifications if state change detected and post_notifications is true.
    # Posts events if state change detected and options permit
    # returns 1 if ok, 0 otherwise

    my ( $ref_array_of_cacti_events, $ref_hash_of_host_states ) = @_;
    my ( $cacti_event, $cacti_host, @host_notifications, @service_notifications, $notificationType, $noma_status ) ;
    my ( @host_events, @service_events, $event_severity, $status );

    if ( not $feeder->{post_notifications} and not $feeder->{post_events} ) {
        $logger->debug("DEBUG post_notifications and post_events are both disabled - no posting of events or notifications will be done");
        return 1;
    }

    # Search for HOST state changes.
    # Construct arrays for both host notification and event objects.
    # CactiHostState can be one of these values ( as determined by get_cacti_host_state() ): UNREACHABLE, UNSCHEDULED DOWN, UP
    foreach $cacti_host ( keys %{$ref_hash_of_host_states} ) {
        # hosts not yet in foundation means FoundationHostState not set, and means don't send events or notifications
        if ( ( defined $ref_hash_of_host_states->{$cacti_host}{FoundationHostState}) and 
             ( $ref_hash_of_host_states->{$cacti_host}{CactiHostState} ne $ref_hash_of_host_states->{$cacti_host}{FoundationHostState} )  ) {

            # For events and notifications ....
            if ( $ref_hash_of_host_states->{$cacti_host}{CactiHostState} ne 'UP' ) { # ie UNREACHABLE, UNSCHEDULED DOWN, UP
                $notificationType = "PROBLEM";
                $event_severity = "SERIOUS";
            }
            else 
            {
                $notificationType = "RECOVERY";
                $event_severity = "OK";
            };

            # For notifications ...
            $noma_status = $ref_hash_of_host_states->{$cacti_host}{CactiHostState};
            $noma_status =~ s/UNSCHEDULED//g; # NoMa will quietly ignore UNSCHEDULED DOWN - only accepts UP, DOWN, UNREACHABLE
            $noma_status =~ s/\s+//g; # NoMa will quietly ignore ' UP' - pretty dumb about whitespace 
            push @host_notifications, {
	                                    'hostName'            => $cacti_host,
	                                    'hostState'           => $noma_status,
	                                    'notificationType'    => $notificationType,
	                                    'hostOutput'          => "$cacti_host is $ref_hash_of_host_states->{$cacti_host}{CactiHostState}", 
                                      };

            # For host events .... 
            push @host_events, {
                                   #'consolidationName' => 'CACTIEVENT',# for now don't consolidate events as they seem to mask each other
                                   'host'              => $cacti_host,
                                   'device'            => $cacti_host,
                                   'monitorStatus'     => $ref_hash_of_host_states->{$cacti_host}{CactiHostState},
                                   'appType'           => $feeder->{app_type},
                                   'severity'          => $event_severity,
                                   'textMessage'       => "$cacti_host is $ref_hash_of_host_states->{$cacti_host}{CactiHostState}",
                               }
        }
    }

    # Search for SERVICE state changes and post events for them
    foreach $cacti_event ( @{$ref_array_of_cacti_events} ) { 
        # events for hosts not yet in foundation means FoundationHostState not set, and means don't send events or notifications
        if ( ( defined $cacti_event->{FoundationServiceState} ) and ( $cacti_event->{CactiServiceState} ne $cacti_event->{FoundationServiceState} ) ) {

            # For notifications and events ...
            if ( $cacti_event->{CactiServiceState} ne 'OK' ) { # ie OK, UNSCHEDULED CRITICAL (or WARNING, UNKNOWN from test tweaking)
                $notificationType = "PROBLEM";
                $event_severity = "SERIOUS";
            }
            else 
            {
                $notificationType = "RECOVERY";
                $event_severity = "OK";
            };

            # For service notifications ...
            $noma_status = $cacti_event->{CactiServiceState} ;
            $noma_status =~ s/UNSCHEDULED//g; # NoMa will quietly ignore UNSCHEDULED CRITICAL - only accepts OK, WARNING, CRITICAL and UNKNOWN 
            $noma_status =~ s/\s+//g; # NoMa will quietly ignore ' CRITICAL' - pretty dumb about whitespace 
            push @service_notifications,  {
                                            'hostName'            => $cacti_event->{Host},
                                            'serviceDescription'  => $cacti_event->{ServiceDescription},
                                            'serviceState'        => $noma_status,
                                            'notificationType'    => $notificationType,
                                            'serviceOutput'       => $cacti_event->{LastPluginOutput},
                                          };

            # For service events ...
            push @service_events, {
                                   #'consolidationName' => 'CACTIEVENT',# for now don't consolidate events as they seem to mask each other
                                   'host'              => $cacti_event->{Host},
                                   'device'            => $cacti_event->{Host},
                                   'service'           => $cacti_event->{ServiceDescription},
                                   'monitorStatus'     => $cacti_event->{CactiServiceState},
                                   'appType'           => $feeder->{app_type},
                                   'severity'          => $event_severity,
                                   'textMessage'       => $cacti_event->{LastPluginOutput},
                               }

        }
    }

    $status = 1; # assume all operations will be ok and disprove ... rename this var :)

    # Send notifications ...
    if ( $feeder->{post_notifications} ) {
        # Send any host notifications
        if ( @host_notifications ) {
            $logger->debug( "DEBUG Posting host notifications" );
            if ( not $feeder->feeder_post_notifications( 'host', \@host_notifications ) ) {
                $feeder->report_feeder_error("NOTIFICATIONS ERROR creating host notifications.");
                $status = 0; # don't bail just yet - try and do as much as possible
            }
        }
        # Send any service notifications
        if ( @service_notifications ) {
            $logger->debug( "DEBUG Posting service notifications" );
            if ( not $feeder->feeder_post_notifications( 'service', \@service_notifications ) ) {
                $feeder->report_feeder_error("NOTIFICATIONS ERROR creating service notifications.");
                $status = 0; # don't bail just yet - try and do as much as possible
            }
        }
    }

    # Post events ...
    if ( $feeder->{post_events} and $feeder->{update_hosts_statuses} ) {
        # Post any host events.
        # Only post host events if update_hosts_statuses is set. Otherwise, the sv host status graphs will reflect up/down states, 
        # but the actual host status will not change when update_hosts_statuses = false
        if ( @host_events ) {
            $logger->debug( "DEBUG Posting host events" );
            if ( not $feeder->feeder_post_events( 'host', \@host_events ) ) {
                $feeder->report_feeder_error("EVENTS ERROR posting host events.");
                $status = 0; # don't bail just yet - try and do as much as possible
            }
        }
        # Post any service events
        if ( @service_events ) {
            $logger->debug( "DEBUG Posting service events" );
            if ( not $feeder->feeder_post_events( 'service', \@service_events ) ) {
                $feeder->report_feeder_error("EVENTS ERROR posting service events.");
                $status = 0; # don't bail just yet - try and do as much as possible
            }
        }
    }

    return $status;

}

# ----------------------------------------------------------------------------------------------------------------
sub validate_cacti_events  # incomplete and used for testing/debugging occasionally
{
    my ( $ref_array_of_cacti_events ) = @_;
    foreach my $event ( @{$ref_array_of_cacti_events} ) { 
        print " $event->{monitorStatus} \n";
    }
    # some code to validate structure of each event to ensure it has all required fields TBD
}
# ----------------------------------------------------------------------------------------------------------------
sub remove_cacti_objects_from_foundation
{
    # Takes a ref to an array of cacti event hashes, and a ref to a hash of host states (for a list of hosts)
    # Gets a list of hosts and their services that are in Foundation that were created by this feeder.
    # Compares that Foundation list with the incoming cacti events lists.
    # Removes anything in Foundation that was created by this feeder and is not in the cacti list.
    # returns 1 on ok, 0 otherwise

    my ( $ref_array_of_cacti_events, $ref_hash_of_host_states ) = @_;

    my ( %outcome, %results );
    my ( @hosts_bundle, @all_cacti_hosts, $foundation_host, $cacti_host );
    my ( %foundation_hosts_to_delete, %foundation_services_to_delete );
    my ( %cacti_hosts_and_services, $cacti_event, $foundation_service );
    my ( %delete_hosts_options, %delete_services_options );

    # Get a list of all hosts from foundation that were created by this feeder.
    $logger->debug( "DEBUG Getting all Foundation hosts that were created by this feeder (guid=$feeder->{guid})");
    if ( not $feeder->{rest_api}->get_hosts( [ ] , { query => "agentId = '$feeder->{guid}'", depth => 'simple' }, \%outcome, \%results ) ) {
        #$feeder->report_feeder_error("ERROR Could not get hosts details from Foundation - skipping any required object removal." );
        #return 0;
        $logger->debug("No hosts were found that were created by this feeder - skipping any required host removal." );
        return 1;
    }

    # Make a list of hosts that exist in Foundation but not in cacti (for the agentId as described above)
    foreach $foundation_host ( sort keys %results ) {
        if ( not exists $ref_hash_of_host_states->{ $foundation_host } ) {
            next if ( $foundation_host eq $feeder->{health_hostname} ); # skip deleting the feeder health host 
            $logger->debug( "DEBUG Marking Foundation host for delete : $foundation_host");
            $foundation_hosts_to_delete{$foundation_host} = 1;
        }
    }
        
    # Get a list of all services from foundation that were created by this feeder.
    # Format the results using the host->service format.
    $logger->debug( "DEBUG Getting all Foundation services that were created by this feeder (guid=$feeder->{guid})");
    if ( not $feeder->{rest_api}->get_services( [ ], { query => "agentId = '$feeder->{guid}'", format=>'host,service' }, \%outcome, \%results ) ) {
        #$feeder->report_feeder_error("ERROR Could not get services details from Foundation - skipping any required object removal.");
        #return 0;
	$logger->debug("No services were found that were created by this feeder - skipping any required service removal.");
        return 1;
    }


    # Construct a hash of cacti hosts->services from all of the cacti events
    summarize_cacti_hosts_and_services( $ref_array_of_cacti_events, \%cacti_hosts_and_services );
        
    # Make a list of services that exist in Foundation but not in cacti (for the agentId as described above)
    foreach $foundation_host ( sort keys %results ) {
        next if ( $foundation_host eq $feeder->{health_hostname} ); # skip deleting the feeder health host services
        next if ( defined $foundation_hosts_to_delete{$foundation_host} ) ; # skip deleting services for a host if it host marked for delete - deleting host=>all of its services nuked too
        foreach $foundation_service ( keys %{ $results{$foundation_host} } ) {
            if ( not exists $cacti_hosts_and_services{ $foundation_host } { $foundation_service } ) {
                $logger->debug( "DEBUG Marking Foundation service $foundation_host : $foundation_service for delete");
                $foundation_services_to_delete{$foundation_host}{$foundation_service} = 1;
            }
        }
    }

    # Bundle-wise delete any hosts from Foundation that don't exist in cacti event set
    %delete_hosts_options = ();
    if ( keys %foundation_hosts_to_delete ) { 
        if ( not $feeder->feeder_delete_hosts( \%foundation_hosts_to_delete, \%delete_hosts_options ) ) {
            $feeder->report_feeder_error("ERROR Couldn't delete hosts from Foundation.");
            return 0;
        }
    }

    # Bundle-wise delete any services from foundation that don't exist in cacti event set
    %delete_services_options = ();
    if ( keys %foundation_services_to_delete ) { 
        if ( not $feeder->feeder_delete_services( \%foundation_services_to_delete, \%delete_services_options ) ) {
            $feeder->report_feeder_error("ERROR Couldn't delete services from Foundation.");
            return 0;
        }
    }

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------
sub constrain_to_hostgroups
{
    # Takes a ref to an array of cacti event hashes, 
    # figures out unique set of hosts,
    # figures out which Foundation hostgroups these hosts are in,
    # then removes those events which have hostgroups matching the constrain_to_hostgroup array members
    my ( $ref_array_of_cacti_events ) = @_;

    my ( $cacti_event, %hosts, $cacti_event_hostgroup );

    # Figure out unique set of hostnames across all cacti events
    # assumes a cacti event always has a Host element
    foreach $cacti_event ( @{ $ref_array_of_cacti_events } ) {
        if ( not defined $hosts{ $cacti_event->{Host} } ) { 
            $hosts{ $cacti_event->{Host} } = undef;
        }
    }

    # If no hostgroups are defined for constraining, or an error occurred getting hostgroups, just return
    if ( not $feeder->feeder_get_hostgroups( \%hosts ) ) {
        $logger->debug("DEBUG No constraining to hostgroups will be done.");
        return 0;
    }
    else {
        $logger->debug("DEBUG Constraining to hostgroups.");
    }

    # Now have a %hosts hash that looks like this :
    # {
    #    host1 => { hg1 =>1, hg2 => 1, hg3 => 1 }, # in hg1, hg2 and hg3
    #    host2 => { hg1 =>1, hg4 => 1 }, 
    #    host3 => undef ; # in no hostgroups
    #    ...
    # }

    # If the cacti event Host is NOT a member of a hostgroup being constrained to, delete it.
    # TBD might be better to label it (or its cacti events) as constrained, and then later can decide whether to delete it or not ?
    my $index=0; my $constrained_events = 0; my @constrained_events = ();
    foreach $cacti_event ( @{ $ref_array_of_cacti_events } ) {
        # cycle through the list of hostgroups that this event's Host belongs to
        foreach $cacti_event_hostgroup ( keys %{ $hosts{ $cacti_event->{Host} } } ) {
            # If the event hostgroup matches one its constrained to, add it to a result list
            # ( Why not splice the cacti events array ? Splicing out elements of the array whilst its being referenced in this cacti_event loop - bad :] )
            if ( defined $feeder->{constrain_to_hostgroups}{$cacti_event_hostgroup} ) { 
                $constrained_events++;
                $logger->debug("DEBUG Hostgroup-constrained event : hostgroup $cacti_event_hostgroup, host $cacti_event->{Host}, service $cacti_event->{ServiceDescription}"); 
                push @constrained_events, $cacti_event;
                last; # only add this event once to the results
            }
        }
        $index ++;
    }

    $logger->info( "INFO  Constraining to host groups : events constrained down to $constrained_events events out of a possible total $index events");

    @{$ref_array_of_cacti_events} = @constrained_events;

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------
sub filter_out_non_state_changed_cacti_hosts_and_services
{
    # Takes a ref to an array of cacti event hashes, and a reference to a hash for host states.
    # Reduces both to just those that are experiencing a state change.
    # No return other than updating the data structures by ref.
    
    my ( $ref_array_of_cacti_events, $ref_hash_of_host_states ) = @_;
    my ( @new_events, %new_hosts_states, $host, $cacti_event );

    # Filter out hosts which didn't have state change
    foreach $host ( sort keys %{$ref_hash_of_host_states}  ) {
        # In the case of a host not yet existing in Foundation, FoundationHostState will not be defined here.
        # ie only those hosts which are in Foundation and which have had a state change get into the filtered hosts list
        if ( ( defined $ref_hash_of_host_states->{$host}{FoundationHostState} ) and 
             ( "$ref_hash_of_host_states->{$host}{CactiHostState}" ne "$ref_hash_of_host_states->{$host}{FoundationHostState}" ) )  { 
            $new_hosts_states{$host} =  $ref_hash_of_host_states->{$host} ;  
        }
    }
        
    # Update the hosts states results
    %{$ref_hash_of_host_states} = %new_hosts_states;

    # Filter out events which didn't have state change
    foreach $cacti_event ( @{ $ref_array_of_cacti_events } ) {
        # Cacti events should always have CactiServiceState set. 
        # If the corresponding service is not in Foundation, then FoundationServiceState won't be set. In that case, do allow it through so it gets 
        # added asap rather than waiting for the next full update cycle.

        # If both defined and not equal - thats a state change
        if ( ( defined $cacti_event->{FoundationServiceState} ) and ( "$cacti_event->{CactiServiceState}" ne "$cacti_event->{FoundationServiceState}" ) ) {
            push @new_events, $cacti_event;
        }

        # New service needs adding so let it through
        if ( not defined $cacti_event->{FoundationServiceState} ) {
            push @new_events, $cacti_event;
        }

    }
    
    @{$ref_array_of_cacti_events} = @new_events;

}

# ----------------------------------------------------------------------------------------------------------------
sub cacti_system_test_tweaks
{
    # Takes a ref to an array of cacti event hashes, and a reference to a hash for host states.
    # Tweaks those events as per instructions in the testdefs config.
    # This results in a reduced or altered set of cacti events and/or host states.
    # TBD add counters for more info at the end of tweaking?
    # returns 1 on success with modified events set, 0 otherwise (and no mods to the cacti event set)

    my ( $ref_array_of_cacti_events, $ref_hash_of_host_states ) = @_;
    my ( $cacti_event, $host );
    my ( %testdefs, @new_events, %new_hosts_states, %hosts_to_delete, $new_event );
    my %allowed_host_states = ( "UP"=>1, "UNKNOWN"=>1, "UNSCHEDULED DOWN"=>1 );
    my %allowed_service_states = ( "OK"=>1, "WARNING"=>1, "UNKNOWN"=>1, "UNSCHEDULED CRITICAL"=>1 );

    # This section tweaks cacti hosts' CactiHostState's.
    %testdefs = %$tests_config; # dereference it else checking it will actually populate it unclear why tho

    $logger->debug("DEBUG Processing cacti system test tweaks configuration $feeder->{cacti_system_test_tweaks_file}");

    # Identify which hosts need deleting
    foreach $host ( sort keys %{$ref_hash_of_host_states}  ) {
        # Repetition of host blocks will be disallowed for clarity
        if ( ref ( $tests_config->{$host} ) eq 'ARRAY' ) {
            $feeder->report_feeder_error( "TWEAKING ERROR in $feeder->{cacti_system_test_tweaks_file} - host $host had a block repeated - please consolidate. No test tweaking will be done.");
            return 0;
        }
        if ( exists $testdefs{ $host } { 'delete' } ) {
            $hosts_to_delete{$host} = 1;
            $logger->info( "INFO  Marking host '$host' for delete");
        }
        else {
            # this hash stores hosts that are marked for delete
            $new_hosts_states{$host} =  $ref_hash_of_host_states->{$host} ;  

            # tweak cacti hosts' CactiHostState's
            if ( $testdefs{ $host }{ hoststate } ) {
                $logger->info( "INFO  Tweaking host '$host' state from '$ref_hash_of_host_states->{$host}->{CactiHostState}' to '$testdefs{ $host }{ hoststate }'");
                #$ref_hash_of_host_states->{$host}->{CactiHostState} = $testdefs{ $host }{ hoststate };
                if ( not exists $allowed_host_states{ $testdefs{ $host }{ hoststate }} ) { 
                    $feeder->report_feeder_error( "TWEAKING ERROR in $feeder->{cacti_system_test_tweaks_file} - host state '$testdefs{ $host }{ hoststate }' invalid for host $host - should be one of :" . 
                            join( ",", keys %allowed_host_states )  . 
                            ". No test tweaking will be done." );
                    return 0;
                }
                $new_hosts_states{$host}{CactiHostState} = $testdefs{ $host }{ hoststate };
            }
        }
    }

    # update host states for rest of this sub and the rest of the feeder to use
    %{$ref_hash_of_host_states} = %new_hosts_states;

    # This section tweaks cacti event's CactiServiceState's
    my $skipcount = 0;
    foreach $cacti_event ( @{ $ref_array_of_cacti_events } ) {

        # skip event if host marked for delete ...
        if ( exists $hosts_to_delete{ $cacti_event->{Host} } ) {  # if host marked for delete, next
            $logger->debug("DEBUG Skipping event since host $cacti_event->{Host} was marked for delete");
            $skipcount++;
            next;
        }
        # tweak services if applicable
        if ( exists $testdefs{ $cacti_event->{Host} }{ $cacti_event->{ServiceDescription}}  ) {
            # skip event if service marked for delete ...
            if ( $testdefs{ $cacti_event->{Host} }{ $cacti_event->{ServiceDescription}} eq 'delete') {   
                $logger->debug("DEBUG Skipping event since service $cacti_event->{ServiceDescription} was marked for delete");
                $skipcount++;
                next;
            }
            # just set the service state 
            else {
                $logger->debug("DEBUG Tweaking service '$cacti_event->{ServiceDescription}' state from '$cacti_event->{CactiServiceState}' to '$testdefs{ $cacti_event->{Host} }{ $cacti_event->{ServiceDescription} }'");
                $new_event = $cacti_event;
                if ( not exists $allowed_service_states{ $testdefs{ $cacti_event->{Host} }{ $cacti_event->{ServiceDescription} } } ) {
                    $feeder->report_feeder_error( "TWEAKING ERROR in $feeder->{cacti_system_test_tweaks_file} - service state '$testdefs{ $cacti_event->{Host} }{ $cacti_event->{ServiceDescription} }' invalid - should be one of : " . 
                            join( ",", keys %allowed_service_states )  . 
                            ". No test tweaking will be done." );
                    return 0;
               }
                $new_event->{CactiServiceState} = $testdefs{ $cacti_event->{Host} }{ $cacti_event->{ServiceDescription} };
            }
        }
        else {
            #print "Host / Service combo $cacti_event->{Host} / $cacti_event->{ServiceDescription} doesn't exist in incoming cacti events - skipping\n";
            # TMI ?
        }
        
        # build the new events array
        push @new_events, $cacti_event;

    }
    $logger->info("INFO  Tweaking : $skipcount events have been removed essentially") if $skipcount > 0;

    @{$ref_array_of_cacti_events} = @new_events; # pass the newly build events back 

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------
sub get_hosts_states
{
    # Takes a ref to an array of cacti event hashes, and a reference to a hash for host states.
    # %host_states is populated with two things : state of cacti host in Foundation, state of cacti host in Cacti.
    # Tries to be as fast and efficient as possible with the API calls.
    # If the API call fails, then the FoundationHostState's don't get set, which will make these appear to not 
    # exist in Foundation later on in the code.

    $logger->debug( "DEBUG getting host states");

    my ( $ref_array_of_cacti_events, $ref_hash_of_host_states ) = @_;
    my ( $gwevent, $host, %cacti_hosts, %outcome, %results, $cacti_host );
    my ( @all_cacti_hosts, $hbsize, @hosts_bundle ); 
    my ( $host_cacti_state );

    # Extract a unique hash of the cacti host names out of the cacti events list
    # and set their values to their current cacti host states
    foreach $gwevent ( @{ $ref_array_of_cacti_events } ) {

        # Get the state of the cacti host as it is in the Cacti system
        $host_cacti_state = get_cacti_host_state( $gwevent->{HostId} );
        
        # Stash that host state - this code assumes that the host state is equal across of cacti services
        # as per that big select up in process_cacti. 
        if ( not defined $ref_hash_of_host_states->{ $gwevent->{Host} }{CactiHostState} ) {
            $ref_hash_of_host_states->{ $gwevent->{Host} }{CactiHostState}   = $host_cacti_state;
        }
            
        # Continue to build the hash of unique hostnames across all events
        if ( not defined $cacti_hosts{ $gwevent->{Host} }  ) { 
                $cacti_hosts{ $gwevent->{Host} } = 1;
        }
    }

    # Efficiently get batches of Foundation host states
    @all_cacti_hosts = keys %cacti_hosts;  
    while ( @hosts_bundle = splice @all_cacti_hosts, 0, $feeder->{host_bundle_size} ) { 
        $logger->debug("DEBUG getting host states for " . ($#hosts_bundle + 1) . " hosts");
        if ( not $feeder->{rest_api}->get_hosts( \@hosts_bundle, {}, \%outcome, \%results ) ) {
            # report an error but continue on rather than returning - ie try to do as much as possible
            if ( defined $outcome{response_code} and $outcome{response_code} ne '404' ) {
                $feeder->report_feeder_error("ERROR getting host states : " . Dumper \%outcome, \%results); die;
            }
        }
        foreach $cacti_host ( keys %cacti_hosts ) {
            if ( defined $results{$cacti_host}{monitorStatus} ) {
                $ref_hash_of_host_states->{$cacti_host}{FoundationHostState} = $results{$cacti_host}{monitorStatus} ;
            }
            else { 
                # the host might not yet exist in Foundation
                #print "Host $cacti_host doesn't have monitorStatus set yet\n"; #  TBD anything to do here ? 
            }
        }
    }

    # At this point, if things worked, then the hash referred to by $ref_hash_of_host_states will look like this, for eg: 
    #
    # {
    #     'host1' => {
    #                        'CactiHostState' => 'UNSCHEDULED DOWN', # ie host1's state in Cacti (translated to GW) is this
    #                         # NOTE  no FoundationHostState set if the host was not yet in Foundation!!!
    #                },
    #     'host2' => {
    #                        'CactiHostState' => 'UNSCHEDULED DOWN', # ie host2's state inc Cacti (translated to GW states) is this
    #                        'FoundationHostState' => 'UP' # ie host2's host state in Foundation is this
    #                },
    #      ...
    # }

    # If things failed, or the hosts in cacti don't exist in Foundation, then the FoundationHostState's won't be in the hash.

}

# ----------------------------------------------------------------------------------------------------------------
sub get_and_set_foundation_service_states
{
    # Takes a ref to an array of cacti event hashes, and a ref to a hash of host states (for a list of hosts)
    # and figures out Foundation states for the cacti services.
    # Results are stored back into each cacti event object in the array ref.

    my ( $ref_array_of_cacti_events, $ref_hash_of_host_states ) = @_;
    my ( $cacti_event, @all_cacti_hosts, @hosts_bundle, $hbsize,
         %outcome, %results, $cacti_host, $cacti_service,
       );

    # Efficiently get all services for a subset of hosts (ie with least # of api calls)
    # Note : there's currently no way to get services like this : {hostA, svc1}, {hostB, svc2} etc which would be ideal here.

    # Definitely other ways this could be approached.  For example, could figure out the services list for each cacti host 
    # and get all of the service states for that host from foundation. The possible issue with that approach is that the service 
    # names for cacti services can be quite long and quite numerous so might run into exceeding url length limitations via RAPID 
    # which is just doing a GET <url>.
    # Could also get all hosts services (a bit too heavy an operation for thousands of hosts with many services on them).
    # Could also chunk it up by getting all services for subsets of hosts like in get_hosts_states().
    # For now will get all services for each host via one api call PER HOST and see how that performs.
    # Getting all services for each host is less efficient.
    # Returns 1 on success, 0 otherwise

    # Create a simple hash of cacti hostnames and their sets of cacti services from the events. 
    # This is aimed at helping unpack potentially large nested loops.
    my %cacti_hosts_and_services; 

    $logger->debug( "DEBUG getting and setting Foundation service states");

    foreach $cacti_event ( @{ $ref_array_of_cacti_events } ) {
        $cacti_hosts_and_services{  $cacti_event->{Host} } { $cacti_event->{ ServiceDescription } } = undef;
    }

    @all_cacti_hosts = sort keys %{$ref_hash_of_host_states};  
    while ( @hosts_bundle = splice @all_cacti_hosts, 0, $feeder->{host_bundle_size} ) { 
        #$logger->debug( "DEBUG get_and_set_foundation_service_states() process bundle of " . ($#hosts_bundle + 1 ) . " host(s) : @hosts_bundle" );
        $logger->debug( "DEBUG get_and_set_foundation_service_states() process bundle of " . ($#hosts_bundle + 1 ) . " host(s)" );
        if ( not $feeder->{rest_api}->get_services( [], { hostname => \@hosts_bundle, format => 'host,service' }, \%outcome, \%results ) ) {
            if ( defined $outcome{response_code} and $outcome{response_code} ne '404' ) {
                $feeder->report_feeder_error( "ERROR Getting Foundation service states - no Foundation service states will be set for this bundle of hosts : @hosts_bundle" );
                return 0;
            }
            else {
                # else just carry on - its ok to get a 404 in the case of ALL services not existing yet
            }
        }
        foreach $cacti_host ( @hosts_bundle ) {
            # See if the cacti services for this host have a service status in the Foundation services list for this host
            foreach $cacti_service ( keys %{ $cacti_hosts_and_services{ $cacti_host } } ) {
                # If the cacti service for this cacti host showed up with a status in Foundation service results for this host, then 
                # update the cacti hosts and services hash for this host/service with the Foundation service status
                if ( defined $results{$cacti_host}{$cacti_service}{monitorStatus} ) { 
                   #print "Host '$cacti_host' -> Service '$cacti_service' === defined : status=$results{$cacti_host}{$cacti_service}{monitorStatus}\n";
                    $cacti_hosts_and_services{ $cacti_host } { $cacti_service } = $results{$cacti_host}{$cacti_service}{monitorStatus};  
                }
                # Else the cacti service didn't show up in Foundation so it hasn't been added yet - and thats ok TBD double check this
            }
        }
    }

    # Go back through the original array of cacti events, inserting FoundationServiceState values 
    foreach $cacti_event ( @{ $ref_array_of_cacti_events } ) {
        # If this cacti event has a defined value in the cacti hosts and events hash built above, then record that back into the event itself
        if ( defined $cacti_hosts_and_services{ $cacti_event->{Host} } { $cacti_event->{ServiceDescription} } ) {
            $cacti_event->{FoundationServiceState} = $cacti_hosts_and_services{ $cacti_event->{Host} } { $cacti_event->{ServiceDescription} } ;
        }
        else { 
            # service has not been added to Foundation yet and thats ok TBD double check this
        }
    }

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------
sub upsert_foundation_hosts_with_cacti_host_states
{
    # Takes a hash of cacti host names with expected CactiHostState values and 
    # creates the hosts or updates them (ie upserts them) in Foundation
    my ( $ref_hash_of_cacti_hosts ) = @_;
    my ( @cacti_hosts_bundle, @cacti_hosts, $cacti_host, %host_options, @hosts ) ;

    %host_options = ();
    @cacti_hosts = keys %{$ref_hash_of_cacti_hosts};

    $logger->debug("DEBUG upserting hosts");
    
    if ( not @cacti_hosts ) { 
        $logger->debug("DEBUG no hosts needed processing.");
        return 1;
    }
        
    # Build an array of options that the feeder rest api can consume
    # However, don't pass in description, properties, agentId, appType or anything else that 
    # will overwrite things should the host already exist. Instead, let feeder_upsert_hosts add those if necessary.
    foreach $cacti_host ( @cacti_hosts ) {

        push @hosts,  {
                          # This should be the smallest set of properties required for updating an existing host
                          hostName       => $cacti_host,
                          monitorStatus  => $ref_hash_of_cacti_hosts->{$cacti_host}{CactiHostState},
                      };

    }

    # feeder_upsert_hosts does bundling 
    if ( not $feeder->feeder_upsert_hosts( \@hosts, \%host_options ) ) { 
        $feeder->report_feeder_error("FOUNDATION HOSTS UPSERT ERROR could not upsert hosts" );
        return 0; 
    }

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------
sub upsert_foundation_hostgroups_with_cacti_hosts
{
    # Takes a ref to an array of cacti event hashes, and updates foundation hostgroup membership with 
    # the hosts from these events. The hostgroups these hosts are assigned to are defined in the default_hostgroups hash prop in the conf.
    # The idea behind the decoupling of assigning hostgroups to hosts from events, and the construction of hostgroup REST data
    # is to allow the former to change without the latter needing to necessarily.
    # Returns 1 on success, 0 otherwise
    # TBD This always gets executed regardless. Be nice to make it smarter.

    my ( $ref_array_of_cacti_events ) = @_;
    my ( %hostgroup_options, @hostgroups, $cacti_event, %cacti_hosts_and_groups, $cacti_hostgroup, $cacti_hostgroup_member, @hosts, $hostgroup );

    %hostgroup_options = ();
    
    # Figure out from the cacti events which hostgroups have which hosts as members
    # that info goes into an hash <hostgroupname> => { host, host, host ... }
    foreach $cacti_event ( @{$ref_array_of_cacti_events} ) {
        foreach $hostgroup ( keys %{ $feeder->{default_hostgroups} } ) {
            $cacti_hosts_and_groups{ $hostgroup} { $cacti_event->{Host}}  = 1 ;
        }
    }

    # Construct data for api call
    foreach $cacti_hostgroup ( keys %cacti_hosts_and_groups ) {
        # Get the members of each hostgroup 
        @hosts = ();
        foreach $cacti_hostgroup_member ( keys %{$cacti_hosts_and_groups{$cacti_hostgroup}} ) {
            push @hosts, { "hostName" => $cacti_hostgroup_member };
        }
        # Build the required api fields, referencing the hosts array built beforehand
        # However, don't pass in anything that will overwrite things should the hostgroup already exist. 
        # Instead, let feeder_upsert_hostgroups add those if necessary.
        push @hostgroups, {
                            # Just enough properties to update hostgroup membership
                            "name"        => $cacti_hostgroup,
                            "hosts"       => [ @hosts ] , # use [ @hosts ] rather than \@hosts here
                          } ;
    
        # Upsert the hostgroups, remember that feeder_upsert_hostgroup handles bundling
        # at the hostgroup level, but not at the hosts level ie you could have one hostgroup with 100000 hosts 
        # and all 100000 will attempted to be added in one api call. TBD improve this later perhaps.
    }

    if ( not $feeder->feeder_upsert_hostgroups( \@hostgroups, \%hostgroup_options ) ) {
        $feeder->report_feeder_error("FOUNDATION HOSTGROUPS UPSERT ERROR could not upsert hostgroups" );
        return 0;
    }
    
    return 1;

}


# ----------------------------------------------------------------------------------------------------------------
sub upsert_foundation_cacti_services
{
    # Takes an ref to an array of cacti events and upserts their services in Foundation
    # Returns 1 on success, 0 otherwise 

    my ( $ref_array_of_cacti_events ) = @_;
    my ( $cacti_event, @services, %service_options );

    if ( not @{$ref_array_of_cacti_events} ) {
        $logger->debug("DEBUG no cacti events needed processing.");
        return 1;
    }

    %service_options = ( );
    foreach $cacti_event ( @{$ref_array_of_cacti_events} ) {

        # Build the required api fields.
        # However, don't pass in anything that will overwrite things should the host:service already exist. 
        # Instead, let feeder_upsert_services add those if necessary.
        push @services, { 
                            # This is the minimum set of properties to achive an update of the service
                            'description'          => $cacti_event->{ServiceDescription},   # the name of the service
                            'hostName'             => $cacti_event->{Host},                 # the host name
                            'monitorStatus'        => $cacti_event->{CactiServiceState},    # the service status
                            'properties'           => { "LastPluginOutput" => $cacti_event->{LastPluginOutput} }, # the service status message
                        };
    }

    if ( not $feeder->feeder_upsert_services( \@services, \%service_options ) ) {
        $feeder->report_feeder_error("FOUNDATION SERVICES UPSERT ERROR could not upsert Cacti services in Foundation" );
        return 0;
    }

    return 1;
}

# ----------------------------------------------------------------------------------------------------------------
sub get_cacti_hostname
{
    # Gets the cacti host description and returns it

    my ( $id ) = @_;
    my $query = "select description from host where id = '$id';";
    $logger->trace("TRACE get_cacti_hostname() SQL = '$query'");
    my $sqlQuery  = $dbh_cacti->prepare($query) or do { $feeder->report_feeder_error( "SQL ERROR Can't prepare $query: " . $dbh_cacti->errstr); return ; };
    $sqlQuery->execute or do { $feeder->report_feeder_error("SQL ERROR Can't execute the query $query : " . $sqlQuery->errstr) ; return ; };
    return $sqlQuery->fetchrow_array();
}


# ----------------------------------------------------------------------------------------------------------------
sub get_cacti_host_state
{
    # Gets the cacti host state and returns it as a GW state : UNKNOWN, DOWN, UNSCHEDULED DOWN, UP
    # Cacti host state values are:
    #   3 Up
    #   2 Recovering
    #   1 Down
    #   0 Unknown
    #  -1 Any
    #  -2 Disabled
    #  -3 Enabled
    #  -4 Not Up

    my ( $id ) = @_;
    my %STATES = (
                    # GW host states here have been chosen so they render properly in status viewer. 
                    # Eg 'UNKNOWN' whilst currently accepted by upsert_hosts() shows up as unrecognized ie empty non counted host state in sv
                    # These mappings are still not quite satisfactory. TBD review.
                    #'-1' => 'UNKNOWN', # UNKNOWN is not a valid host state in GW it seems
                    #'-2' => 'UNKNOWN',
                    #'-3' => 'UNKNOWN',
                    '-1' => 'UNREACHABLE',
                    '-2' => 'UNREACHABLE',
                    '-3' => 'UNREACHABLE',
                    #'-4' => 'DOWN', # has to be UNSCHEDULED DOWN for GW API
                    '-4' => 'UNSCHEDULED DOWN', # has to be UNSCHEDULED DOWN for GW API
                    #'0'  => 'UNKNOWN',
                    '0'  => 'UNREACHABLE',
                    '1'  => 'UNSCHEDULED DOWN',
                    '2'  => 'UP', # Perhaps make this PENDING ?
                    '3'  => 'UP'
    );
    my $query = "select status from host where id = '$id';";
    $logger->trace("TRACE get_cacti_host_state() SQL=$query");
    my $sqlQuery  = $dbh_cacti->prepare($query) or do { $feeder->report_feeder_error( "SQL ERROR Can't prepare $query: " . $dbh_cacti->errstr) ; return ; };
    $sqlQuery->execute or do { $feeder->report_feeder_error( "SQL ERROR Can't execute the query $query : " . $sqlQuery->errstr) ; return ; };
    return $STATES{  $sqlQuery->fetchrow_array() } ;
}
 
# ----------------------------------------------------------------------------------------------------------------
sub initialize_cacti_database_connection
{
    # Set up cacti database handle
    # returns 1 on success, 0 otherwise

    my ( $dsn_cacti );

    $logger->info("INFO  Initializing connection to cacti database");
    # TBD needs to be able to handle case of reconnecting - eg what happens if connect, then restart psql , then read with original handle  ?
    if ( $feeder->{cactidbtype} eq 'postgresql' ) {
        $dsn_cacti = "DBI:Pg:dbname=$feeder->{cactidbname};host=$feeder->{cactidbhost};port=$feeder->{cactidbport}";
    }
    elsif ( $feeder->{cactidbtype} eq 'mysql' ) {
        $dsn_cacti = "DBI:mysql:database=$feeder->{cactidbname};host=$feeder->{cactidbhost};port=$feeder->{cactidbport}";
    }
    else {
        # unrecognized db type error
        $feeder->report_feeder_error("DATABASE ERROR Invalid database type - should be postgresql or mysql.");
        return 0;  
    }

    $dbh_cacti = DBI->connect( $dsn_cacti, $feeder->{cactidbuser}, $feeder->{cactidbpass}, { 'AutoCommit' => 1 } ); 
    if ( ! $dbh_cacti ) {
        $feeder->report_feeder_error ("CACTI DATABASE ERROR Cannot connect to database '$feeder->{cactidbname}'. Error: '$DBI::errstr'");
        return 0;
    }

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------
sub cacti_db_connection_ok
{
    # Checks to see if a db connection is up using the ping() method.
    # TBD Works with psql but needs testing against mysql

    return 0 if not defined $dbh_cacti;
    return $dbh_cacti->ping();
}

# ----------------------------------------------------------------------------------------------------------------
sub update_feeder_stats
{
    # Logs feeder stats and updates services with metrics too

    my ( $cycle_number, $total_cycle_time_taken, $total_events, $total_events_processed ) = @_;
    my ( $cycle_elapsed_time_msg, $events_processed_msg ) ;

    $cycle_elapsed_time_msg = "Cycle $cycle_number elapsed processing time : $total_cycle_time_taken seconds";

    $total_events_processed = 0 if not defined $total_events_processed;
    $total_events           = 0 if not defined $total_events;

    $events_processed_msg   = "$total_events_processed events processed out of a total possible $total_events events";

    $logger->debug("DEBUG Updating feeder statistics");

    # Log metrics
    $logger->info( "INFO  $cycle_elapsed_time_msg") if defined $feeder->{cycle_timings};
    $logger->info( "INFO  $events_processed_msg");

    # Update services with metrics
    if ( not $feeder->feeder_upsert_services(    [ 
                                                    {
                                                        'description'          => 'cycle_elapsed_time',
                                                        'hostName'             => $feeder->{properties}->{health_hostname}, 
                                                        'monitorStatus'        => 'OK', 
                                                        'properties'           => { "LastPluginOutput" => $cycle_elapsed_time_msg }
                                                    },
                                                    {
                                                        'description'          => 'events_processed',
                                                        'hostName'             => $feeder->{properties}->{health_hostname}, 
                                                        'monitorStatus'        => 'OK', 
                                                        'properties'           => { "LastPluginOutput" => $events_processed_msg }
                                                    },
        
                                                    # Maybe add something like this in future
                                                    #{
                                                    #    'description'          => 'feeder_objects',
                                                    #    'hostName'             => $feeder->{properties}->{health_hostname}, 
                                                    #    'monitorStatus'        => 'OK', 
                                                    #    'properties'           => { "LastPluginOutput" => "h/hg/s created: 1/2/3,  h/hg/s/ deleted : 4/5/6" }
                                                    #},
                                                 
                                                ], {}  )  ) { # Author's favourite line of code ;->
        $feeder->report_feeder_error("ERROR updating feeder statistical services");
    }

}

# ----------------------------------------------------------------------------------------------------------------
sub initialize_options
{
    # Command line options processing and help.
    # TBD finish help string

    my $helpstring = "
Groundwork Cacti feeder - version $VERSION
GroundWork Feeder module version $GW::Feeder::VERSION
";

    $SIG{__WARN__} = undef; # disable warnings to log4perl temporarily
    GetOptions(
                'help'             => \$help,
                'once'             => \$once,
                'version'          => \$show_version,
              ) or die "$helpstring\n";

    if ( defined $help ) { print $helpstring; exit; }
    if ( defined $show_version ) { print "$0 version $VERSION, Feeder module version $GW::Feeder::VERSION\n"; exit; }

    $SIG{__WARN__} = sub { $logger->warn( "WARN  @_" );  }; # revert- warnings to log4perl
}

# ---------------------------------------------------------------------------------
sub read_cacti_system_test_tweaks_file
{
    # Reads the cacti_system_test_tweaks_file config into a hash 

    if ( ( not -e $feeder->{cacti_system_test_tweaks_file} ) or ( not -r $feeder->{cacti_system_test_tweaks_file} ) ) {
        $logger->debug("DEBUG Cacti system test tweaks config file '$feeder->{cacti_system_test_tweaks_file}' doesn't exist or isn't readable. No testing will be done.");
        return;
    }
         
    eval { $tests_config = TypedConfig->new ( $feeder->{cacti_system_test_tweaks_file} ); };
    if ($@) {
        chomp $@;
        $@ =~ s/^ERROR:\s+//i;
        $logger->error("ERROR Cannot read tests config file $feeder->{cacti_system_test_tweaks_file} ($@) - continuing without tests");
    };
}

# ---------------------------------------------------------------------------------
sub summarize_cacti_hosts_and_services
{
    # Takes an array of cacti event hashes and
    # boils it down to a hash : { host1 => { service1=>1, service2=>2, ... },   host2 => { service5=>1, service12=>2, ... }   }

    my ( $ref_hash_of_cacti_hosts, $hashref_results ) = @_;

    my ( %results, $cacti_event );

    foreach $cacti_event ( @{$ref_hash_of_cacti_hosts} ) {
        if ( defined $cacti_event->{Host} and defined $cacti_event->{ServiceDescription} ) { 
            $results{ $cacti_event->{Host} } { $cacti_event->{ServiceDescription} } = 1;    
        }
        else {
            $feeder->report_feeder_error("ERROR Skipping malformed cacti event - expecting both Host and ServiceDescription keys to be defined. Got " . Dumper $cacti_event );
        }
    }

    %{$hashref_results} = %results;

}

# ---------------------------------------------------------------------------------
sub validate_feeder_specific_options
{
    # Logic for validation of feeder-specific options
    # TBD improve this

    if ( not defined $feeder->{default_hostgroups} or not scalar keys %{ $feeder->{default_hostgroups} } ) {
        $feeder->terminate_feeder("ERROR No default hostgroups given - check the default_hostgroups hash property is present and non empty. Quitting.");
    }

}

# ----------------------------------------------------------------------------------------------------------------
sub check_cacti_system_indicator
{
    # Looks for an indicator from the cacti system telling the feeder to go ahead and process cacti events.
    # For now, this is simply existence of a flag file which is created via the cacti_cron.sh cron script.
    # TBD perhaps use a more resilient approach than a flag file :)
    # returns 1 if the indicator is positive, 0 otherwise

    if ( -e $feeder->{cacti_system_indicator_file} ) {
        return 1;
    }
    return 0;
}

# ----------------------------------------------------------------------------------------------------------------
sub reset_cacti_system_indicator
{
    # Resets the cacti system indicator.
    # For now this just means delete the flag file.
    # TBD perhaps use a more resilient approach than a flag file :)
    # returns 1 if the reset worked, 0 otherwise

    if ( not unlink $feeder->{cacti_system_indicator_file} ) {
        $feeder->report_feeder_error("CACTI SYSTEM INTEGRATION ERROR Could not remove cacti system indicator file $feeder->{cacti_system_indicator_file} : $!");
        return 0;
    }
    else { 
        $logger->debug("DEBUG reset cacti system indicator by removing file file $feeder->{cacti_system_indicator_file}");
    }
    return 1;
    
}

# ----------------------------------------------------------------------------------------------------------------
sub cacti_system_requirements_met
{
    # Checks for the following requirements :
    #  - specific version of cacti
    #  - existence of thold plugin
    #  - specific version of thold plugin
    # Takes ref to a cacti version var which it will populate
    # Returns 0 if any of these requirements are not met, 1 if all are met

    my ( $cacti_version_ref ) = @_;
    my ( $sth );

    # get the version of cacti
    $$cacti_version_ref = get_cacti_version();

    # check the version of cacti
    if ( not exists $supported_cacti_versions{$$cacti_version_ref} ) {
        $feeder->report_feeder_error("ERROR Cacti version $$cacti_version_ref is not yet supported by this feeder");
        return 0;
    }

    # Check that the thold plugin is installed by checking for existence of thold tables
    $sth = $dbh_cacti->table_info('', '', 'thold_%', 'TABLE');
    if ( not $sth->fetch) {
        $feeder->report_feeder_error("ERROR Cacti doesn't appear to have the thold plugin installed - no thold tables were found in the cacti database");
        return 0;
    } 

    # TBD check for the right version of the thold plugin via the database, not the cli.
    # Since there's no thold_version table yet, marking this as to-do

    return 1;
}

# ----------------------------------------------------------------------------------------------------------------
sub generate_cacti_query
{
    # get the set of cacti events based on this query
    # Takes a cacti version string.
    # returns 1 on success, 0 otherwise
    my ( $query_ref, $cacti_version ) = @_;

    # Create the query based on the version
    if ( $cacti_version eq '0.8.7g' ) {
        # This is the version shipped with GW 7.0.2. 
        $$query_ref= "SELECT    thold_data.*, host.description, host.status
                       FROM      thold_data  LEFT JOIN  host  ON  thold_data.host_id=host.id
                       WHERE     thold_enabled='on'  OR  bl_enabled='on'
                       ORDER BY  thold_alert DESC, bl_alert DESC, host.description, rra_id ASC;";
        return 1;
    }
    elsif ( $cacti_version eq '0.8.8b' ) {
        # This is the latest version at the time this comment is being written. In this version :
        # - thresholds have a type : 0 for hi/low, 1 for baseline deviation, 2 for time based
        # - thresholds can be enabled or not, regardless of type
        $$query_ref = "SELECT    thold_data.*, host.description, host.status
                       FROM      thold_data  LEFT JOIN  host  ON  thold_data.host_id=host.id
                       WHERE     thold_enabled='on'  
                       ORDER BY  thold_alert DESC, bl_alert DESC, host.description, rra_id ASC;";
        return 1;
    }
    else {
        # A query needs writing.
        $feeder->report_feeder_error("ERROR No suitable cacti query has been defined yet for Cacti version $cacti_version");
        $$query_ref = undef;
        return 0;
    }

}

# ----------------------------------------------------------------------------------------------------------------
sub get_cacti_version
{
    # looks in the cacti database version table for the cacti version
    # returns that version, or undef if couldn't find the version
    my $query = "select * from version;";
    $logger->debug("DEBUG get_cacti_version() SQL = '$query'");
    my $sqlQuery  = $dbh_cacti->prepare($query) or do { $feeder->report_feeder_error( "SQL ERROR Can't prepare $query: " . $dbh_cacti->errstr); return undef ; };
    $sqlQuery->execute or do { $feeder->report_feeder_error("SQL ERROR Can't execute the query $query : " . $sqlQuery->errstr) ; return ; };
    my @rows = $sqlQuery->fetchrow_array();
    if ( not @rows ) {
        $feeder->report_feeder_error("ERROR No cacti version was defined in the cacti version table.");
        return undef;
    }
    $logger->debug("DEBUG Cacti version : '$rows[0]'");
    return $rows[0];
}

__END__
