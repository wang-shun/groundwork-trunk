#!/usr/local/groundwork/perl/bin/perl -w --

# This test script tests the REST API Perl module set_/clear_/get_indowntime
# Its more convenient to do it all together rather than separate .t files for get/set/clear

use strict;

# FIX MAJOR:  This is one form of workaround for the underscore-to-dash translation issue.
# It should be fixed instead by renaming the APP_NAME and GWOS_API_TOKEN header names.
use HTTP::Headers; $HTTP::Headers::TRANSLATE_UNDERSCORE = 0;
use GW::RAPID;
use Test::More;
use Test::Deep;
use Test::Exception;
use JSON;
use Data::Dumper; $Data::Dumper::Indent   = 1; $Data::Dumper::Sortkeys = 1;
use File::Basename; my $requestor = "RAPID-" . basename($0);
use Log::Log4perl qw(get_logger);
Log::Log4perl::init('GW_RAPID.log4perl.conf');
my $logger = get_logger("GW.RAPID.module");
$logger->debug("----- START get_host_identities() tests ----");
my ( %outcome, %results, @results, $query, $msg, @ids ) = ();

# ----------------------------------------------------------------------------------------------------------------------
# initialize the REST API
my $rest_api = GW::RAPID->new( undef, undef, undef, undef, $requestor, { access => '/usr/local/groundwork/config/ws_client.properties' });


# Exception testing for set/get/clear_indowntime( \\%objects, \\%options, \\%outcome, \\@results )
foreach my $function qw( set_indowntime get_indowntime clear_indowntime ) {
	is $rest_api->$function("arg1"), 0, 'Missing arguments exception';
	is( ( not $rest_api->$function( "arg1", "arg2", \%outcome, "arg4", "arg5" ) and $outcome{response_error} =~ /Invalid number of args/ ), 1, 'Too many arguments exception' );
	is( ( not $rest_api->$function( undef, {}, \%outcome, [] ) and $outcome{response_error} =~ /Undefined arg/ ), 1, 'Undefined argument exception' );
	is( ( not $rest_api->$function( [], undef, \%outcome, [] ) and $outcome{response_error} =~ /Undefined arg/ ), 1, 'Undefined argument exception' );
	is $rest_api->$function( [], {}, undef, [] ), 0, 'Undefined argument exception'; 
	is( ( not $rest_api->$function( [], {}, \%outcome, undef ) and $outcome{response_error} =~ /Undefined arg/ ), 1, 'Undefined argument exception' );
	is( ( not $rest_api->$function( [], {}, \%outcome, [] ) and $outcome{response_error} =~ /Expecting HASH reference/ ), 1, 'Incorrect arguments object type reference exception' );
	is( ( not $rest_api->$function( [], [], \%outcome, [] ) and $outcome{response_error} =~ /Expecting HASH reference/ ), 1, 'Incorrect arguments object type reference exception' );
	is $rest_api->$function( {}, {}, [], [] ), 0, 'Incorrect arguments object type reference exception';
	is( ( not $rest_api->$function( {}, {}, \%outcome, {} ) and $outcome{response_error} =~ /Expecting ARRAY reference/ ), 1, 'Incorrect arguments object type reference exception' );
	is( ( not $rest_api->$function( "", {}, \%outcome, [] ) and $outcome{response_error} =~ /Expecting HASH reference/ ), 1, 'Incorrect arguments object type reference exception' );
	is( ( not $rest_api->$function( [], "", \%outcome, [] ) and $outcome{response_error} =~ /Expecting HASH reference/ ), 1, 'Incorrect arguments object type reference exception' );
	is $rest_api->$function( [], {}, "", [] ), 0, 'Incorrect arguments object type reference exception'; 
	is( ( not $rest_api->upsert_hosts( [], {}, \%outcome, "" ) and $outcome{response_error} =~ /Expecting ARRAY reference/ ), 1, 'Incorrect arguments object type reference exception' );
}

# biz/[get,set,clear]_indowntime works differently to other methods :
#  - the objects passed in to the methods are not arrays, but rather just whatever JSON string you want
#  - all of the methods call POST (ie get_indowntime, set_indowntime and clear_indowntime)

# From the docs:
#
# Set downtime for hosts and services associated with host names, service descriptions, host group names, or service group names by 
# incrementing their Nagios ScheduledDowntimeDepth properties. Hosts may be set to a single * wildcard to specify all hosts for a 
# service(s). Similarly, service descriptions may be set to a single * wildcard to specify all services for a host(s). The following 
# table documents the valid parameter combinations. START_DOWNTIME and IN_DOWNTIME events are also generated by this endpoint. A list 
# of hosts and services that have been put in downtime is returned and is wrapped in an XML <bizHostServiceInDowntimes> element or 
# JSON object with an bizHostServiceInDowntimes array member.
#
# Clear downtime for hosts and services by decrementing their Nagios ScheduledDowntimeDepth properties. 
# Hosts and services are specified by posting the returned in downtime list returned by the set in downtime invocation, (See 20.1). 
# IN_DOWNTIME and CLEAR_DOWNTIME events are also generated by this endpoint. A list of hosts and services that have cleared downtime 
# is returned and is wrapped in an XML <bizHostServiceInDowntimes> element or JSON object with an bizHostServiceInDowntimes array member.
# The data posted to this endpoint must be the same returned by set in downtime, (See 20.1.5). 
# All elements must be returned in the same order and all data fields must be preserved with the exception of the scheduledDowntimeDepth which will be overwritten.
#
# Get downtime for hosts and services by returning their Nagios ScheduledDowntimeDepth properties. 
# Hosts and services are specified by posting the returned in downtime list returned by the set in downtime invocation, (See 20.1). 
# A list of hosts and services is returned and is wrapped in an XML <bizHostServiceInDowntimes> element or JSON object with an bizHostServiceInDowntimes array member.

# Basic core functionality tests
# ------------------------------
# set some downtimes 
# get some of them
# clear some of them

# create some test hosts (delete them first)
my $unlikely_host = '__abc_domtesting__RAPID__abc_zzz___' ; # it's really unlikely this host will ever exist - could write a function to return non existent host but this is fine for now 
my @test_hosts = ( "ahost1" , "ahost2" , "ahost3", 'ahost4', 'ahost5', 'ahost6' );
my @host_set1 = @test_hosts[0..3];
my @host_set2 = @test_hosts[4..5];
delete_test_hosts( \@test_hosts ); # delete them first so have clean env, to ensure scheduledDowntimeDepth start at 1
create_test_hosts( \@test_hosts );

# create and assign to test groups 
my @test_hostgroups = ( "test_group1", "test_group2" );
assign_to_hostgroup(  $test_hostgroups[0] , \@host_set1 );
assign_to_hostgroup(  $test_hostgroups[1] , \@host_set2 ) ;

# attach some services to a couple of the hosts
attach_services_to_a_host( "ahost1");
attach_services_to_a_host( "ahost2");

# Set all hosts in test_group1 into downtime ie this just increments the downtime depth
my $dt = {
        "hostNames" => [ "*" ],
        "hostGroupNames" => [ $test_hostgroups[0] ] # test_group1
};

# Set the hosts in the hostgroup to be all in downtime
# Setting them again will keep incrementing scheduledDowntimeDepth over 
@results = ();
is $rest_api->set_indowntime( $dt, {}, \%outcome, \@results ) , 1 , "set indowntime for all hosts in hostgroup $test_hostgroups[0]";
$logger->debug(  Dumper \%outcome, \@results ) ; 
# Inspect the results a bit more closely - expecting %outcome to look like this :
#{
#  'bizHostServiceInDowntimes' => [
#    {
#      'entityName' => 'test_group1',
#      'entityType' => 'HOSTGROUP',
#      'hostName' => 'ahost4',
#      'scheduledDowntimeDepth' => 1
#    },
#    {
#      'entityName' => 'test_group1',
#      'entityType' => 'HOSTGROUP',
#      'hostName' => 'ahost2',
#      'scheduledDowntimeDepth' => 1
#    },
#    {
#      'entityName' => 'test_group1',
#      'entityType' => 'HOSTGROUP',
#      'hostName' => 'ahost3',
#      'scheduledDowntimeDepth' => 1
#    },
#    {
#      'entityName' => 'test_group1',
#      'entityType' => 'HOSTGROUP',
#      'hostName' => 'ahost1',
#      'scheduledDowntimeDepth' => 1
#    }
#  ]
#};

# @results should be empty and not defined => all went without error 
is ( (@results = undef ) , 1 , "Results not defined as expected - time to rename results for this test!");
# Should have 4 elements in the outcome bizHostServiceInDowntimes array
my $size = scalar @{$outcome{bizHostServiceInDowntimes}};
is $size == 4 , 1, "Got expected number of results - got $size";
$logger->error( Dumper \%outcome, \@results );
# Check they all have depth = 1
for ( my $i=0; $i<4; $i++) {
	is ( ( defined $outcome{bizHostServiceInDowntimes}[0]{scheduledDowntimeDepth} and $outcome{bizHostServiceInDowntimes}[0]{scheduledDowntimeDepth} == 1 ) , 1, "Checking setindowntime $i: got expected depth"  );
}

# you can put any old crap in here - the API just won't return a scheduledDowntimeDepth property if it cannot figure stuff out it seems
# hostName seems to be required, and can be * - consult api docs for what's possible here.
my $get = 
{
        "bizHostServiceInDowntimes" => [
                {
			# This block will return what was sent and non scheduledDowntimeDepth property
                        #"entityName" => "test_group1",
                        "entityType" => "_not_an_entity_1234",
                        "hostName" => $unlikely_host
                },
                {
			# This block will return what was sent and scheduledDowntimeDepth = 1
                        "entityName" => "non_existent_hostgroup_entity",
                        "entityType" => "HOSTGROUP", 
                        "hostName" => "ahost4" # the API seems to match on this 
                }
        ]
};

is  $rest_api->get_indowntime( $get, { }, \%outcome, \@results ), 1, "Get downtimes for some hosts";
$logger->debug(  Dumper \%outcome, \@results ) ; 

# check that scheduledDowntimeDepth is present and 1 for ahost4
is ( ( defined $outcome{bizHostServiceInDowntimes}[1]{scheduledDowntimeDepth} and $outcome{bizHostServiceInDowntimes}[1]{scheduledDowntimeDepth} == 1 ) , 1, "Checking getindowntime for a valid host that had downtime set earlier"  );

# Same sort of mechanism as get here - if something matches, and hostName at least seems required, then a scheduledDowntimeDepth prop is returned, otherwise not. 
# Missing a hostName seems to result in a status 500.
my $clear = 
{
        "bizHostServiceInDowntimes" => [
                { 	# this block should result in a scheduledDowntimeDepth prop in the results and it should be 0
                        "entityName" => "test_group1",
                        "entityType" => "HOSTGROUP",
                        "hostName" => "ahost1"
                },
                { 	# this block won't result in a scheduledDowntimeDepth prop in the results
                        "entityName" => "test_group1",
                        "entityType" => "HOSTGROUP",
                        "hostName" => $unlikely_host
                }
        ]
};


is $rest_api->clear_indowntime( $clear, { }, \%outcome, \@results ), 1, "Clear downtime for some hosts";
$logger->debug(  Dumper \%outcome, \@results ) ;

# check that scheduledDowntimeDepth is present and 0 for ahost4
is ( ( defined $outcome{bizHostServiceInDowntimes}[1]{scheduledDowntimeDepth} and $outcome{bizHostServiceInDowntimes}[1]{scheduledDowntimeDepth} == 0 ) , 1, "Checking clear_indowntime worked"  );
$logger->debug(  Dumper \%outcome, \@results ) ;

# TBD more tests. 

# ========
done();
# ========

# ----------------------------------------------------------------------------------------------------------------------
sub delete_test_hosts
{
	my ( $hosts_ref ) = @_;
 	if ( not $rest_api->delete_hosts( $hosts_ref, {}, \%outcome, \@results ) ) {
		$logger->error("Failed to delete hosts : " . Dumper \%outcome, \@results );
		return 0;
	}
	return 1;
}
# ----------------------------------------------------------------------------------------------------------------------
sub create_test_hosts
{
	# creates some test hosts
	my ( $hosts_ref ) = @_;
	my ( @hosts ) ;
	foreach  my $host  ( @{$hosts_ref} ) {
	    push @hosts,
		{
			"hostName"             => $host,
			"description"          => "CREATED at " . localtime,
			"monitorStatus"        => "UP",
			"appType"              => "NAGIOS",
			"deviceIdentification" => $host,
			"monitorServer"        => "localhost",
			"deviceDisplayName"    => $host,
			"properties"           => { "Latency" => "125", "UpdatedBy" => "admin", "Comments" => "Blacklists testing host" }
		};
	    }
    
	    if ( not $rest_api->upsert_hosts(  \@hosts, {}, \%outcome, \@results )  ) {
	       $logger->error("Failed to build test hosts : " . Dumper \%outcome, \@results);
	       return 0;
	    }

    return 1;

}

# ----------------------------------------------------------------------------------------------------------------------
sub clear
{
	system("clear");
	print "=" x 80 . "\n";
}

# ----------------------------------------------------------------------------------------------------------------------
sub show_and_die 
{
	my ( $dontdie ) = @_;
	#clear(); 
	print "=" x 80 . "\n";
	$rest_api->get_hostidentities( [ ] , { }, \%outcome, \%results ); 
	print "GET ALL : " . Dumper \%outcome, \%results; 
	if ( not defined $dontdie )  {
		done_testing();
		$rest_api = undef;
 		exit;
	}
}

# ----------------------------------------------------------------------------------------------------------------------
sub array_contains
{
	my ( $array_ref, $search_item ) = @_;
	( grep {$_ eq $search_item} @{$array_ref} ) ? return 1: return 0;
}

# ----------------------------------------------------------------------------------------------------------------------
sub assign_to_hostgroup
{
	my ( $hostgroup_name, $hosts_array_ref ) = @_;

	# create the hostgroup and put the hosts in it
	my @hostgroups = (
    		{
			"name"        => $hostgroup_name,
			"description" => "CREATED at " . localtime,
			"alias"       => "Alias for $hostgroup_name",
			"hosts"       => $hosts_array_ref
    		}
	);

	if ( not $rest_api->upsert_hostgroups( \@hostgroups, {}, \%outcome, \@results ) ) {
	       $logger->error("Failed to build test hostgroup and assign hosts : " . Dumper \%outcome, \@results);
		return 0;
        }

	return 1;
}

sub attach_services_to_a_host
{
	# tries to attach service_1 and service_2 to $host
	my ( $host ) = @_;
	my @services = (
    	   {
		'lastCheckTime'        => '2013-05-22T09:36:47-07:00',
		'deviceIdentification' => $host,
		'nextCheckTime'        => '2013-05-22T09:46:47-07:00',
		'lastHardState'        => 'PENDING',
		'monitorStatus'        => 'OK',
		'description'          => "service_1",
		'properties' => { 'Latency' => '950', 'ExecutionTime' => '7', 'MaxAttempts' => '3', 'LastPluginOutput' => 'ORIGINAL output from test service' },
		'stateType'       => 'HARD',
		'hostName'        => $host,
		'appType'         => 'NAGIOS',
		'monitorServer'   => 'localhost',
		'checkType'       => 'ACTIVE',
		'lastStateChange' => '2013-05-22T09:36:47-07:00'
    	   },
    	   {
		'lastCheckTime'        => '2013-05-22T09:36:47-07:00',
		'deviceIdentification' => $host,
		'nextCheckTime'        => '2013-05-22T09:46:47-07:00',
		'lastHardState'        => 'PENDING',
		'monitorStatus'        => 'OK',
		'description'          => "service_2",
		'properties' => { 'Latency' => '950', 'ExecutionTime' => '7', 'MaxAttempts' => '3', 'LastPluginOutput' => 'ORIGINAL output from test service' },
		'stateType'       => 'HARD',
		'hostName'        => $host,
		'appType'         => 'NAGIOS',
		'monitorServer'   => 'localhost',
		'checkType'       => 'ACTIVE',
		'lastStateChange' => '2013-05-22T09:36:47-07:00'
    	   },
	);
	
	if ( not  $rest_api->upsert_services( \@services, {}, \%outcome, \@results ) ) { 
		$logger->error("Failed to attach service to host : " . Dumper \%outcome, \@results );
		return 0;
	}

	return 1;
}


# ----------------------------------------------------------------------------------------------------------------------
sub done
{
	$logger->debug("----- END $0 tests ----"); 
	done_testing(); 
	$rest_api = undef; exit;
}

